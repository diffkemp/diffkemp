; ModuleID = 'tests/regression/kernel_modules/firewire-sbp2/firewire-sbp2_new.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %struct.dev_archdata }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, %struct.kernel_symbol*, i32*, i32, i32, %struct.kernel_symbol*, i32*, i8, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [56 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, i32, i64*, i8, i8, %struct.klp_modinfo*, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, void ()**, i32, [36 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, %struct.delayed_work, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qspinlock = type { %struct.atomic_t }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.hlist_node, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.lockdep_map, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)*, %struct.lock_class_key }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %union.anon.3, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.0, %struct.list_head, %struct.list_head, %union.anon.57 }
%struct.seqcount = type { i32, %struct.lockdep_map }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%struct.lockref = type { %union.anon.51 }
%union.anon.51 = type { %struct.anon.52 }
%struct.anon.52 = type { %struct.spinlock, i32 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %union.anon.3, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, [32 x i8], %struct.list_lru, [40 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %struct.qspinlock, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.6, %union.anon.3, %union.anon.3, %union.anon.0, %union.anon.3, %struct.mem_cgroup* }
%union.anon.6 = type { %struct.address_space* }
%struct.mem_cgroup = type opaque
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.atomic_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %union.anon.3, %struct.list_head, %struct.raw_spinlock, %struct.qspinlock, %struct.task_struct*, %struct.lockdep_map }
%struct.task_struct = type { %union.anon.3, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, %struct.hlist_head, i32, i32, i32, %struct.cpumask, i64, i8, %struct.list_head, i32, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %union.anon.0, i64, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.atomic_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, i32, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.callback_head, %struct.list_head, %struct.numa_group*, i64*, i64, [3 x i64], i64, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.bio_vec, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, i32, i32, i8*, %struct.kcov*, %struct.mem_cgroup*, i32, i32, i32, %struct.uprobe_task*, i32, i32, i64, i32, %struct.task_struct*, %struct.atomic_t, %struct.thread_struct }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [8 x i8], [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [128 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %union.anon.3*, %struct.atomic_t, %struct.atomic_t, %union.anon.3, %union.anon.3, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.task_struct*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, %struct.cpumask, i64, i64, i32, i8, %struct.uprobes_state, %union.anon.3, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %union.anon.3, i64, %struct.timerqueue_node, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type { %struct.userfaultfd_ctx* }
%struct.userfaultfd_ctx = type opaque
%struct.mm_rss_stat = type { [4 x %union.anon.3] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16, i8* }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.8 }
%union.anon.8 = type { %struct.anon.9 }
%struct.anon.9 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type opaque
%struct.sighand_struct = type opaque
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, %struct.ww_acquire_ctx*, i8* }
%struct.ww_acquire_ctx = type opaque
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32, i32 }
%struct.bio_list = type { %struct.bio*, %struct.bio* }
%struct.bio = type { %struct.bio*, %struct.block_device*, i32, i32, i16, i16, %struct.bvec_iter, i32, i32, i32, %struct.atomic_t, void (%struct.bio*)*, i8*, %struct.io_context*, %struct.cgroup_subsys_state*, %union.anon.15, i16, i16, %struct.atomic_t, %struct.bio_vec*, %struct.bio_set*, [0 x %struct.bio_vec] }
%struct.bvec_iter = type { i64, i32, i32, i32 }
%struct.cgroup_subsys_state = type opaque
%union.anon.15 = type { %struct.bio_integrity_payload* }
%struct.bio_integrity_payload = type { %struct.bio*, %struct.bvec_iter, void (%struct.bio*)*, i16, i16, i16, i16, %struct.work_struct, %struct.bio_vec*, [0 x %struct.bio_vec] }
%struct.bio_set = type { %struct.kmem_cache*, i32, %struct.mempool_s*, %struct.mempool_s*, %struct.mempool_s*, %struct.mempool_s*, %struct.spinlock, %struct.bio_list, %struct.work_struct, %struct.workqueue_struct* }
%struct.kmem_cache = type opaque
%struct.mempool_s = type { %struct.spinlock, i32, i32, i8**, i8*, i8* (i32, i8*)*, void (i8*, i8*)*, %struct.__wait_queue_head }
%struct.blk_plug = type { %struct.list_head, %struct.list_head, %struct.list_head }
%struct.reclaim_state = type opaque
%struct.io_context = type { %union.anon.3, %struct.atomic_t, %struct.atomic_t, %struct.spinlock, i16, i32, i64, %struct.radix_tree_root, %struct.io_cq*, %struct.hlist_head, %struct.work_struct }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%struct.io_cq = type { %struct.request_queue*, %struct.io_context*, %union.anon.0, %union.anon.57, i32 }
%struct.request_queue = type { %struct.list_head, %struct.request*, %struct.elevator_queue*, [2 x i32], i32, %struct.rq_wb*, %struct.request_list, void (%struct.request_queue*)*, i32 (%struct.request_queue*, %struct.bio*)*, i32 (%struct.request_queue*, %struct.request*)*, void (%struct.request_queue*, %struct.request*)*, void (%struct.request*)*, i32 (%struct.request*)*, i32 (%struct.request*)*, i32 (%struct.request_queue*)*, i32 (%struct.request_queue*, %struct.request*, i32)*, void (%struct.request_queue*, %struct.request*)*, %struct.blk_mq_ops*, i32*, %struct.blk_mq_ctx*, i32, i32, %struct.blk_mq_hw_ctx**, i32, i64, %struct.request*, %struct.delayed_work, %struct.backing_dev_info*, i8*, i64, i32, i32, %struct.spinlock, %struct.spinlock*, %struct.kobject, %struct.kobject, %struct.blk_integrity, %struct.device*, i32, i32, i64, i32, i32, i32, i32, i8*, i32, i32, %struct.blk_queue_tag*, %struct.list_head, i32, [2 x i32], [2 x %struct.blk_rq_stat], i32, i32, i32, %struct.timer_list, %struct.work_struct, %struct.list_head, %struct.list_head, [1 x i64], %struct.blkcg_gq*, %struct.list_head, %struct.queue_limits, i32, i32, i32, %struct.blk_trace*, %struct.blk_flush_queue*, %struct.list_head, %struct.spinlock, %struct.delayed_work, %struct.mutex, i32, %struct.atomic_t, i32 (%struct.bsg_job*)*, i32, %struct.bsg_class_device, %struct.throtl_data*, %struct.callback_head, %struct.__wait_queue_head, %struct.percpu_ref, %struct.list_head, %struct.blk_mq_tag_set*, %struct.list_head, %struct.bio_set*, %struct.dentry*, %struct.dentry*, i8, i64, i8* }
%struct.elevator_queue = type { %struct.elevator_type*, i8*, %struct.kobject, %struct.mutex, i8, [64 x %struct.hlist_head] }
%struct.elevator_type = type { %struct.kmem_cache*, %union.anon.62, i64, i64, %struct.elv_fs_entry*, [16 x i8], %struct.module*, i8, [21 x i8], %struct.list_head }
%union.anon.62 = type { %struct.elevator_ops }
%struct.elevator_ops = type { i32 (%struct.request_queue*, %struct.request**, %struct.bio*)*, void (%struct.request_queue*, %struct.request*, i32)*, void (%struct.request_queue*, %struct.request*, %struct.request*)*, i32 (%struct.request_queue*, %struct.request*, %struct.bio*)*, i32 (%struct.request_queue*, %struct.request*, %struct.request*)*, void (%struct.request_queue*, %struct.request*, %struct.bio*)*, i32 (%struct.request_queue*, i32)*, void (%struct.request_queue*, %struct.request*)*, void (%struct.request_queue*, %struct.request*)*, void (%struct.request_queue*, %struct.request*)*, void (%struct.request_queue*, %struct.request*)*, %struct.request* (%struct.request_queue*, %struct.request*)*, %struct.request* (%struct.request_queue*, %struct.request*)*, void (%struct.io_cq*)*, void (%struct.io_cq*)*, i32 (%struct.request_queue*, %struct.request*, %struct.bio*, i32)*, void (%struct.request*)*, i32 (%struct.request_queue*, i32)*, i32 (%struct.request_queue*, %struct.elevator_type*)*, void (%struct.elevator_queue*)*, void (%struct.request_queue*)* }
%struct.elv_fs_entry = type { %struct.attribute, i64 (%struct.elevator_queue*, i8*)*, i64 (%struct.elevator_queue*, i8*, i64)* }
%struct.rq_wb = type opaque
%struct.request_list = type { %struct.request_queue*, %struct.blkcg_gq*, [2 x i32], [2 x i32], %struct.mempool_s*, [2 x %struct.__wait_queue_head], i32 }
%struct.blk_mq_ops = type { i32 (%struct.blk_mq_hw_ctx*, %struct.blk_mq_queue_data*)*, i32 (%struct.request*, i1)*, i32 (%struct.blk_mq_hw_ctx*, i32)*, void (%struct.request*)*, i32 (%struct.blk_mq_hw_ctx*, i8*, i32)*, void (%struct.blk_mq_hw_ctx*, i32)*, i32 (i8*, %struct.request*, i32, i32, i32)*, void (i8*, %struct.request*, i32, i32)*, i32 (i8*, %struct.request*)*, i32 (%struct.blk_mq_tag_set*)* }
%struct.blk_mq_hw_ctx = type { %struct.anon.63, %struct.work_struct, %struct.cpumask*, i32, i32, i64, i8*, %struct.request_queue*, %struct.blk_flush_queue*, i8*, %struct.sbitmap, %struct.blk_mq_ctx**, i32, %struct.__wait_queue, %struct.atomic_t, %struct.blk_mq_tags*, %struct.blk_mq_tags*, %struct.srcu_struct, i64, i64, [7 x i64], i32, i32, %struct.atomic_t, %struct.delayed_work, %struct.delayed_work, %struct.hlist_node, %struct.kobject, i64, i64, i64, [56 x i8] }
%struct.anon.63 = type { %struct.spinlock, %struct.list_head, i64, [32 x i8] }
%struct.sbitmap = type { i32, i32, i32, %struct.sbitmap_word* }
%struct.sbitmap_word = type { i64, i64, [48 x i8] }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%struct.blk_mq_tags = type opaque
%struct.srcu_struct = type { i64, %struct.srcu_array*, %struct.spinlock, i8, %struct.rcu_batch, %struct.rcu_batch, %struct.rcu_batch, %struct.rcu_batch, %struct.delayed_work, %struct.lockdep_map }
%struct.srcu_array = type { [2 x i64], [2 x i64] }
%struct.rcu_batch = type { %struct.callback_head*, %struct.callback_head** }
%struct.blk_mq_queue_data = type { %struct.request*, %struct.list_head*, i8 }
%struct.blk_mq_ctx = type opaque
%struct.request = type { %struct.list_head, %union.anon.56, %struct.request_queue*, %struct.blk_mq_ctx*, i32, i32, i32, i32, i64, i32, i32, i64, %struct.bio*, %struct.bio*, %union.anon.57, %union.anon.64, %union.anon.59, %struct.gendisk*, %struct.hd_struct*, i64, %union.anon.3, %struct.request_list*, i64, i64, i16, i16, i16, i8*, i32, i32, i64, %struct.list_head, i32, i32, void (%struct.request*, i32)*, i8*, %struct.request* }
%union.anon.56 = type { %struct.call_single_data }
%struct.call_single_data = type { %struct.llist_node, void (i8*)*, i8*, i32 }
%union.anon.64 = type { %struct.rb_node }
%union.anon.59 = type { %struct.anon.61 }
%struct.anon.61 = type { i32, %struct.list_head, void (%struct.request*, i32)* }
%struct.gendisk = type { i32, i32, i32, [32 x i8], i8* (%struct.gendisk*, i16*)*, i32, i32, %struct.disk_part_tbl*, %struct.hd_struct, %struct.block_device_operations*, %struct.request_queue*, i8*, i32, %struct.kobject*, %struct.timer_rand_state*, %struct.atomic_t, %struct.disk_events*, %struct.kobject, i32, %struct.badblocks* }
%struct.disk_part_tbl = type { %struct.callback_head, i32, %struct.hd_struct*, [0 x %struct.hd_struct*] }
%struct.hd_struct = type { i64, i64, %struct.seqcount, i64, i32, %struct.device, %struct.kobject*, i32, i32, %struct.partition_meta_info*, i32, i64, [2 x %struct.atomic_t], %struct.disk_stats*, %struct.percpu_ref, %struct.callback_head }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.dev_pin_info*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.cma*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.atomic_t, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head, %struct.pm_domain_data* }
%struct.pm_domain_data = type opaque
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dev_pin_info = type { %struct.pinctrl*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state* }
%struct.pinctrl = type opaque
%struct.pinctrl_state = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.cma = type opaque
%struct.device_node = type opaque
%struct.fwnode_handle = type opaque
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.partition_meta_info = type { [37 x i8], [64 x i8] }
%struct.disk_stats = type { [2 x i64], [2 x i64], [2 x i64], [2 x i64], i64, i64 }
%struct.block_device_operations = type { i32 (%struct.block_device*, i32)*, void (%struct.gendisk*, i32)*, i32 (%struct.block_device*, i64, %struct.page*, i1)*, i32 (%struct.block_device*, i32, i32, i64)*, i32 (%struct.block_device*, i32, i32, i64)*, i64 (%struct.block_device*, i64, i8**, %union.anon.3*, i64)*, i32 (%struct.gendisk*, i32)*, i32 (%struct.gendisk*)*, void (%struct.gendisk*)*, i32 (%struct.gendisk*)*, i32 (%struct.block_device*, %struct.hd_geometry*)*, void (%struct.block_device*, i64)*, %struct.module*, %struct.pr_ops* }
%struct.hd_geometry = type opaque
%struct.pr_ops = type opaque
%struct.timer_rand_state = type opaque
%struct.disk_events = type opaque
%struct.badblocks = type opaque
%struct.blk_integrity = type { %struct.blk_integrity_profile*, i8, i8, i8, i8 }
%struct.blk_integrity_profile = type { i32 (%struct.blk_integrity_iter*)*, i32 (%struct.blk_integrity_iter*)*, i8* }
%struct.blk_integrity_iter = type { i8*, i8*, i64, i32, i16, i8* }
%struct.blk_queue_tag = type { %struct.request**, i64*, i32, i32, %struct.atomic_t, i32, i32 }
%struct.blk_rq_stat = type { i64, i64, i64, i32, i32, i64, i64 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32, %struct.lockdep_map }
%struct.blkcg_gq = type opaque
%struct.queue_limits = type { i64, i64, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i8, i8, i8, i8, i8, i32 }
%struct.blk_trace = type opaque
%struct.blk_flush_queue = type opaque
%struct.bsg_job = type opaque
%struct.bsg_class_device = type { %struct.device*, %struct.device*, i32, %struct.request_queue*, %struct.kref, void (%struct.device*)* }
%struct.throtl_data = type opaque
%struct.percpu_ref = type { %union.anon.3, i64, void (%struct.percpu_ref*)*, void (%struct.percpu_ref*)*, i8, %struct.callback_head }
%struct.blk_mq_tag_set = type { i32*, %struct.blk_mq_ops*, i32, i32, i32, i32, i32, i32, i32, i8*, %struct.blk_mq_tags**, %struct.mutex, %struct.list_head }
%struct.siginfo = type { i32, i32, i32, %union.anon.16 }
%union.anon.16 = type { %struct.anon.20, [80 x i8] }
%struct.anon.20 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.numa_group = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.bio_vec = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.kcov = type opaque
%struct.uprobe_task = type { i32, %union.anon.26, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.26 = type { %struct.anon.27 }
%struct.anon.27 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %union.anon.3, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.29 }
%union.anon.29 = type { %struct.anon.30 }
%struct.anon.30 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.32, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.35 }
%union.anon.32 = type { %struct.timespec }
%struct.timespec = type { i64, i64 }
%union.anon.35 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.backing_dev_info = type { %struct.list_head, i64, i64, i32 (i8*, i32)*, i8*, i8*, %struct.kref, i32, i32, i32, i32, %union.anon.3, %struct.bdi_writeback, %struct.list_head, %struct.radix_tree_root, %struct.rb_root, %struct.atomic_t, %struct.__wait_queue_head, %struct.device*, %struct.device*, %struct.timer_list, %struct.dentry*, %struct.dentry* }
%struct.bdi_writeback = type { %struct.backing_dev_info*, i64, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.spinlock, [4 x %struct.percpu_counter], %struct.bdi_writeback_congested*, i64, i64, i64, i64, i64, i64, i64, %struct.fprop_local_percpu, i32, %struct.spinlock, %struct.list_head, %struct.delayed_work, i64, %struct.list_head, %struct.percpu_ref, %struct.fprop_local_percpu, %struct.cgroup_subsys_state*, %struct.cgroup_subsys_state*, %struct.list_head, %struct.list_head, %union.anon.12 }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.bdi_writeback_congested = type { i64, %struct.atomic_t, %struct.backing_dev_info*, i32, %struct.rb_node }
%struct.fprop_local_percpu = type { %struct.percpu_counter, i32, %struct.raw_spinlock }
%union.anon.12 = type { %struct.work_struct }
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %union.anon.3* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type opaque
%struct.list_lru = type { %struct.list_lru_node*, %struct.list_head }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, %struct.list_lru_memcg*, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.list_lru_memcg = type { [0 x %struct.list_lru_one*] }
%struct.work_struct = type { %union.anon.3, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%union.anon.0 = type { %struct.list_head }
%union.anon.57 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.atomic_t, %struct.atomic_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %struct.atomic_t, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.bdi_writeback*, i32, i16, i16, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.2, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.50, i32, i32, %struct.hlist_head, %struct.fscrypt_info*, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.atomic_t, %struct.atomic_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.atomic_t, %struct.atomic_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type opaque
%struct.swap_info_struct = type opaque
%union.anon.50 = type { %struct.pipe_inode_info* }
%struct.fscrypt_info = type opaque
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type opaque
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.48 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.48 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%union.anon.3 = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.atomic_t, %struct.atomic_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.64, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.3, i64, %struct.atomic_t, %struct.atomic_t, i32, i16, i16, i64, %union.anon.66, %union.anon.68, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%struct.key_user = type opaque
%union.anon.66 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.68 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %union.anon.3, i64, i64, i64, %union.anon.3, %struct.key*, %struct.key*, %struct.hlist_node, %struct.atomic_t, %union.anon.3 }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.atomic_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %union.anon.3*, %union.anon.3*, %union.anon.3, %struct.page*, %struct.mem_cgroup*, %struct.page*, %union.anon.3*, %struct.spinlock*, %struct.page* }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.qspinlock }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %union.anon.3, %struct.spinlock, %struct.qspinlock, %struct.list_head, i8*, %struct.lockdep_map }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.qspinlock, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.klp_modinfo = type { %struct.elf64_hdr, %struct.elf64_shdr*, i8*, i32 }
%struct.elf64_hdr = type { [16 x i8], i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 }
%struct.elf64_shdr = type { i32, i32, i64, i64, i64, i64, i32, i32, i64, i64 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.dev_archdata = type { i8* }
%struct.ieee1394_device_id = type { i32, i32, i32, i32, i32, i64 }
%struct.fw_driver = type { %struct.device_driver, i32 (%struct.fw_unit*, %struct.ieee1394_device_id*)*, void (%struct.fw_unit*)*, void (%struct.fw_unit*)*, %struct.ieee1394_device_id* }
%struct.fw_unit = type { %struct.device, i32*, %struct.fw_attribute_group }
%struct.fw_attribute_group = type { [2 x %struct.attribute_group*], %struct.attribute_group, [13 x %struct.attribute*] }
%struct.scsi_host_template = type { %struct.module*, i8*, i32 (%struct.scsi_host_template*)*, i32 (%struct.Scsi_Host*)*, i8* (%struct.Scsi_Host*)*, i32 (%struct.scsi_device*, i32, i8*)*, i32 (%struct.scsi_device*, i32, i8*)*, i32 (%struct.Scsi_Host*, %struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_device*)*, i32 (%struct.scsi_device*)*, void (%struct.scsi_device*)*, i32 (%struct.scsi_target*)*, void (%struct.scsi_target*)*, i32 (%struct.Scsi_Host*, i64)*, void (%struct.Scsi_Host*)*, i32 (%struct.scsi_device*, i32)*, i32 (%struct.Scsi_Host*)*, i32 (%struct.scsi_device*, %struct.block_device*, i64, i32*)*, void (%struct.scsi_device*)*, i32 (%struct.seq_file*, %struct.Scsi_Host*)*, i32 (%struct.Scsi_Host*, i8*, i32)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.Scsi_Host*, i32)*, i8*, %struct.proc_dir_entry*, i32, i32, i16, i16, i32, i64, i16, i8, i32, i16, i32, %struct.device_attribute**, %struct.device_attribute**, %struct.list_head, i64, i32, %struct.scsi_host_cmd_pool* }
%struct.Scsi_Host = type { %struct.list_head, %struct.list_head, %struct.list_head, %struct.spinlock, %struct.spinlock*, %struct.mutex, %struct.list_head, %struct.task_struct*, %struct.completion*, %struct.__wait_queue_head, %struct.scsi_host_template*, %struct.scsi_transport_template*, %union.anon.70, %struct.atomic_t, %struct.atomic_t, i32, i32, i32, i32, i64, i32, i32, i64, i32, i16, i32, i32, i16, i16, i16, i32, i64, i32, i64, i16, [20 x i8], %struct.workqueue_struct*, %struct.workqueue_struct*, i8, i32, i32, i8, %struct.request_queue*, i64, i64, i8, i8, i32, i32, %struct.device, %struct.device, %struct.list_head, i8*, %struct.device*, [0 x i64] }
%struct.scsi_transport_template = type opaque
%union.anon.70 = type { %struct.blk_mq_tag_set }
%struct.scsi_device = type { %struct.Scsi_Host*, %struct.request_queue*, %struct.list_head, %struct.list_head, %struct.atomic_t, %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.list_head, i16, i16, i16, i16, i64, i64, i64, i32, i32, i64, i32, i32, i8*, i8, i8, i8, %struct.mutex, i8, i8*, i8*, i8*, i8*, i32, i8*, i32, i8*, i8, %struct.scsi_target*, i32, i32, i48, %struct.atomic_t, [1 x i64], [1 x i64], %struct.list_head, %struct.work_struct, i32, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.device, %struct.device, %union.anon.12, %struct.work_struct, %struct.scsi_device_handler*, i8*, i8, i32, [0 x i64] }
%struct.scsi_target = type { %struct.scsi_device*, %struct.list_head, %struct.list_head, %struct.device, %struct.kref, i32, i32, i8, %struct.atomic_t, %struct.atomic_t, i32, i32, i8, i32, i8*, [0 x i64] }
%struct.scsi_device_handler = type opaque
%struct.scsi_cmnd = type { %struct.scsi_request, %struct.scsi_device*, %struct.list_head, %struct.list_head, %struct.delayed_work, i32, i64, i64, i32, i32, i8, i8, i8, i16, i32, i8*, %struct.scsi_data_buffer, %struct.scsi_data_buffer*, i32, i32, %struct.request*, i8*, void (%struct.scsi_cmnd*)*, %struct.scsi_pointer, i8*, i32, i32, i8 }
%struct.scsi_request = type { [16 x i8], i8*, i16, i32, i32, i8* }
%struct.scsi_data_buffer = type { %struct.sg_table, i32, i32 }
%struct.scsi_pointer = type { i8*, i32, %struct.scatterlist*, i32, i64, i32, i32, i32, i32, i32 }
%struct.proc_dir_entry = type opaque
%struct.scsi_host_cmd_pool = type opaque
%struct.fw_device = type { %struct.atomic_t, %struct.fw_node*, i32, i32, i32, %struct.fw_card*, %struct.device, %struct.mutex, %struct.list_head, i32*, i64, i32, i16, void (%struct.work_struct*)*, %struct.delayed_work, %struct.fw_attribute_group }
%struct.fw_node = type opaque
%struct.fw_card = type { %struct.fw_card_driver*, %struct.device*, %struct.kref, %struct.completion, i32, i32, i32, i64, %struct.list_head, i64, i32, i32, i32, i32, i64, i32, i32, i32, %struct.spinlock, %struct.fw_node*, %struct.fw_node*, %struct.fw_node*, i8, i32, i8, i32, %struct.list_head, %struct.list_head, %struct.delayed_work, i8, %struct.delayed_work, i32, i32, i32, i8, i8, i8, i8, i32, [256 x i32], i32 }
%struct.fw_card_driver = type opaque
%struct.sbp2_target = type { %struct.fw_unit*, %struct.list_head, i64, i64, i32, i32, i32, i32, i32, i32, %struct.spinlock, i32, i32 }
%struct.sbp2_logical_unit = type { %struct.sbp2_target*, %struct.list_head, %struct.fw_address_handler, %struct.list_head, i64, i16, i32, i32, i32, void (%struct.work_struct*)*, %struct.delayed_work, i8, i8 }
%struct.fw_address_handler = type { i64, i64, void (%struct.fw_card*, %struct.fw_request*, i32, i32, i32, i32, i64, i8*, i64, i8*)*, i8*, %struct.list_head }
%struct.fw_request = type opaque
%struct.scsi_lun = type { [8 x i8] }
%struct.sbp2_management_orb = type { %struct.sbp2_orb, %struct.anon.78, [4 x i32], i64, %struct.completion, %struct.sbp2_status }
%struct.sbp2_orb = type { %struct.fw_transaction, %struct.kref, i64, i32, void (%struct.sbp2_orb*, %struct.sbp2_status*)*, %struct.sbp2_logical_unit*, %struct.list_head }
%struct.fw_transaction = type { i32, i32, %struct.list_head, %struct.fw_card*, i8, %struct.timer_list, %struct.fw_packet, void (%struct.fw_card*, i32, i8*, i64, i8*)*, i8* }
%struct.fw_packet = type { i32, i32, [4 x i32], i64, i8*, i64, i64, i8, i32, void (%struct.fw_packet*, %struct.fw_card*, i32)*, i32, %struct.list_head, i8* }
%struct.anon.78 = type { %struct.anon.30, %struct.anon.30, i32, i32, %struct.anon.30 }
%struct.sbp2_status = type { i32, i32, [24 x i8] }
%union.anon.74 = type { %struct.list_head* }
%struct.fw_csr_iterator = type { i32*, i32* }
%struct.sbp2_login_response = type { i32, %struct.anon.30, i32 }
%struct.sbp2_command_orb = type { %struct.sbp2_orb, %struct.anon.71, %struct.scsi_cmnd*, [128 x %struct.anon.30], i64 }
%struct.anon.71 = type { %struct.anon.30, %struct.anon.30, i32, [16 x i8] }

@llvm.used = appending global [10 x i8*] [i8* bitcast (%struct.kernel_param* @__param_exclusive_login to i8*), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__UNIQUE_ID_exclusive_logintype36, i32 0, i32 0), i8* getelementptr inbounds ([99 x i8], [99 x i8]* @__UNIQUE_ID_exclusive_login37, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_workarounds to i8*), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__UNIQUE_ID_workaroundstype38, i32 0, i32 0), i8* getelementptr inbounds ([272 x i8], [272 x i8]* @__UNIQUE_ID_workarounds39, i32 0, i32 0), i8* getelementptr inbounds ([46 x i8], [46 x i8]* @__UNIQUE_ID_author48, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__UNIQUE_ID_description49, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license50, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__UNIQUE_ID_alias51, i32 0, i32 0)], section "llvm.metadata"
@__param_exclusive_login = internal constant %struct.kernel_param { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__param_str_exclusive_login, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 420, i8 -1, i8 0, %struct.dev_archdata { i8* @sbp2_param_exclusive_login } }, section "__param", align 8
@__UNIQUE_ID_exclusive_logintype36 = internal constant [30 x i8] c"parmtype=exclusive_login:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_exclusive_login37 = internal constant [99 x i8] c"parm=exclusive_login:Exclusive login to sbp2 device (default = Y, use N for concurrent initiators)\00", section ".modinfo", align 1
@__param_workarounds = internal constant %struct.kernel_param { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__param_str_workarounds, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 420, i8 -1, i8 0, %struct.dev_archdata { i8* bitcast (i32* @sbp2_param_workarounds to i8*) } }, section "__param", align 8
@__UNIQUE_ID_workaroundstype38 = internal constant [25 x i8] c"parmtype=workarounds:int\00", section ".modinfo", align 1
@__UNIQUE_ID_workarounds39 = internal constant [272 x i8] c"parm=workarounds:Work around device bugs (default = 0, 128kB max transfer = 0x1, 36 byte inquiry = 0x2, skip mode page 8 = 0x4, fix capacity = 0x8, delay inquiry = 0x10, set power condition in start stop unit = 0x20, override internal blacklist = 0x100, or a combination)\00", section ".modinfo", align 1
@__UNIQUE_ID_author48 = internal constant [46 x i8] c"author=Kristian Hoegsberg <krh@bitplanet.net>\00", section ".modinfo", align 1
@__UNIQUE_ID_description49 = internal constant [31 x i8] c"description=SCSI over IEEE1394\00", section ".modinfo", align 1
@__UNIQUE_ID_license50 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__UNIQUE_ID_alias51 = internal constant [11 x i8] c"alias=sbp2\00", section ".modinfo", align 1
@__param_str_workarounds = internal constant [12 x i8] c"workarounds\00", align 1
@__this_module = external global %struct.module, align 64
@param_ops_int = external constant %struct.kernel_param_ops, align 8
@sbp2_param_workarounds = internal global i32 0, align 4
@__param_str_exclusive_login = internal constant [16 x i8] c"exclusive_login\00", align 16
@param_ops_bool = external constant %struct.kernel_param_ops, align 8
@sbp2_param_exclusive_login = internal global i8 1, align 1
@sbp2_id_table = internal constant [2 x %struct.ieee1394_device_id] [%struct.ieee1394_device_id { i32 12, i32 0, i32 0, i32 24734, i32 66691, i64 0 }, %struct.ieee1394_device_id zeroinitializer], align 16
@sbp2_driver = internal global %struct.fw_driver { %struct.device_driver { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str, i32 0, i32 0), %struct.bus_type* @fw_bus_type, %struct.module* @__this_module, i8* null, i8 0, i32 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* null, %struct.driver_private* null }, i32 (%struct.fw_unit*, %struct.ieee1394_device_id*)* @sbp2_probe, void (%struct.fw_unit*)* @sbp2_update, void (%struct.fw_unit*)* @sbp2_remove, %struct.ieee1394_device_id* getelementptr inbounds ([2 x %struct.ieee1394_device_id], [2 x %struct.ieee1394_device_id]* @sbp2_id_table, i32 0, i32 0) }, align 8
@.str = private unnamed_addr constant [14 x i8] c"firewire_sbp2\00", align 1
@fw_bus_type = external global %struct.bus_type, align 8
@.str.27 = private unnamed_addr constant [24 x i8] c"released target %d:0:0\0A\00", align 1
@.str.18 = private unnamed_addr constant [35 x i8] c"ORB reply timed out, rcode 0x%02x\0A\00", align 1
@.str.19 = private unnamed_addr constant [39 x i8] c"management write failed, rcode 0x%02x\0A\00", align 1
@.str.20 = private unnamed_addr constant [21 x i8] c"error status: %d:%d\0A\00", align 1
@.str.7 = private unnamed_addr constant [23 x i8] c"./include/linux/kref.h\00", align 1
@.str.6 = private unnamed_addr constant [30 x i8] c"./include/linux/dma-mapping.h\00", align 1
@dma_ops = external global %struct.dma_map_ops*, align 8
@.str.21 = private unnamed_addr constant [9 x i8] c"&x->wait\00", align 1
@init_completion.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@vmemmap_base = external global i64, align 8
@fw_workqueue = external global %struct.workqueue_struct*, align 8
@.str.1 = private unnamed_addr constant [24 x i8] c"drivers/firewire/sbp2.c\00", align 1
@scsi_driver_template = internal global { %struct.module*, i8*, i32 (%struct.scsi_host_template*)*, i32 (%struct.Scsi_Host*)*, i8* (%struct.Scsi_Host*)*, i32 (%struct.scsi_device*, i32, i8*)*, i32 (%struct.scsi_device*, i32, i8*)*, i32 (%struct.Scsi_Host*, %struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_device*)*, i32 (%struct.scsi_device*)*, void (%struct.scsi_device*)*, i32 (%struct.scsi_target*)*, void (%struct.scsi_target*)*, i32 (%struct.Scsi_Host*, i64)*, void (%struct.Scsi_Host*)*, i32 (%struct.scsi_device*, i32)*, i32 (%struct.Scsi_Host*)*, i32 (%struct.scsi_device*, %struct.block_device*, i64, i32*)*, void (%struct.scsi_device*)*, i32 (%struct.seq_file*, %struct.Scsi_Host*)*, i32 (%struct.Scsi_Host*, i8*, i32)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.Scsi_Host*, i32)*, i8*, %struct.proc_dir_entry*, i32, i32, i16, i16, i32, i64, i16, i8, i32, i8, i8, i32, %struct.device_attribute**, %struct.device_attribute**, %struct.list_head, i64, i32, %struct.scsi_host_cmd_pool* } { %struct.module* @__this_module, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.3, i32 0, i32 0), i32 (%struct.scsi_host_template*)* null, i32 (%struct.Scsi_Host*)* null, i8* (%struct.Scsi_Host*)* null, i32 (%struct.scsi_device*, i32, i8*)* null, i32 (%struct.scsi_device*, i32, i8*)* null, i32 (%struct.Scsi_Host*, %struct.scsi_cmnd*)* @sbp2_scsi_queuecommand, i32 (%struct.scsi_cmnd*)* @sbp2_scsi_abort, i32 (%struct.scsi_cmnd*)* null, i32 (%struct.scsi_cmnd*)* null, i32 (%struct.scsi_cmnd*)* null, i32 (%struct.scsi_cmnd*)* null, i32 (%struct.scsi_device*)* @sbp2_scsi_slave_alloc, i32 (%struct.scsi_device*)* @sbp2_scsi_slave_configure, void (%struct.scsi_device*)* null, i32 (%struct.scsi_target*)* null, void (%struct.scsi_target*)* null, i32 (%struct.Scsi_Host*, i64)* null, void (%struct.Scsi_Host*)* null, i32 (%struct.scsi_device*, i32)* null, i32 (%struct.Scsi_Host*)* null, i32 (%struct.scsi_device*, %struct.block_device*, i64, i32*)* null, void (%struct.scsi_device*)* null, i32 (%struct.seq_file*, %struct.Scsi_Host*)* null, i32 (%struct.Scsi_Host*, i8*, i32)* null, i32 (%struct.scsi_cmnd*)* null, i32 (%struct.Scsi_Host*, i32)* null, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), %struct.proc_dir_entry* null, i32 1, i32 -1, i16 128, i16 0, i32 0, i64 0, i16 0, i8 0, i32 0, i8 16, i8 0, i32 0, %struct.device_attribute** null, %struct.device_attribute** getelementptr inbounds ([2 x %struct.device_attribute*], [2 x %struct.device_attribute*]* @sbp2_scsi_sysfs_attrs, i32 0, i32 0), %struct.list_head zeroinitializer, i64 0, i32 0, %struct.scsi_host_cmd_pool* null }, align 8
@.str.2 = private unnamed_addr constant [21 x i8] c"&(&tgt->lock)->rlock\00", align 1
@sbp2_probe.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.25 = private unnamed_addr constant [82 x i8] c"Please notify linux1394-devel@lists.sf.net if you need the workarounds parameter\0A\00", align 1
@sbp2_workarounds_table = internal constant [11 x %struct.exception_table_entry] [%struct.exception_table_entry { i32 10240, i32 4112, i32 38 }, %struct.exception_table_entry { i32 10240, i32 0, i32 32 }, %struct.exception_table_entry { i32 512, i32 -1, i32 2 }, %struct.exception_table_entry { i32 75776, i32 -1, i32 32 }, %struct.exception_table_entry { i32 10532864, i32 -1, i32 1 }, %struct.exception_table_entry { i32 9728, i32 -1, i32 1 }, %struct.exception_table_entry { i32 665344, i32 0, i32 9 }, %struct.exception_table_entry { i32 665344, i32 33, i32 8 }, %struct.exception_table_entry { i32 665344, i32 34, i32 8 }, %struct.exception_table_entry { i32 665344, i32 35, i32 8 }, %struct.exception_table_entry { i32 665344, i32 126, i32 8 }], align 16
@.str.26 = private unnamed_addr constant [62 x i8] c"workarounds 0x%x (firmware_revision 0x%06x, model_id 0x%06x)\0A\00", align 1
@.str.24 = private unnamed_addr constant [36 x i8] c"%ds mgt_ORB_timeout limited to 40s\0A\00", align 1
@fw_high_memory_region = external constant %struct.timespec, align 8
@.str.11 = private unnamed_addr constant [21 x i8] c"(&(&lu->work)->work)\00", align 1
@sbp2_add_logical_unit.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.13 = private unnamed_addr constant [22 x i8] c"(&(&lu->work)->timer)\00", align 1
@sbp2_add_logical_unit.__key.12 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.16 = private unnamed_addr constant [29 x i8] c"failed to login to LUN %04x\0A\00", align 1
@.str.17 = private unnamed_addr constant [36 x i8] c"logged in to LUN %04x (%d retries)\0A\00", align 1
@.str.22 = private unnamed_addr constant [21 x i8] c"failed to reconnect\0A\00", align 1
@.str.23 = private unnamed_addr constant [38 x i8] c"reconnected to LUN %04x (%d retries)\0A\00", align 1
@.str.14 = private unnamed_addr constant [43 x i8] c"non-ORB related status write, not handled\0A\00", align 1
@.str.15 = private unnamed_addr constant [30 x i8] c"status write for unknown ORB\0A\00", align 1
@.str.3 = private unnamed_addr constant [16 x i8] c"SBP-2 IEEE-1394\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c"sbp2\00", align 1
@sbp2_scsi_sysfs_attrs = internal global [2 x %struct.device_attribute*] [%struct.device_attribute* @dev_attr_ieee1394_id, %struct.device_attribute* null], align 16
@dev_attr_ieee1394_id = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.9, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sbp2_sysfs_ieee1394_id_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.9 = private unnamed_addr constant [12 x i8] c"ieee1394_id\00", align 1
@.str.10 = private unnamed_addr constant [19 x i8] c"%016llx:%06x:%04x\0A\00", align 1
@.str.8 = private unnamed_addr constant [17 x i8] c"sbp2_scsi_abort\0A\00", align 1
@sbp2_agent_reset_no_wait.d = internal global i32 0, align 4

@__mod_ieee1394__sbp2_id_table_device_table = alias [2 x %struct.ieee1394_device_id], [2 x %struct.ieee1394_device_id]* @sbp2_id_table
@init_module = alias i32 (), i32 ()* @sbp2_init
@cleanup_module = alias void (), void ()* @sbp2_cleanup

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_init() #0 section ".init.text" {
entry:
  %call = call i32 @driver_register(%struct.device_driver* getelementptr inbounds (%struct.fw_driver, %struct.fw_driver* @sbp2_driver, i32 0, i32 0))
  ret i32 %call
}

declare i32 @driver_register(%struct.device_driver*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_probe(%struct.fw_unit* %unit, %struct.ieee1394_device_id* %id) #2 {
entry:
  %model = alloca i32, align 4
  %firmware_revision = alloca i32, align 4
  %__UNIQUE_ID_min1_46 = alloca i32, align 4
  %__UNIQUE_ID_min1_44 = alloca i32, align 4
  %__UNIQUE_ID_min2_45 = alloca i32, align 4
  %__UNIQUE_ID_min2_47 = alloca i32, align 4
  %call = call %struct.fw_device* @fw_parent_device(%struct.fw_unit* %unit)
  %0 = bitcast i32* %model to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = bitcast i32* %firmware_revision to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  %is_local = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 12
  %bf.load = load i16, i16* %is_local, align 4
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %2 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %device1 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %2, i32 0, i32 1
  %3 = load %struct.device*, %struct.device** %device1, align 8, !tbaa !35
  %call2 = call i32 @dma_get_max_seg_size(%struct.device* %3)
  %cmp = icmp ugt i32 %call2, 65532
  br i1 %cmp, label %if.then3, label %if.end24

if.then3:                                         ; preds = %if.end
  %card4 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %4 = load %struct.fw_card*, %struct.fw_card** %card4, align 8, !tbaa !2
  %device5 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %4, i32 0, i32 1
  %5 = load %struct.device*, %struct.device** %device5, align 8, !tbaa !35
  %call6 = call i32 @dma_set_max_seg_size(%struct.device* %5, i32 65532)
  %tobool7 = icmp ne i32 %call6, 0
  %lnot = xor i1 %tobool7, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv = sext i32 %lnot.ext13 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.then3
  call void @warn_slowpath_null(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.1, i32 0, i32 0), i32 1149)
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.then3
  %tobool17 = icmp ne i32 %lnot.ext, 0
  %lnot18 = xor i1 %tobool17, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %expval23 = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  br label %if.end24

if.end24:                                         ; preds = %if.end16, %if.end
  %call25 = call %struct.Scsi_Host* @scsi_host_alloc(%struct.scsi_host_template* bitcast ({ %struct.module*, i8*, i32 (%struct.scsi_host_template*)*, i32 (%struct.Scsi_Host*)*, i8* (%struct.Scsi_Host*)*, i32 (%struct.scsi_device*, i32, i8*)*, i32 (%struct.scsi_device*, i32, i8*)*, i32 (%struct.Scsi_Host*, %struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_device*)*, i32 (%struct.scsi_device*)*, void (%struct.scsi_device*)*, i32 (%struct.scsi_target*)*, void (%struct.scsi_target*)*, i32 (%struct.Scsi_Host*, i64)*, void (%struct.Scsi_Host*)*, i32 (%struct.scsi_device*, i32)*, i32 (%struct.Scsi_Host*)*, i32 (%struct.scsi_device*, %struct.block_device*, i64, i32*)*, void (%struct.scsi_device*)*, i32 (%struct.seq_file*, %struct.Scsi_Host*)*, i32 (%struct.Scsi_Host*, i8*, i32)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.Scsi_Host*, i32)*, i8*, %struct.proc_dir_entry*, i32, i32, i16, i16, i32, i64, i16, i8, i32, i8, i8, i32, %struct.device_attribute**, %struct.device_attribute**, %struct.list_head, i64, i32, %struct.scsi_host_cmd_pool* }* @scsi_driver_template to %struct.scsi_host_template*), i32 144)
  %cmp26 = icmp eq %struct.Scsi_Host* %call25, null
  br i1 %cmp26, label %cleanup, label %if.end29

if.end29:                                         ; preds = %if.end24
  %hostdata = getelementptr inbounds %struct.Scsi_Host, %struct.Scsi_Host* %call25, i32 0, i32 54
  %arraydecay = getelementptr inbounds [0 x i64], [0 x i64]* %hostdata, i32 0, i32 0
  %6 = bitcast i64* %arraydecay to %struct.sbp2_target*
  %device30 = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %unit, i32 0, i32 0
  %7 = bitcast %struct.sbp2_target* %6 to i8*
  call void @dev_set_drvdata(%struct.device* %device30, i8* %7)
  %unit31 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 0
  store %struct.fw_unit* %unit, %struct.fw_unit** %unit31, align 8, !tbaa !37
  %lu_list = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %lu_list)
  %lock = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 10
  %call32 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %lock34 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 10
  %8 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock34, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %8 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.2, i32 0, i32 0), %struct.lock_class_key* @sbp2_probe.__key)
  %config_rom = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 9
  %9 = load i32*, i32** %config_rom, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i32, i32* %9, i64 3
  %10 = load i32, i32* %arrayidx, align 4, !tbaa !40
  %conv37 = zext i32 %10 to i64
  %shl = shl i64 %conv37, 32
  %config_rom38 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 9
  %11 = load i32*, i32** %config_rom38, align 8, !tbaa !39
  %arrayidx39 = getelementptr inbounds i32, i32* %11, i64 4
  %12 = load i32, i32* %arrayidx39, align 4, !tbaa !40
  %conv40 = zext i32 %12 to i64
  %or = or i64 %shl, %conv40
  %guid = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 3
  store i64 %or, i64* %guid, align 8, !tbaa !41
  %call41 = call i32 @fw_device_enable_phys_dma(%struct.fw_device* %call)
  %cmp42 = icmp slt i32 %call41, 0
  br i1 %cmp42, label %fail_shost_put, label %if.end45

if.end45:                                         ; preds = %if.end29
  %max_cmd_len = getelementptr inbounds %struct.Scsi_Host, %struct.Scsi_Host* %call25, i32 0, i32 24
  store i16 16, i16* %max_cmd_len, align 4, !tbaa !42
  %device46 = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %unit, i32 0, i32 0
  %card47 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %13 = load %struct.fw_card*, %struct.fw_card** %card47, align 8, !tbaa !2
  %device48 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %13, i32 0, i32 1
  %14 = load %struct.device*, %struct.device** %device48, align 8, !tbaa !35
  %call49 = call i32 @scsi_add_host_with_dma(%struct.Scsi_Host* %call25, %struct.device* %device46, %struct.device* %14)
  %cmp50 = icmp slt i32 %call49, 0
  br i1 %cmp50, label %fail_shost_put, label %if.end53

if.end53:                                         ; preds = %if.end45
  %directory = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %unit, i32 0, i32 1
  %15 = load i32*, i32** %directory, align 8, !tbaa !45
  %config_rom54 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 9
  %16 = load i32*, i32** %config_rom54, align 8, !tbaa !39
  %sub.ptr.lhs.cast = ptrtoint i32* %15 to i64
  %sub.ptr.rhs.cast = ptrtoint i32* %16 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %mul = mul nsw i64 %sub.ptr.div, 4
  %add = add nsw i64 %mul, 1024
  %and = and i64 %add, 16777215
  %conv55 = trunc i64 %and to i32
  %directory_id = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 4
  store i32 %conv55, i32* %directory_id, align 8, !tbaa !47
  store i32 -16777216, i32* %firmware_revision, align 4, !tbaa !40
  store i32 -16777216, i32* %model, align 4, !tbaa !40
  %directory56 = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %unit, i32 0, i32 1
  %17 = load i32*, i32** %directory56, align 8, !tbaa !45
  %call57 = call i32 @sbp2_scan_unit_dir(%struct.sbp2_target* %6, i32* %17, i32* %model, i32* %firmware_revision)
  %cmp58 = icmp slt i32 %call57, 0
  br i1 %cmp58, label %fail_remove, label %if.end61

if.end61:                                         ; preds = %if.end53
  call void @sbp2_clamp_management_orb_timeout(%struct.sbp2_target* %6)
  %18 = load i32, i32* %model, align 4, !tbaa !40
  %19 = load i32, i32* %firmware_revision, align 4, !tbaa !40
  call void @sbp2_init_workarounds(%struct.sbp2_target* %6, i32 %18, i32 %19)
  %20 = bitcast i32* %__UNIQUE_ID_min1_46 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %20) #8
  %21 = bitcast i32* %__UNIQUE_ID_min1_44 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %21) #8
  %max_speed = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 4
  %22 = load i32, i32* %max_speed, align 8, !tbaa !48
  %add62 = add i32 %22, 7
  store i32 %add62, i32* %__UNIQUE_ID_min1_44, align 4, !tbaa !40
  %23 = bitcast i32* %__UNIQUE_ID_min2_45 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %23) #8
  store i32 10, i32* %__UNIQUE_ID_min2_45, align 4, !tbaa !40
  %cmp63 = icmp eq i32* %__UNIQUE_ID_min1_44, %__UNIQUE_ID_min2_45
  %conv64 = zext i1 %cmp63 to i32
  %24 = load i32, i32* %__UNIQUE_ID_min1_44, align 4, !tbaa !40
  %25 = load i32, i32* %__UNIQUE_ID_min2_45, align 4, !tbaa !40
  %cmp66 = icmp ult i32 %24, %25
  %26 = load i32, i32* %__UNIQUE_ID_min1_44, align 4
  %27 = load i32, i32* %__UNIQUE_ID_min2_45, align 4
  %cond = select i1 %cmp66, i32 %26, i32 %27
  %28 = bitcast i32* %__UNIQUE_ID_min2_45 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %28) #8
  %29 = bitcast i32* %__UNIQUE_ID_min1_44 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %29) #8
  store i32 %cond, i32* %__UNIQUE_ID_min1_46, align 4, !tbaa !40
  %30 = bitcast i32* %__UNIQUE_ID_min2_47 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %30) #8
  %card68 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %31 = load %struct.fw_card*, %struct.fw_card** %card68, align 8, !tbaa !2
  %max_receive = getelementptr inbounds %struct.fw_card, %struct.fw_card* %31, i32 0, i32 15
  %32 = load i32, i32* %max_receive, align 8, !tbaa !49
  %sub = sub i32 %32, 1
  store i32 %sub, i32* %__UNIQUE_ID_min2_47, align 4, !tbaa !40
  %cmp69 = icmp eq i32* %__UNIQUE_ID_min1_46, %__UNIQUE_ID_min2_47
  %conv70 = zext i1 %cmp69 to i32
  %33 = load i32, i32* %__UNIQUE_ID_min1_46, align 4, !tbaa !40
  %34 = load i32, i32* %__UNIQUE_ID_min2_47, align 4, !tbaa !40
  %cmp72 = icmp ult i32 %33, %34
  %35 = load i32, i32* %__UNIQUE_ID_min1_46, align 4
  %36 = load i32, i32* %__UNIQUE_ID_min2_47, align 4
  %cond77 = select i1 %cmp72, i32 %35, i32 %36
  %37 = bitcast i32* %__UNIQUE_ID_min2_47 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %37) #8
  %38 = bitcast i32* %__UNIQUE_ID_min1_46 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %38) #8
  %max_payload = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 9
  store i32 %cond77, i32* %max_payload, align 4, !tbaa !50
  %lu_list78 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 1
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end61
  %link84.sink = phi %struct.list_head* [ %link84, %for.body ], [ %lu_list78, %if.end61 ]
  %next85 = getelementptr inbounds %struct.list_head, %struct.list_head* %link84.sink, i32 0, i32 0
  %39 = load %struct.list_head*, %struct.list_head** %next85, align 8, !tbaa !51
  %40 = bitcast %struct.list_head* %39 to i8*
  %add.ptr87 = getelementptr inbounds i8, i8* %40, i64 -8
  %41 = bitcast i8* %add.ptr87 to %struct.sbp2_logical_unit*
  %link = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %41, i32 0, i32 1
  %lu_list80 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 1
  %cmp81 = icmp ne %struct.list_head* %link, %lu_list80
  br i1 %cmp81, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  call void @sbp2_queue_work(%struct.sbp2_logical_unit* %41, i64 50)
  %link84 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %41, i32 0, i32 1
  br label %for.cond

fail_remove:                                      ; preds = %if.end53
  call void @sbp2_remove(%struct.fw_unit* %unit)
  br label %cleanup

fail_shost_put:                                   ; preds = %if.end45, %if.end29
  call void @scsi_host_put(%struct.Scsi_Host* %call25)
  br label %cleanup

cleanup:                                          ; preds = %fail_shost_put, %fail_remove, %for.cond, %if.end24, %entry
  %retval.0 = phi i32 [ -12, %fail_shost_put ], [ -12, %fail_remove ], [ -19, %entry ], [ -12, %if.end24 ], [ 0, %for.cond ]
  %42 = bitcast i32* %firmware_revision to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %42) #8
  %43 = bitcast i32* %model to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %43) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_update(%struct.fw_unit* %unit) #2 {
entry:
  %device = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %unit, i32 0, i32 0
  %call = call i8* @dev_get_drvdata(%struct.device* %device)
  %0 = bitcast i8* %call to %struct.sbp2_target*
  %call1 = call %struct.fw_device* @fw_parent_device(%struct.fw_unit* %unit)
  %call2 = call i32 @fw_device_enable_phys_dma(%struct.fw_device* %call1)
  %lu_list = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 1
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %link5.sink = phi %struct.list_head* [ %link5, %for.body ], [ %lu_list, %entry ]
  %next6 = getelementptr inbounds %struct.list_head, %struct.list_head* %link5.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next6, align 8, !tbaa !51
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr8 = getelementptr inbounds i8, i8* %2, i64 -8
  %3 = bitcast i8* %add.ptr8 to %struct.sbp2_logical_unit*
  %link = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %3, i32 0, i32 1
  %lu_list3 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %link, %lu_list3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @sbp2_conditionally_block(%struct.sbp2_logical_unit* %3)
  %retries = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %3, i32 0, i32 8
  store i32 0, i32* %retries, align 4, !tbaa !52
  call void @sbp2_queue_work(%struct.sbp2_logical_unit* %3, i64 0)
  %link5 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %3, i32 0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_remove(%struct.fw_unit* %unit) #2 {
entry:
  %call = call %struct.fw_device* @fw_parent_device(%struct.fw_unit* %unit)
  %device1 = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %unit, i32 0, i32 0
  %call2 = call i8* @dev_get_drvdata(%struct.device* %device1)
  %0 = bitcast i8* %call2 to %struct.sbp2_target*
  %1 = bitcast %struct.sbp2_target* %0 to i8*
  %2 = bitcast i8* %1 to i64*
  %3 = bitcast i64* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -3744
  %4 = bitcast i8* %add.ptr to %struct.Scsi_Host*
  call void @sbp2_unblock(%struct.sbp2_target* %0)
  %lu_list = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 1
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %lu_list, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next4, align 8, !tbaa !55
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr6 = getelementptr inbounds i8, i8* %6, i64 -8
  %7 = bitcast i8* %add.ptr6 to %struct.sbp2_logical_unit*
  br label %for.cond

for.cond:                                         ; preds = %if.end23, %entry
  %.sink = phi %struct.sbp2_logical_unit* [ %10, %if.end23 ], [ %7, %entry ]
  %lu.0 = phi %struct.sbp2_logical_unit* [ %7, %entry ], [ %10, %if.end23 ]
  %link26 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %.sink, i32 0, i32 1
  %next27 = getelementptr inbounds %struct.list_head, %struct.list_head* %link26, i32 0, i32 0
  %8 = load %struct.list_head*, %struct.list_head** %next27, align 8, !tbaa !56
  %9 = bitcast %struct.list_head* %8 to i8*
  %add.ptr29 = getelementptr inbounds i8, i8* %9, i64 -8
  %10 = bitcast i8* %add.ptr29 to %struct.sbp2_logical_unit*
  %link11 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu.0, i32 0, i32 1
  %lu_list12 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %link11, %lu_list12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %work = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu.0, i32 0, i32 10
  %call13 = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %work)
  %lun = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu.0, i32 0, i32 5
  %11 = load i16, i16* %lun, align 8, !tbaa !57
  %call14 = call i32 @sbp2_lun2int(i16 zeroext %11)
  %conv = sext i32 %call14 to i64
  %call15 = call %struct.scsi_device* @scsi_device_lookup(%struct.Scsi_Host* %4, i32 0, i32 0, i64 %conv)
  %tobool = icmp ne %struct.scsi_device* %call15, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  call void @scsi_remove_device(%struct.scsi_device* %call15)
  call void @scsi_device_put(%struct.scsi_device* %call15)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %login_id = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu.0, i32 0, i32 6
  %12 = load i32, i32* %login_id, align 4, !tbaa !58
  %cmp16 = icmp ne i32 %12, 65536
  br i1 %cmp16, label %if.then18, label %if.end23

if.then18:                                        ; preds = %if.end
  %generation19 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 3
  %13 = load i32, i32* %generation19, align 4, !tbaa !59
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !60
  %node_id20 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 2
  %14 = load i32, i32* %node_id20, align 8, !tbaa !61
  %login_id21 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu.0, i32 0, i32 6
  %15 = load i32, i32* %login_id21, align 4, !tbaa !58
  %call22 = call i32 @sbp2_send_management_orb(%struct.sbp2_logical_unit* %lu.0, i32 %14, i32 %13, i32 7, i32 %15, i8* null)
  br label %if.end23

if.end23:                                         ; preds = %if.then18, %if.end
  %address_handler = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu.0, i32 0, i32 2
  call void @fw_core_remove_address_handler(%struct.fw_address_handler* %address_handler)
  %link24 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu.0, i32 0, i32 1
  call void @list_del(%struct.list_head* %link24)
  %16 = bitcast %struct.sbp2_logical_unit* %lu.0 to i8*
  call void @kfree(i8* %16)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @scsi_remove_host(%struct.Scsi_Host* %4)
  %device30 = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %unit, i32 0, i32 0
  %host_no = getelementptr inbounds %struct.Scsi_Host, %struct.Scsi_Host* %4, i32 0, i32 17
  %17 = load i32, i32* %host_no, align 8, !tbaa !62
  call void (%struct.device*, i8*, ...) @dev_notice(%struct.device* %device30, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.27, i32 0, i32 0), i32 %17)
  call void @scsi_host_put(%struct.Scsi_Host* %4)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.fw_device* @fw_parent_device(%struct.fw_unit* %unit) #3 {
entry:
  %device = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %unit, i32 0, i32 0
  %parent = getelementptr inbounds %struct.device, %struct.device* %device, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !63
  %call = call %struct.fw_device* @fw_device(%struct.device* %0)
  ret %struct.fw_device* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata(%struct.device* %dev) #3 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !64
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_unblock(%struct.sbp2_target* %tgt) #2 {
entry:
  %0 = bitcast %struct.sbp2_target* %tgt to i8*
  %1 = bitcast i8* %0 to i64*
  %2 = bitcast i64* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -3744
  %3 = bitcast i8* %add.ptr to %struct.Scsi_Host*
  %lock = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 10
  call void @spin_lock_irq(%struct.spinlock* %lock)
  %dont_block = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 11
  %4 = load i32, i32* %dont_block, align 8, !tbaa !65
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %dont_block, align 8, !tbaa !65
  %lock1 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 10
  call void @spin_unlock_irq(%struct.spinlock* %lock1)
  call void @scsi_unblock_requests(%struct.Scsi_Host* %3)
  ret void
}

declare zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_lun2int(i16 zeroext %lun) #2 {
entry:
  %eight_bytes_lun = alloca %struct.scsi_lun, align 1
  %0 = bitcast %struct.scsi_lun* %eight_bytes_lun to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast %struct.scsi_lun* %eight_bytes_lun to i8*
  %call = call i8* @__memset(i8* %1, i32 0, i64 8)
  %conv = zext i16 %lun to i32
  %shr = ashr i32 %conv, 8
  %and = and i32 %shr, 255
  %conv1 = trunc i32 %and to i8
  %scsi_lun = getelementptr inbounds %struct.scsi_lun, %struct.scsi_lun* %eight_bytes_lun, i32 0, i32 0
  %arrayidx = getelementptr inbounds [8 x i8], [8 x i8]* %scsi_lun, i64 0, i64 0
  store i8 %conv1, i8* %arrayidx, align 1, !tbaa !66
  %conv2 = zext i16 %lun to i32
  %and3 = and i32 %conv2, 255
  %conv4 = trunc i32 %and3 to i8
  %scsi_lun5 = getelementptr inbounds %struct.scsi_lun, %struct.scsi_lun* %eight_bytes_lun, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [8 x i8], [8 x i8]* %scsi_lun5, i64 0, i64 1
  store i8 %conv4, i8* %arrayidx6, align 1, !tbaa !66
  %call7 = call i64 @scsilun_to_int(%struct.scsi_lun* %eight_bytes_lun)
  %conv8 = trunc i64 %call7 to i32
  %2 = bitcast %struct.scsi_lun* %eight_bytes_lun to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  ret i32 %conv8
}

declare %struct.scsi_device* @scsi_device_lookup(%struct.Scsi_Host*, i32, i32, i64) #1

declare void @scsi_remove_device(%struct.scsi_device*) #1

declare void @scsi_device_put(%struct.scsi_device*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_send_management_orb(%struct.sbp2_logical_unit* %lu, i32 %node_id, i32 %generation, i32 %function, i32 %lun_or_login_id, i8* %response) #2 {
entry:
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %cmp = icmp eq i32 %function, 7
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call2 = call i32 @fw_device_is_shutdown(%struct.fw_device* %call)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %call3 = call i8* @kzalloc(i64 496, i32 20971520)
  %1 = bitcast i8* %call3 to %struct.sbp2_management_orb*
  %cmp4 = icmp eq %struct.sbp2_management_orb* %1, null
  br i1 %cmp4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %base = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %kref = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base, i32 0, i32 1
  call void @kref_init(%struct.kref* %kref)
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %2 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %device7 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %2, i32 0, i32 1
  %3 = load %struct.device*, %struct.device** %device7, align 8, !tbaa !35
  %response8 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 2
  %4 = bitcast [4 x i32]* %response8 to i8*
  %call9 = call i64 @dma_map_single_attrs(%struct.device* %3, i8* %4, i64 16, i32 2, i64 0)
  %response_bus = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 3
  store i64 %call9, i64* %response_bus, align 8, !tbaa !68
  %card10 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %5 = load %struct.fw_card*, %struct.fw_card** %card10, align 8, !tbaa !2
  %device11 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %5, i32 0, i32 1
  %6 = load %struct.device*, %struct.device** %device11, align 8, !tbaa !35
  %response_bus12 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 3
  %7 = load i64, i64* %response_bus12, align 8, !tbaa !68
  %call13 = call i32 @dma_mapping_error(%struct.device* %6, i64 %7)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %fail_mapping_response, label %if.end16

if.end16:                                         ; preds = %if.end6
  %request = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %response17 = getelementptr inbounds %struct.anon.78, %struct.anon.78* %request, i32 0, i32 1
  %high = getelementptr inbounds %struct.anon.30, %struct.anon.30* %response17, i32 0, i32 0
  store i32 0, i32* %high, align 8, !tbaa !76
  %response_bus18 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 3
  %8 = load i64, i64* %response_bus18, align 8, !tbaa !68
  %conv = trunc i64 %8 to i32
  %call19 = call i32 @__fswab32(i32 %conv) #7
  %request20 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %response21 = getelementptr inbounds %struct.anon.78, %struct.anon.78* %request20, i32 0, i32 1
  %low = getelementptr inbounds %struct.anon.30, %struct.anon.30* %response21, i32 0, i32 1
  store i32 %call19, i32* %low, align 4, !tbaa !77
  %shl = shl i32 %function, 16
  %or = or i32 -2147483648, %shl
  %or22 = or i32 %or, %lun_or_login_id
  %call23 = call i32 @__fswab32(i32 %or22) #7
  %request24 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %misc = getelementptr inbounds %struct.anon.78, %struct.anon.78* %request24, i32 0, i32 2
  store i32 %call23, i32* %misc, align 8, !tbaa !78
  %request25 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %length = getelementptr inbounds %struct.anon.78, %struct.anon.78* %request25, i32 0, i32 3
  store i32 268435456, i32* %length, align 4, !tbaa !79
  %address_handler = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 2
  %offset = getelementptr inbounds %struct.fw_address_handler, %struct.fw_address_handler* %address_handler, i32 0, i32 0
  %9 = load i64, i64* %offset, align 8, !tbaa !80
  %shr = lshr i64 %9, 32
  %conv26 = trunc i64 %shr to i32
  %call27 = call i32 @__fswab32(i32 %conv26) #7
  %request28 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %status_fifo = getelementptr inbounds %struct.anon.78, %struct.anon.78* %request28, i32 0, i32 4
  %high29 = getelementptr inbounds %struct.anon.30, %struct.anon.30* %status_fifo, i32 0, i32 0
  store i32 %call27, i32* %high29, align 8, !tbaa !81
  %address_handler30 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 2
  %offset31 = getelementptr inbounds %struct.fw_address_handler, %struct.fw_address_handler* %address_handler30, i32 0, i32 0
  %10 = load i64, i64* %offset31, align 8, !tbaa !80
  %conv32 = trunc i64 %10 to i32
  %call33 = call i32 @__fswab32(i32 %conv32) #7
  %request34 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %status_fifo35 = getelementptr inbounds %struct.anon.78, %struct.anon.78* %request34, i32 0, i32 4
  %low36 = getelementptr inbounds %struct.anon.30, %struct.anon.30* %status_fifo35, i32 0, i32 1
  store i32 %call33, i32* %low36, align 4, !tbaa !82
  %cmp37 = icmp eq i32 %function, 0
  br i1 %cmp37, label %if.then39, label %if.end48

if.then39:                                        ; preds = %if.end16
  %11 = load i8, i8* @sbp2_param_exclusive_login, align 1, !tbaa !83, !range !84
  %tobool40 = trunc i8 %11 to i1
  %12 = zext i1 %tobool40 to i64
  %cond = select i1 %tobool40, i32 268435456, i32 0
  %or42 = or i32 2097152, %cond
  %call43 = call i32 @__fswab32(i32 %or42) #7
  %request44 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %misc45 = getelementptr inbounds %struct.anon.78, %struct.anon.78* %request44, i32 0, i32 2
  %13 = load i32, i32* %misc45, align 8, !tbaa !78
  %or46 = or i32 %13, %call43
  store i32 %or46, i32* %misc45, align 8, !tbaa !78
  %tgt47 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %14 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt47, align 8, !tbaa !67
  %mgt_orb_timeout = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %14, i32 0, i32 8
  %15 = load i32, i32* %mgt_orb_timeout, align 8, !tbaa !85
  br label %if.end48

if.end48:                                         ; preds = %if.then39, %if.end16
  %timeout.0 = phi i32 [ %15, %if.then39 ], [ 2000, %if.end16 ]
  %done = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 4
  call void @init_completion(%struct.completion* %done)
  %base49 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %callback = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base49, i32 0, i32 4
  store void (%struct.sbp2_orb*, %struct.sbp2_status*)* @complete_management_orb, void (%struct.sbp2_orb*, %struct.sbp2_status*)** %callback, align 8, !tbaa !86
  %card50 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %16 = load %struct.fw_card*, %struct.fw_card** %card50, align 8, !tbaa !2
  %device51 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %16, i32 0, i32 1
  %17 = load %struct.device*, %struct.device** %device51, align 8, !tbaa !35
  %request52 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %18 = bitcast %struct.anon.78* %request52 to i8*
  %call53 = call i64 @dma_map_single_attrs(%struct.device* %17, i8* %18, i64 32, i32 1, i64 0)
  %base54 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %request_bus = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base54, i32 0, i32 2
  store i64 %call53, i64* %request_bus, align 8, !tbaa !87
  %card55 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %19 = load %struct.fw_card*, %struct.fw_card** %card55, align 8, !tbaa !2
  %device56 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %19, i32 0, i32 1
  %20 = load %struct.device*, %struct.device** %device56, align 8, !tbaa !35
  %base57 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %request_bus58 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base57, i32 0, i32 2
  %21 = load i64, i64* %request_bus58, align 8, !tbaa !87
  %call59 = call i32 @dma_mapping_error(%struct.device* %20, i64 %21)
  %tobool60 = icmp ne i32 %call59, 0
  br i1 %tobool60, label %fail_mapping_request, label %if.end62

if.end62:                                         ; preds = %if.end48
  %base63 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %tgt64 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %22 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt64, align 8, !tbaa !67
  %management_agent_address = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %22, i32 0, i32 2
  %23 = load i64, i64* %management_agent_address, align 8, !tbaa !88
  call void @sbp2_send_orb(%struct.sbp2_orb* %base63, %struct.sbp2_logical_unit* %lu, i32 %node_id, i32 %generation, i64 %23)
  %done65 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 4
  %call66 = call i64 @msecs_to_jiffies(i32 %timeout.0)
  %call67 = call i64 @wait_for_completion_timeout(%struct.completion* %done65, i64 %call66)
  %call68 = call i32 @sbp2_cancel_orbs(%struct.sbp2_logical_unit* %lu)
  %cmp69 = icmp eq i32 %call68, 0
  br i1 %cmp69, label %if.then71, label %if.end74

if.then71:                                        ; preds = %if.end62
  %call72 = call %struct.device* @lu_dev(%struct.sbp2_logical_unit* %lu)
  %base73 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %rcode = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base73, i32 0, i32 3
  %24 = load i32, i32* %rcode, align 8, !tbaa !89
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %call72, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.18, i32 0, i32 0), i32 %24)
  br label %out

if.end74:                                         ; preds = %if.end62
  %base75 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %rcode76 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base75, i32 0, i32 3
  %25 = load i32, i32* %rcode76, align 8, !tbaa !89
  %cmp77 = icmp ne i32 %25, 0
  br i1 %cmp77, label %if.then79, label %if.end83

if.then79:                                        ; preds = %if.end74
  %call80 = call %struct.device* @lu_dev(%struct.sbp2_logical_unit* %lu)
  %base81 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %rcode82 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base81, i32 0, i32 3
  %26 = load i32, i32* %rcode82, align 8, !tbaa !89
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %call80, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.19, i32 0, i32 0), i32 %26)
  br label %out

if.end83:                                         ; preds = %if.end74
  %status = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 5
  %status84 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  %27 = load i32, i32* %status84, align 8, !tbaa !90
  %shr85 = lshr i32 %27, 28
  %and = and i32 %shr85, 3
  %cmp86 = icmp ne i32 %and, 0
  br i1 %cmp86, label %if.then94, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end83
  %status88 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 5
  %status89 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status88, i32 0, i32 0
  %28 = load i32, i32* %status89, align 8, !tbaa !90
  %shr90 = lshr i32 %28, 16
  %and91 = and i32 %shr90, 255
  %cmp92 = icmp ne i32 %and91, 0
  br i1 %cmp92, label %if.then94, label %out

if.then94:                                        ; preds = %lor.lhs.false, %if.end83
  %call95 = call %struct.device* @lu_dev(%struct.sbp2_logical_unit* %lu)
  %status96 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 5
  %status97 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status96, i32 0, i32 0
  %29 = load i32, i32* %status97, align 8, !tbaa !90
  %shr98 = lshr i32 %29, 28
  %and99 = and i32 %shr98, 3
  %status100 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 5
  %status101 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status100, i32 0, i32 0
  %30 = load i32, i32* %status101, align 8, !tbaa !90
  %shr102 = lshr i32 %30, 16
  %and103 = and i32 %shr102, 255
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %call95, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.20, i32 0, i32 0), i32 %and99, i32 %and103)
  br label %out

out:                                              ; preds = %if.then94, %lor.lhs.false, %if.then79, %if.then71
  %retval1.0 = phi i32 [ -5, %if.then71 ], [ -5, %if.then79 ], [ -5, %if.then94 ], [ 0, %lor.lhs.false ]
  %card105 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %31 = load %struct.fw_card*, %struct.fw_card** %card105, align 8, !tbaa !2
  %device106 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %31, i32 0, i32 1
  %32 = load %struct.device*, %struct.device** %device106, align 8, !tbaa !35
  %base107 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %request_bus108 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base107, i32 0, i32 2
  %33 = load i64, i64* %request_bus108, align 8, !tbaa !87
  call void @dma_unmap_single_attrs(%struct.device* %32, i64 %33, i64 32, i32 1, i64 0)
  br label %fail_mapping_request

fail_mapping_request:                             ; preds = %out, %if.end48
  %retval1.1 = phi i32 [ %retval1.0, %out ], [ -12, %if.end48 ]
  %card109 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %34 = load %struct.fw_card*, %struct.fw_card** %card109, align 8, !tbaa !2
  %device110 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %34, i32 0, i32 1
  %35 = load %struct.device*, %struct.device** %device110, align 8, !tbaa !35
  %response_bus111 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 3
  %36 = load i64, i64* %response_bus111, align 8, !tbaa !68
  call void @dma_unmap_single_attrs(%struct.device* %35, i64 %36, i64 16, i32 2, i64 0)
  br label %fail_mapping_response

fail_mapping_response:                            ; preds = %fail_mapping_request, %if.end6
  %retval1.2 = phi i32 [ %retval1.1, %fail_mapping_request ], [ -12, %if.end6 ]
  %tobool112 = icmp ne i8* %response, null
  br i1 %tobool112, label %if.then113, label %if.end116

if.then113:                                       ; preds = %fail_mapping_response
  %response114 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 2
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %response114, i32 0, i32 0
  %37 = bitcast i32* %arraydecay to i8*
  %call115 = call i8* @__memcpy(i8* %response, i8* %37, i64 16)
  br label %if.end116

if.end116:                                        ; preds = %if.then113, %fail_mapping_response
  %base117 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %kref118 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base117, i32 0, i32 1
  call void @kref_put(%struct.kref* %kref118, void (%struct.kref*)* @free_orb)
  br label %cleanup

cleanup:                                          ; preds = %if.end116, %if.end, %land.lhs.true
  %retval.0 = phi i32 [ %retval1.2, %if.end116 ], [ 0, %land.lhs.true ], [ -12, %if.end ]
  ret i32 %retval.0
}

declare void @fw_core_remove_address_handler(%struct.fw_address_handler*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del(%struct.list_head* %entry1) #3 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !55
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !91
  ret void
}

declare void @kfree(i8*) #1

declare void @scsi_remove_host(%struct.Scsi_Host*) #1

declare void @dev_notice(%struct.device*, i8*, ...) #1

declare void @scsi_host_put(%struct.Scsi_Host*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry(%struct.list_head* %entry1) #3 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !91
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !55
  call void @__list_del(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare zeroext i1 @__list_del_entry_valid(%struct.list_head*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del(%struct.list_head* %prev, %struct.list_head* %next) #3 {
entry:
  %__u = alloca %union.anon.74, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !91
  %0 = bitcast %union.anon.74* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %__val = bitcast %union.anon.74* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !66
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.74* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val3 = bitcast %union.anon.74* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val3, align 8, !tbaa !66
  %3 = bitcast %union.anon.74* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #4

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__write_once_size(i8* %p, i8* %res, i32 %size) #5 {
entry:
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %0 = load i8, i8* %res, align 1, !tbaa !66
  store volatile i8 %0, i8* %p, align 1, !tbaa !66
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %res to i16*
  %2 = load i16, i16* %1, align 2, !tbaa !92
  %3 = bitcast i8* %p to i16*
  store volatile i16 %2, i16* %3, align 2, !tbaa !92
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %res to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !40
  %6 = bitcast i8* %p to i32*
  store volatile i32 %5, i32* %6, align 4, !tbaa !40
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %res to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !93
  %9 = bitcast i8* %p to i64*
  store volatile i64 %8, i64* %9, align 8, !tbaa !93
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !94
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %res, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !95
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #4

; Function Attrs: nounwind uwtable
define internal %struct.fw_device* @target_parent_device(%struct.sbp2_target* %tgt) #2 {
entry:
  %unit = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 0
  %0 = load %struct.fw_unit*, %struct.fw_unit** %unit, align 8, !tbaa !37
  %call = call %struct.fw_device* @fw_parent_device(%struct.fw_unit* %0)
  ret %struct.fw_device* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @fw_device_is_shutdown(%struct.fw_device* %device) #3 {
entry:
  %state = getelementptr inbounds %struct.fw_device, %struct.fw_device* %device, i32 0, i32 0
  %call = call i32 @atomic_read(%struct.atomic_t* %state)
  %cmp = icmp eq i32 %call, 3
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init(%struct.kref* %kref) #3 {
entry:
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  call void @refcount_set(%struct.qspinlock* %refcount, i32 1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @dma_map_single_attrs(%struct.device* %dev, i8* %ptr, i64 %size, i32 %dir, i64 %attrs) #3 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %conv = trunc i64 %size to i32
  call void @kmemcheck_mark_initialized()
  %call1 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %do.body6, label %do.end11

do.body6:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.6, i32 0, i32 0), i32 209, i64 12) #8, !srcloc !96
  br label %do.body7

do.body7:                                         ; preds = %do.body7, %do.body6
  br label %do.body7

do.end11:                                         ; preds = %entry
  %map_page = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 4
  %0 = load i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)** %map_page, align 8, !tbaa !97
  %1 = load i64, i64* @vmemmap_base, align 8, !tbaa !99
  %2 = inttoptr i64 %1 to %struct.page*
  %3 = ptrtoint i8* %ptr to i64
  %call12 = call i64 @__phys_addr(i64 %3)
  %shr = lshr i64 %call12, 12
  %add.ptr = getelementptr inbounds %struct.page, %struct.page* %2, i64 %shr
  %4 = ptrtoint i8* %ptr to i64
  %and = and i64 %4, 4095
  %call13 = call i64 %0(%struct.device* %dev, %struct.page* %add.ptr, i64 %and, i64 %size, i32 %dir, i64 %attrs)
  %5 = load i64, i64* @vmemmap_base, align 8, !tbaa !99
  %6 = inttoptr i64 %5 to %struct.page*
  %7 = ptrtoint i8* %ptr to i64
  %call14 = call i64 @__phys_addr(i64 %7)
  %shr15 = lshr i64 %call14, 12
  %add.ptr16 = getelementptr inbounds %struct.page, %struct.page* %6, i64 %shr15
  %8 = ptrtoint i8* %ptr to i64
  %and17 = and i64 %8, 4095
  call void @debug_dma_map_page(%struct.device* %dev, %struct.page* %add.ptr16, i64 %and17, i64 %size, i32 %dir, i64 %call13, i1 zeroext true)
  ret i64 %call13
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @dma_mapping_error(%struct.device* %dev, i64 %dma_addr) #3 {
entry:
  call void @debug_dma_mapping_error(%struct.device* %dev, i64 %dma_addr)
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %mapping_error = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 14
  %0 = load i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)** %mapping_error, align 8, !tbaa !100
  %tobool = icmp ne i32 (%struct.device*, i64)* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %mapping_error2 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call1, i32 0, i32 14
  %1 = load i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)** %mapping_error2, align 8, !tbaa !100
  %call3 = call i32 %1(%struct.device* %dev, i64 %dma_addr)
  br label %return

if.end:                                           ; preds = %entry
  %cmp = icmp eq i64 %dma_addr, 0
  %conv = zext i1 %cmp to i32
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call3, %if.then ], [ %conv, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32(i32 %val) #6 {
entry:
  %call = call i32 @__arch_swab32(i32 %val) #7
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @init_completion(%struct.completion* %x) #3 {
entry:
  %done = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 0
  store i32 0, i32* %done, align 8, !tbaa !101
  %wait = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 1
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wait, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.21, i32 0, i32 0), %struct.lock_class_key* @init_completion.__key)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @complete_management_orb(%struct.sbp2_orb* %base_orb, %struct.sbp2_status* %status) #2 {
entry:
  %0 = bitcast %struct.sbp2_orb* %base_orb to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sbp2_management_orb*
  %tobool = icmp ne %struct.sbp2_status* %status, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %status1 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 5
  %2 = bitcast %struct.sbp2_status* %status1 to i8*
  %3 = bitcast %struct.sbp2_status* %status to i8*
  %call = call i8* @__memcpy(i8* %2, i8* %3, i64 32)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %done = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 4
  call void @complete(%struct.completion* %done)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_send_orb(%struct.sbp2_orb* %orb, %struct.sbp2_logical_unit* %lu, i32 %node_id, i32 %generation, i64 %offset) #2 {
entry:
  %orb_pointer = alloca %struct.anon.30, align 4
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %1 = bitcast %struct.anon.30* %orb_pointer to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %high = getelementptr inbounds %struct.anon.30, %struct.anon.30* %orb_pointer, i32 0, i32 0
  store i32 0, i32* %high, align 4, !tbaa !102
  %request_bus = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb, i32 0, i32 2
  %2 = load i64, i64* %request_bus, align 8, !tbaa !103
  %conv = trunc i64 %2 to i32
  %call1 = call i32 @__fswab32(i32 %conv) #7
  %low = getelementptr inbounds %struct.anon.30, %struct.anon.30* %orb_pointer, i32 0, i32 1
  store i32 %call1, i32* %low, align 4, !tbaa !104
  %lu2 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb, i32 0, i32 5
  store %struct.sbp2_logical_unit* %lu, %struct.sbp2_logical_unit** %lu2, align 8, !tbaa !105
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #8
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv4 = zext i1 %cmp to i32
  %5 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #8
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #8
  %tgt5 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %7 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt5, align 8, !tbaa !67
  %lock = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %7, i32 0, i32 10
  %call6 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call7 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call6)
  %link = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb, i32 0, i32 6
  %orb_list = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 3
  call void @list_add_tail(%struct.list_head* %link, %struct.list_head* %orb_list)
  %tgt10 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %8 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt10, align 8, !tbaa !67
  %lock11 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %8, i32 0, i32 10
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock11, i64 %call7)
  %kref = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb, i32 0, i32 1
  call void @kref_get(%struct.kref* %kref)
  %kref12 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb, i32 0, i32 1
  call void @kref_get(%struct.kref* %kref12)
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %9 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %t = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb, i32 0, i32 0
  %max_speed = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 4
  %10 = load i32, i32* %max_speed, align 8, !tbaa !48
  %11 = bitcast %struct.anon.30* %orb_pointer to i8*
  %12 = bitcast %struct.sbp2_orb* %orb to i8*
  call void @fw_send_request(%struct.fw_card* %9, %struct.fw_transaction* %t, i32 1, i32 %node_id, i32 %generation, i32 %10, i64 %offset, i8* %11, i64 8, void (%struct.fw_card*, i32, i8*, i64, i8*)* @complete_transaction, i8* %12)
  %13 = bitcast %struct.anon.30* %orb_pointer to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #8
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i64 @msecs_to_jiffies(i32 %m) #5 {
entry:
  %call = call i64 @__msecs_to_jiffies(i32 %m)
  ret i64 %call
}

declare i64 @wait_for_completion_timeout(%struct.completion*, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_cancel_orbs(%struct.sbp2_logical_unit* %lu) #2 {
entry:
  %list = alloca %struct.list_head, align 8
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %1 = bitcast %struct.list_head* %list to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %1) #8
  call void @INIT_LIST_HEAD(%struct.list_head* %list)
  %tgt2 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %2 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt2, align 8, !tbaa !67
  %lock = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %2, i32 0, i32 10
  call void @spin_lock_irq(%struct.spinlock* %lock)
  %orb_list = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 3
  call void @list_splice_init(%struct.list_head* %orb_list, %struct.list_head* %list)
  %tgt3 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %3 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt3, align 8, !tbaa !67
  %lock4 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %3, i32 0, i32 10
  call void @spin_unlock_irq(%struct.spinlock* %lock4)
  %next5 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next5, align 8, !tbaa !55
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 -296
  %6 = bitcast i8* %add.ptr to %struct.sbp2_orb*
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %.sink = phi %struct.sbp2_orb* [ %9, %for.inc ], [ %6, %entry ]
  %orb.0 = phi %struct.sbp2_orb* [ %6, %entry ], [ %9, %for.inc ]
  %retval1.0 = phi i32 [ -2, %entry ], [ 0, %for.inc ]
  %link15 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %.sink, i32 0, i32 6
  %next16 = getelementptr inbounds %struct.list_head, %struct.list_head* %link15, i32 0, i32 0
  %7 = load %struct.list_head*, %struct.list_head** %next16, align 8, !tbaa !106
  %8 = bitcast %struct.list_head* %7 to i8*
  %add.ptr18 = getelementptr inbounds i8, i8* %8, i64 -296
  %9 = bitcast i8* %add.ptr18 to %struct.sbp2_orb*
  %link10 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb.0, i32 0, i32 6
  %cmp = icmp ne %struct.list_head* %link10, %list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %10 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %t = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb.0, i32 0, i32 0
  %call11 = call i32 @fw_cancel_transaction(%struct.fw_card* %10, %struct.fw_transaction* %t)
  %cmp12 = icmp eq i32 %call11, 0
  br i1 %cmp12, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %rcode = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb.0, i32 0, i32 3
  store i32 17, i32* %rcode, align 8, !tbaa !107
  %callback = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb.0, i32 0, i32 4
  %11 = load void (%struct.sbp2_orb*, %struct.sbp2_status*)*, void (%struct.sbp2_orb*, %struct.sbp2_status*)** %callback, align 8, !tbaa !108
  call void %11(%struct.sbp2_orb* %orb.0, %struct.sbp2_status* null)
  %kref = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb.0, i32 0, i32 1
  call void @kref_put(%struct.kref* %kref, void (%struct.kref*)* @free_orb)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %for.body
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %12 = bitcast %struct.list_head* %list to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %12) #8
  ret i32 %retval1.0
}

; Function Attrs: nounwind uwtable
define internal %struct.device* @lu_dev(%struct.sbp2_logical_unit* %lu) #2 {
entry:
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %unit = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 0
  %1 = load %struct.fw_unit*, %struct.fw_unit** %unit, align 8, !tbaa !37
  %device = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %1, i32 0, i32 0
  ret %struct.device* %device
}

declare void @dev_err(%struct.device*, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @dma_unmap_single_attrs(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, i64 %attrs) #3 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %call1 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.end10

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.6, i32 0, i32 0), i32 226, i64 12) #8, !srcloc !109
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.end10:                                         ; preds = %entry
  %unmap_page = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 5
  %0 = load void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)** %unmap_page, align 8, !tbaa !110
  %tobool11 = icmp ne void (%struct.device*, i64, i64, i32, i64)* %0, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %do.end10
  %unmap_page13 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 5
  %1 = load void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)** %unmap_page13, align 8, !tbaa !110
  call void %1(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, i64 %attrs)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %do.end10
  call void @debug_dma_unmap_page(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, i1 zeroext true)
  ret void
}

declare i8* @__memcpy(i8*, i8*, i64) #1

; Function Attrs: nounwind uwtable
define internal void @free_orb(%struct.kref* %kref) #2 {
entry:
  %0 = bitcast %struct.kref* %kref to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -256
  %1 = bitcast i8* %add.ptr to %struct.sbp2_orb*
  %2 = bitcast %struct.sbp2_orb* %1 to i8*
  call void @kfree(i8* %2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put(%struct.kref* %kref, void (%struct.kref*)* %release) #3 {
entry:
  %cmp = icmp eq void (%struct.kref*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.7, i32 0, i32 0), i32 69)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool7 = icmp ne i32 %lnot.ext, 0
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  %expval13 = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  %call = call zeroext i1 @refcount_dec_and_test(%struct.qspinlock* %refcount)
  br i1 %call, label %if.then14, label %return

if.then14:                                        ; preds = %if.end
  call void %release(%struct.kref* %kref)
  br label %return

return:                                           ; preds = %if.then14, %if.end
  %retval.0 = phi i32 [ 1, %if.then14 ], [ 0, %if.end ]
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #7

declare void @warn_slowpath_null(i8*, i32) #1

declare zeroext i1 @refcount_dec_and_test(%struct.qspinlock*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev) #3 {
entry:
  %magicptr = ptrtoint %struct.device* %dev to i64
  %cond1 = icmp eq i64 %magicptr, 0
  br i1 %cond1, label %cond.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %dma_ops = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 17
  %0 = load %struct.dma_map_ops*, %struct.dma_map_ops** %dma_ops, align 8, !tbaa !111
  %tobool1 = icmp ne %struct.dma_map_ops* %0, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %dma_ops2 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 17
  %1 = load %struct.dma_map_ops*, %struct.dma_map_ops** %dma_ops2, align 8, !tbaa !111
  br label %return

if.end:                                           ; preds = %land.lhs.true
  %tobool3 = icmp ne %struct.device* %dev, null
  br i1 %tobool3, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end
  %bus = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 6
  %2 = load %struct.bus_type*, %struct.bus_type** %bus, align 8, !tbaa !112
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end, %entry
  %cond = phi %struct.bus_type* [ %2, %cond.true ], [ null, %entry ], [ null, %if.end ]
  %call = call %struct.dma_map_ops* @get_arch_dma_ops()
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %retval.0 = phi %struct.dma_map_ops* [ %1, %if.then ], [ %call, %cond.end ]
  ret %struct.dma_map_ops* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @valid_dma_direction(i32 %dma_direction) #3 {
entry:
  %switch = icmp ult i32 %dma_direction, 3
  %. = select i1 %switch, i1 true, i1 false
  %lor.ext = zext i1 %. to i32
  ret i32 %lor.ext
}

declare void @debug_dma_unmap_page(%struct.device*, i64, i64, i32, i1 zeroext) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.dma_map_ops* @get_arch_dma_ops() #3 {
entry:
  %0 = load %struct.dma_map_ops*, %struct.dma_map_ops** @dma_ops, align 8, !tbaa !51
  ret %struct.dma_map_ops* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #3 {
entry:
  %__u = alloca %union.anon.74, align 8
  %0 = bitcast %union.anon.74* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %__val = bitcast %union.anon.74* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !66
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.74* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val1 = bitcast %union.anon.74* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val1, align 8, !tbaa !66
  %3 = bitcast %union.anon.74* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !91
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_lock_irq(%struct.spinlock* %lock) #5 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_splice_init(%struct.list_head* %list, %struct.list_head* %head) #3 {
entry:
  %call = call i32 @list_empty(%struct.list_head* %list)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !55
  call void @__list_splice(%struct.list_head* %list, %struct.list_head* %head, %struct.list_head* %0)
  call void @INIT_LIST_HEAD(%struct.list_head* %list)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_unlock_irq(%struct.spinlock* %lock) #5 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

declare i32 @fw_cancel_transaction(%struct.fw_card*, %struct.fw_transaction*) #1

declare void @_raw_spin_unlock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #3 {
entry:
  %__u = alloca %union.anon.74, align 8
  %0 = bitcast %union.anon.74* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.74* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.74* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val, align 8, !tbaa !66
  %3 = bitcast %union.anon.74* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %cmp = icmp eq %struct.list_head* %2, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_splice(%struct.list_head* %list, %struct.list_head* %prev, %struct.list_head* %next) #3 {
entry:
  %next1 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next1, align 8, !tbaa !55
  %prev2 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  %1 = load %struct.list_head*, %struct.list_head** %prev2, align 8, !tbaa !91
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !91
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  store %struct.list_head* %0, %struct.list_head** %next4, align 8, !tbaa !55
  %next5 = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next5, align 8, !tbaa !55
  %prev6 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %1, %struct.list_head** %prev6, align 8, !tbaa !91
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__read_once_size(i8* %p, i8* %res, i32 %size) #5 {
entry:
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %0 = load volatile i8, i8* %p, align 1, !tbaa !66
  store i8 %0, i8* %res, align 1, !tbaa !66
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %p to i16*
  %2 = load volatile i16, i16* %1, align 2, !tbaa !92
  %3 = bitcast i8* %res to i16*
  store i16 %2, i16* %3, align 2, !tbaa !92
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %p to i32*
  %5 = load volatile i32, i32* %4, align 4, !tbaa !40
  %6 = bitcast i8* %res to i32*
  store i32 %5, i32* %6, align 4, !tbaa !40
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %p to i64*
  %8 = load volatile i64, i64* %7, align 8, !tbaa !93
  %9 = bitcast i8* %res to i64*
  store i64 %8, i64* %9, align 8, !tbaa !93
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !113
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %res, i8* %p, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !114
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare i64 @__msecs_to_jiffies(i32) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock) #5 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #3 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !91
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #5 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get(%struct.kref* %kref) #3 {
entry:
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  call void @refcount_inc(%struct.qspinlock* %refcount)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @complete_transaction(%struct.fw_card* %card, i32 %rcode, i8* %payload, i64 %length, i8* %data) #2 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i8* %data to %struct.sbp2_orb*
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #8
  %lu = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 5
  %5 = load %struct.sbp2_logical_unit*, %struct.sbp2_logical_unit** %lu, align 8, !tbaa !105
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %5, i32 0, i32 0
  %6 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %lock = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 10
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %rcode5 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 3
  %7 = load i32, i32* %rcode5, align 8, !tbaa !107
  %cmp6 = icmp eq i32 %7, -1
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %rcode8 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 3
  store i32 %rcode, i32* %rcode8, align 8, !tbaa !107
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rcode9 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 3
  %8 = load i32, i32* %rcode9, align 8, !tbaa !107
  %cmp10 = icmp ne i32 %8, 0
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %link = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 6
  call void @list_del(%struct.list_head* %link)
  %lu13 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 5
  %9 = load %struct.sbp2_logical_unit*, %struct.sbp2_logical_unit** %lu13, align 8, !tbaa !105
  %tgt14 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %9, i32 0, i32 0
  %10 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt14, align 8, !tbaa !67
  %lock15 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %10, i32 0, i32 10
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock15, i64 %call2)
  %callback = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 4
  %11 = load void (%struct.sbp2_orb*, %struct.sbp2_status*)*, void (%struct.sbp2_orb*, %struct.sbp2_status*)** %callback, align 8, !tbaa !108
  call void %11(%struct.sbp2_orb* %0, %struct.sbp2_status* null)
  %kref = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 1
  call void @kref_put(%struct.kref* %kref, void (%struct.kref*)* @free_orb)
  br label %if.end20

if.else:                                          ; preds = %if.end
  %lu17 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 5
  %12 = load %struct.sbp2_logical_unit*, %struct.sbp2_logical_unit** %lu17, align 8, !tbaa !105
  %tgt18 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %12, i32 0, i32 0
  %13 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt18, align 8, !tbaa !67
  %lock19 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %13, i32 0, i32 10
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock19, i64 %call2)
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then12
  %kref21 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 1
  call void @kref_put(%struct.kref* %kref21, void (%struct.kref*)* @free_orb)
  ret void
}

declare void @fw_send_request(%struct.fw_card*, %struct.fw_transaction*, i32, i32, i32, i32, i64, i8*, i64, void (%struct.fw_card*, i32, i8*, i64, i8*)*, i8*) #1

declare void @refcount_inc(%struct.qspinlock*) #1

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #3 {
entry:
  %__u = alloca %union.anon.74, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !91
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !55
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !91
  %0 = bitcast %union.anon.74* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %__val = bitcast %union.anon.74* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !66
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.74* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val5 = bitcast %union.anon.74* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val5, align 8, !tbaa !66
  %3 = bitcast %union.anon.74* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare zeroext i1 @__list_add_valid(%struct.list_head*, %struct.list_head*, %struct.list_head*) #1

declare void @complete(%struct.completion*) #1

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #1

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32(i32 %val) #6 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #7, !srcloc !115
  ret i32 %0
}

declare void @debug_dma_mapping_error(%struct.device*, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @kmemcheck_mark_initialized() #3 {
entry:
  ret void
}

declare i64 @__phys_addr(i64) #1

declare void @debug_dma_map_page(%struct.device*, %struct.page*, i64, i64, i32, i64, i1 zeroext) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @refcount_set(%struct.qspinlock* %r, i32 %n) #3 {
entry:
  %refs = getelementptr inbounds %struct.qspinlock, %struct.qspinlock* %r, i32 0, i32 0
  call void @atomic_set(%struct.atomic_t* %refs, i32 %n)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @atomic_set(%struct.atomic_t* %v, i32 %i) #5 {
entry:
  %__u = alloca %struct.atomic_t, align 4
  %0 = bitcast %struct.atomic_t* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %__val = bitcast %struct.atomic_t* %__u to i32*
  store i32 %i, i32* %__val, align 4, !tbaa !66
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %1 = bitcast i32* %counter to i8*
  %__c = bitcast %struct.atomic_t* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 4)
  %__val1 = bitcast %struct.atomic_t* %__u to i32*
  %2 = load i32, i32* %__val1, align 4, !tbaa !66
  %3 = bitcast %struct.atomic_t* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %3) #8
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #5 {
entry:
  %call = call noalias i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

declare noalias i8* @__kmalloc(i64, i32) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @atomic_read(%struct.atomic_t* %v) #5 {
entry:
  %__u = alloca %struct.atomic_t, align 4
  %0 = bitcast %struct.atomic_t* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %1 = bitcast i32* %counter to i8*
  %__c = bitcast %struct.atomic_t* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* %1, i8* %arraydecay, i32 4)
  %__val = bitcast %struct.atomic_t* %__u to i32*
  %2 = load i32, i32* %__val, align 4, !tbaa !66
  %3 = bitcast %struct.atomic_t* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %3) #8
  ret i32 %2
}

declare i8* @__memset(i8*, i32, i64) #1

declare i64 @scsilun_to_int(%struct.scsi_lun*) #1

declare void @scsi_unblock_requests(%struct.Scsi_Host*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.fw_device* @fw_device(%struct.device* %dev) #3 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -40
  %1 = bitcast i8* %add.ptr to %struct.fw_device*
  ret %struct.fw_device* %1
}

declare i32 @fw_device_enable_phys_dma(%struct.fw_device*) #1

; Function Attrs: nounwind uwtable
define internal void @sbp2_conditionally_block(%struct.sbp2_logical_unit* %lu) #2 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tgt1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt1, align 8, !tbaa !67
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %card2 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %1 = load %struct.fw_card*, %struct.fw_card** %card2, align 8, !tbaa !2
  %2 = bitcast %struct.sbp2_target* %0 to i8*
  %3 = bitcast i8* %2 to i64*
  %4 = bitcast i64* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 -3744
  %5 = bitcast i8* %add.ptr to %struct.Scsi_Host*
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #8
  %7 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %8 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #8
  %9 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #8
  %lock = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 10
  %call5 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call6 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call5)
  %dont_block = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 11
  %10 = load i32, i32* %dont_block, align 8, !tbaa !65
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.end19, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %blocked = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 12
  %11 = load i8, i8* %blocked, align 1, !tbaa !116, !range !84
  %tobool9 = trunc i8 %11 to i1
  br i1 %tobool9, label %if.end19, label %land.lhs.true10

land.lhs.true10:                                  ; preds = %land.lhs.true
  %generation = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 7
  %12 = load i32, i32* %generation, align 8, !tbaa !117
  %generation11 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %1, i32 0, i32 5
  %13 = load i32, i32* %generation11, align 4, !tbaa !118
  %cmp12 = icmp ne i32 %12, %13
  br i1 %cmp12, label %if.then, label %if.end19

if.then:                                          ; preds = %land.lhs.true10
  %blocked14 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 12
  store i8 1, i8* %blocked14, align 1, !tbaa !116
  %blocked15 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 12
  %14 = load i32, i32* %blocked15, align 4, !tbaa !119
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %blocked15, align 4, !tbaa !119
  %cmp16 = icmp eq i32 %inc, 1
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then
  call void @scsi_block_requests(%struct.Scsi_Host* %5)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.then, %land.lhs.true10, %land.lhs.true, %entry
  %lock20 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 10
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock20, i64 %call6)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_queue_work(%struct.sbp2_logical_unit* %lu, i64 %delay) #2 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @fw_workqueue, align 8, !tbaa !51
  %work = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 10
  call void @queue_delayed_work(%struct.workqueue_struct* %0, %struct.delayed_work* %work, i64 %delay)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_delayed_work(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #3 {
entry:
  %call = call zeroext i1 @queue_delayed_work_on(i32 8192, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret void
}

declare zeroext i1 @queue_delayed_work_on(i32, %struct.workqueue_struct*, %struct.delayed_work*, i64) #1

declare void @scsi_block_requests(%struct.Scsi_Host*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @dma_get_max_seg_size(%struct.device* %dev) #3 {
entry:
  %dma_parms = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 21
  %0 = load %struct.device_dma_parameters*, %struct.device_dma_parameters** %dma_parms, align 8, !tbaa !120
  %tobool = icmp ne %struct.device_dma_parameters* %0, null
  br i1 %tobool, label %land.lhs.true, label %return

land.lhs.true:                                    ; preds = %entry
  %dma_parms1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 21
  %1 = load %struct.device_dma_parameters*, %struct.device_dma_parameters** %dma_parms1, align 8, !tbaa !120
  %max_segment_size = getelementptr inbounds %struct.device_dma_parameters, %struct.device_dma_parameters* %1, i32 0, i32 0
  %2 = load i32, i32* %max_segment_size, align 8, !tbaa !121
  %tobool2 = icmp ne i32 %2, 0
  br i1 %tobool2, label %if.then, label %return

if.then:                                          ; preds = %land.lhs.true
  %dma_parms3 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 21
  %3 = load %struct.device_dma_parameters*, %struct.device_dma_parameters** %dma_parms3, align 8, !tbaa !120
  %max_segment_size4 = getelementptr inbounds %struct.device_dma_parameters, %struct.device_dma_parameters* %3, i32 0, i32 0
  %4 = load i32, i32* %max_segment_size4, align 8, !tbaa !121
  br label %return

return:                                           ; preds = %if.then, %land.lhs.true, %entry
  %retval.0 = phi i32 [ %4, %if.then ], [ 65536, %land.lhs.true ], [ 65536, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @dma_set_max_seg_size(%struct.device* %dev, i32 %size) #3 {
entry:
  %dma_parms = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 21
  %0 = load %struct.device_dma_parameters*, %struct.device_dma_parameters** %dma_parms, align 8, !tbaa !120
  %tobool = icmp ne %struct.device_dma_parameters* %0, null
  br i1 %tobool, label %if.then, label %return

if.then:                                          ; preds = %entry
  %dma_parms1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 21
  %1 = load %struct.device_dma_parameters*, %struct.device_dma_parameters** %dma_parms1, align 8, !tbaa !120
  %max_segment_size = getelementptr inbounds %struct.device_dma_parameters, %struct.device_dma_parameters* %1, i32 0, i32 0
  store i32 %size, i32* %max_segment_size, align 8, !tbaa !121
  br label %return

return:                                           ; preds = %if.then, %entry
  %retval.0 = phi i32 [ 0, %if.then ], [ -5, %entry ]
  ret i32 %retval.0
}

declare %struct.Scsi_Host* @scsi_host_alloc(%struct.scsi_host_template*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_set_drvdata(%struct.device* %dev, i8* %data) #3 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  store i8* %data, i8** %driver_data, align 8, !tbaa !64
  ret void
}

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #1

declare i32 @scsi_add_host_with_dma(%struct.Scsi_Host*, %struct.device*, %struct.device*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_scan_unit_dir(%struct.sbp2_target* %tgt, i32* %directory, i32* %model, i32* %firmware_revision) #2 {
entry:
  %ci = alloca %struct.fw_csr_iterator, align 8
  %key = alloca i32, align 4
  %value = alloca i32, align 4
  %0 = bitcast %struct.fw_csr_iterator* %ci to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #8
  %1 = bitcast i32* %key to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  %2 = bitcast i32* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #8
  call void @fw_csr_iterator_init(%struct.fw_csr_iterator* %ci, i32* %directory)
  br label %while.cond

while.cond:                                       ; preds = %sw.epilog, %entry
  %call = call i32 @fw_csr_iterator_next(%struct.fw_csr_iterator* %ci, i32* %key, i32* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %3 = load i32, i32* %key, align 4, !tbaa !40
  %Pivot26 = icmp slt i32 %3, 60
  br i1 %Pivot26, label %NodeBlock9, label %NodeBlock23

NodeBlock23:                                      ; preds = %while.body
  %Pivot24 = icmp slt i32 %3, 141
  br i1 %Pivot24, label %NodeBlock15, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %3, 212
  br i1 %Pivot22, label %LeafBlock17, label %LeafBlock19

LeafBlock19:                                      ; preds = %NodeBlock21
  %SwitchLeaf20 = icmp eq i32 %3, 212
  br i1 %SwitchLeaf20, label %sw.bb11, label %sw.epilog

LeafBlock17:                                      ; preds = %NodeBlock21
  %SwitchLeaf18 = icmp eq i32 %3, 141
  br i1 %SwitchLeaf18, label %sw.bb9, label %sw.epilog

NodeBlock15:                                      ; preds = %NodeBlock23
  %Pivot16 = icmp slt i32 %3, 84
  br i1 %Pivot16, label %LeafBlock11, label %LeafBlock13

LeafBlock13:                                      ; preds = %NodeBlock15
  %SwitchLeaf14 = icmp eq i32 %3, 84
  br i1 %SwitchLeaf14, label %sw.bb, label %sw.epilog

LeafBlock11:                                      ; preds = %NodeBlock15
  %SwitchLeaf12 = icmp eq i32 %3, 60
  br i1 %SwitchLeaf12, label %sw.bb3, label %sw.epilog

NodeBlock9:                                       ; preds = %while.body
  %Pivot10 = icmp slt i32 %3, 32
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %3, 58
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %3, 58
  br i1 %SwitchLeaf6, label %sw.bb4, label %sw.epilog

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %3, 32
  br i1 %SwitchLeaf4, label %sw.bb1, label %sw.epilog

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %3, 23
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %3, 23
  br i1 %SwitchLeaf2, label %sw.bb2, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %3, 20
  br i1 %SwitchLeaf, label %sw.bb6, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock13
  %4 = load i32, i32* %value, align 4, !tbaa !40
  %mul = mul nsw i32 4, %4
  %conv = sext i32 %mul to i64
  %add = add i64 281474708275200, %conv
  %management_agent_address = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 2
  store i64 %add, i64* %management_agent_address, align 8, !tbaa !88
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock3
  %5 = load i32, i32* %value, align 4, !tbaa !40
  %directory_id = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 4
  store i32 %5, i32* %directory_id, align 8, !tbaa !47
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock1
  %6 = load i32, i32* %value, align 4, !tbaa !40
  store i32 %6, i32* %model, align 4, !tbaa !40
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock11
  %7 = load i32, i32* %value, align 4, !tbaa !40
  store i32 %7, i32* %firmware_revision, align 4, !tbaa !40
  br label %sw.epilog

sw.bb4:                                           ; preds = %LeafBlock5
  %8 = load i32, i32* %value, align 4, !tbaa !40
  %shr = ashr i32 %8, 8
  %and = and i32 %shr, 255
  %mul5 = mul nsw i32 %and, 500
  %mgt_orb_timeout = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 8
  store i32 %mul5, i32* %mgt_orb_timeout, align 8, !tbaa !85
  br label %sw.epilog

sw.bb6:                                           ; preds = %LeafBlock
  %9 = load i32, i32* %value, align 4, !tbaa !40
  %call7 = call i32 @sbp2_add_logical_unit(%struct.sbp2_target* %tgt, i32 %9)
  %cmp = icmp slt i32 %call7, 0
  br i1 %cmp, label %cleanup, label %sw.epilog

sw.bb9:                                           ; preds = %LeafBlock17
  %p = getelementptr inbounds %struct.fw_csr_iterator, %struct.fw_csr_iterator* %ci, i32 0, i32 0
  %10 = load i32*, i32** %p, align 8, !tbaa !123
  %add.ptr = getelementptr inbounds i32, i32* %10, i64 -1
  %11 = load i32, i32* %value, align 4, !tbaa !40
  %idx.ext = sext i32 %11 to i64
  %add.ptr10 = getelementptr inbounds i32, i32* %add.ptr, i64 %idx.ext
  call void @sbp2_get_unit_unique_id(%struct.sbp2_target* %tgt, i32* %add.ptr10)
  br label %sw.epilog

sw.bb11:                                          ; preds = %LeafBlock19
  %p12 = getelementptr inbounds %struct.fw_csr_iterator, %struct.fw_csr_iterator* %ci, i32 0, i32 0
  %12 = load i32*, i32** %p12, align 8, !tbaa !123
  %add.ptr13 = getelementptr inbounds i32, i32* %12, i64 -1
  %13 = load i32, i32* %value, align 4, !tbaa !40
  %idx.ext14 = sext i32 %13 to i64
  %add.ptr15 = getelementptr inbounds i32, i32* %add.ptr13, i64 %idx.ext14
  %call16 = call i32 @sbp2_scan_logical_unit_dir(%struct.sbp2_target* %tgt, i32* %add.ptr15)
  %cmp17 = icmp slt i32 %call16, 0
  br i1 %cmp17, label %cleanup, label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb11, %sw.bb9, %sw.bb6, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock11, %LeafBlock13, %LeafBlock17, %LeafBlock19
  br label %while.cond

cleanup:                                          ; preds = %sw.bb11, %sw.bb6, %while.cond
  %retval.0 = phi i32 [ -12, %sw.bb6 ], [ -12, %sw.bb11 ], [ 0, %while.cond ]
  %14 = bitcast i32* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %14) #8
  %15 = bitcast i32* %key to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %15) #8
  %16 = bitcast %struct.fw_csr_iterator* %ci to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %16) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_clamp_management_orb_timeout(%struct.sbp2_target* %tgt) #2 {
entry:
  %__UNIQUE_ID_min1_42 = alloca i32, align 4
  %__UNIQUE_ID_min1_40 = alloca i32, align 4
  %__UNIQUE_ID_min2_41 = alloca i32, align 4
  %__UNIQUE_ID_min2_43 = alloca i32, align 4
  %mgt_orb_timeout = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 8
  %0 = load i32, i32* %mgt_orb_timeout, align 8, !tbaa !85
  %cmp = icmp ugt i32 %0, 40000
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %struct.device* @tgt_dev(%struct.sbp2_target* %tgt)
  %div = udiv i32 %0, 1000
  call void (%struct.device*, i8*, ...) @dev_notice(%struct.device* %call, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.24, i32 0, i32 0), i32 %div)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = bitcast i32* %__UNIQUE_ID_min1_42 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  %2 = bitcast i32* %__UNIQUE_ID_min1_40 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #8
  store i32 %0, i32* %__UNIQUE_ID_min1_40, align 4, !tbaa !40
  %3 = bitcast i32* %__UNIQUE_ID_min2_41 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #8
  store i32 5000, i32* %__UNIQUE_ID_min2_41, align 4, !tbaa !40
  %cmp1 = icmp eq i32* %__UNIQUE_ID_min1_40, %__UNIQUE_ID_min2_41
  %conv = zext i1 %cmp1 to i32
  %4 = load i32, i32* %__UNIQUE_ID_min1_40, align 4, !tbaa !40
  %5 = load i32, i32* %__UNIQUE_ID_min2_41, align 4, !tbaa !40
  %cmp2 = icmp ugt i32 %4, %5
  %6 = load i32, i32* %__UNIQUE_ID_min1_40, align 4
  %7 = load i32, i32* %__UNIQUE_ID_min2_41, align 4
  %cond = select i1 %cmp2, i32 %6, i32 %7
  %8 = bitcast i32* %__UNIQUE_ID_min2_41 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %8) #8
  %9 = bitcast i32* %__UNIQUE_ID_min1_40 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %9) #8
  store i32 %cond, i32* %__UNIQUE_ID_min1_42, align 4, !tbaa !40
  %10 = bitcast i32* %__UNIQUE_ID_min2_43 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %10) #8
  store i32 40000, i32* %__UNIQUE_ID_min2_43, align 4, !tbaa !40
  %cmp4 = icmp eq i32* %__UNIQUE_ID_min1_42, %__UNIQUE_ID_min2_43
  %conv5 = zext i1 %cmp4 to i32
  %11 = load i32, i32* %__UNIQUE_ID_min1_42, align 4, !tbaa !40
  %12 = load i32, i32* %__UNIQUE_ID_min2_43, align 4, !tbaa !40
  %cmp7 = icmp ult i32 %11, %12
  %13 = load i32, i32* %__UNIQUE_ID_min1_42, align 4
  %14 = load i32, i32* %__UNIQUE_ID_min2_43, align 4
  %cond12 = select i1 %cmp7, i32 %13, i32 %14
  %15 = bitcast i32* %__UNIQUE_ID_min2_43 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %15) #8
  %16 = bitcast i32* %__UNIQUE_ID_min1_42 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %16) #8
  %mgt_orb_timeout13 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 8
  store i32 %cond12, i32* %mgt_orb_timeout13, align 8, !tbaa !85
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_init_workarounds(%struct.sbp2_target* %tgt, i32 %model, i32 %firmware_revision) #2 {
entry:
  %0 = load i32, i32* @sbp2_param_workarounds, align 4, !tbaa !40
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %struct.device* @tgt_dev(%struct.sbp2_target* %tgt)
  call void (%struct.device*, i8*, ...) @dev_notice(%struct.device* %call, i8* getelementptr inbounds ([82 x i8], [82 x i8]* @.str.25, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %and = and i32 %0, 256
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %out, label %if.end3

if.end3:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %i.0 = phi i32 [ 0, %if.end3 ], [ %inc, %for.inc ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 11
  br i1 %cmp, label %for.body, label %out

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [11 x %struct.exception_table_entry], [11 x %struct.exception_table_entry]* @sbp2_workarounds_table, i64 0, i64 %idxprom
  %firmware_revision5 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %arrayidx, i32 0, i32 0
  %1 = load i32, i32* %firmware_revision5, align 4, !tbaa !125
  %and6 = and i32 %firmware_revision, -256
  %cmp7 = icmp ne i32 %1, %and6
  br i1 %cmp7, label %for.inc, label %if.end10

if.end10:                                         ; preds = %for.body
  %idxprom11 = sext i32 %i.0 to i64
  %arrayidx12 = getelementptr inbounds [11 x %struct.exception_table_entry], [11 x %struct.exception_table_entry]* @sbp2_workarounds_table, i64 0, i64 %idxprom11
  %model13 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %arrayidx12, i32 0, i32 1
  %2 = load i32, i32* %model13, align 4, !tbaa !127
  %cmp14 = icmp ne i32 %2, %model
  br i1 %cmp14, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %if.end10
  %idxprom16 = sext i32 %i.0 to i64
  %arrayidx17 = getelementptr inbounds [11 x %struct.exception_table_entry], [11 x %struct.exception_table_entry]* @sbp2_workarounds_table, i64 0, i64 %idxprom16
  %model18 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %arrayidx17, i32 0, i32 1
  %3 = load i32, i32* %model18, align 4, !tbaa !127
  %cmp19 = icmp ne i32 %3, -1
  br i1 %cmp19, label %for.inc, label %if.end22

if.end22:                                         ; preds = %land.lhs.true, %if.end10
  %idxprom23 = sext i32 %i.0 to i64
  %arrayidx24 = getelementptr inbounds [11 x %struct.exception_table_entry], [11 x %struct.exception_table_entry]* @sbp2_workarounds_table, i64 0, i64 %idxprom23
  %workarounds = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %arrayidx24, i32 0, i32 2
  %4 = load i32, i32* %workarounds, align 4, !tbaa !128
  %or = or i32 %0, %4
  br label %out

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

out:                                              ; preds = %if.end22, %for.cond, %if.end
  %w.1 = phi i32 [ %0, %if.end ], [ %or, %if.end22 ], [ %0, %for.cond ]
  %tobool25 = icmp ne i32 %w.1, 0
  br i1 %tobool25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %out
  %call27 = call %struct.device* @tgt_dev(%struct.sbp2_target* %tgt)
  call void (%struct.device*, i8*, ...) @dev_notice(%struct.device* %call27, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.26, i32 0, i32 0), i32 %w.1, i32 %firmware_revision, i32 %model)
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %out
  %workarounds29 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 7
  store i32 %w.1, i32* %workarounds29, align 4, !tbaa !129
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.device* @tgt_dev(%struct.sbp2_target* %tgt) #2 {
entry:
  %unit = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 0
  %0 = load %struct.fw_unit*, %struct.fw_unit** %unit, align 8, !tbaa !37
  %device = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %0, i32 0, i32 0
  ret %struct.device* %device
}

declare void @fw_csr_iterator_init(%struct.fw_csr_iterator*, i32*) #1

declare i32 @fw_csr_iterator_next(%struct.fw_csr_iterator*, i32*, i32*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_add_logical_unit(%struct.sbp2_target* %tgt, i32 %lun_entry) #2 {
entry:
  %.compoundliteral = alloca %union.anon.3, align 8
  %call = call i8* @kmalloc(i64 320, i32 20971712)
  %0 = bitcast i8* %call to %struct.sbp2_logical_unit*
  %tobool = icmp ne %struct.sbp2_logical_unit* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %address_handler = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 2
  %length = getelementptr inbounds %struct.fw_address_handler, %struct.fw_address_handler* %address_handler, i32 0, i32 1
  store i64 256, i64* %length, align 8, !tbaa !130
  %address_handler1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 2
  %address_callback = getelementptr inbounds %struct.fw_address_handler, %struct.fw_address_handler* %address_handler1, i32 0, i32 2
  store void (%struct.fw_card*, %struct.fw_request*, i32, i32, i32, i32, i64, i8*, i64, i8*)* @sbp2_status_write, void (%struct.fw_card*, %struct.fw_request*, i32, i32, i32, i32, i64, i8*, i64, i8*)** %address_callback, align 8, !tbaa !131
  %1 = bitcast %struct.sbp2_logical_unit* %0 to i8*
  %address_handler2 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 2
  %callback_data = getelementptr inbounds %struct.fw_address_handler, %struct.fw_address_handler* %address_handler2, i32 0, i32 3
  store i8* %1, i8** %callback_data, align 8, !tbaa !132
  %address_handler3 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 2
  %call4 = call i32 @fw_core_add_address_handler(%struct.fw_address_handler* %address_handler3, %struct.timespec* @fw_high_memory_region)
  %cmp = icmp slt i32 %call4, 0
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %2 = bitcast %struct.sbp2_logical_unit* %0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

if.end6:                                          ; preds = %if.end
  %tgt7 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 0
  store %struct.sbp2_target* %tgt, %struct.sbp2_target** %tgt7, align 8, !tbaa !67
  %and = and i32 %lun_entry, 65535
  %conv = trunc i32 %and to i16
  %lun = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 5
  store i16 %conv, i16* %lun, align 8, !tbaa !57
  %login_id = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 6
  store i32 65536, i32* %login_id, align 4, !tbaa !58
  %retries = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 8
  store i32 0, i32* %retries, align 4, !tbaa !52
  %has_sdev = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 11
  store i8 0, i8* %has_sdev, align 8, !tbaa !133
  %blocked = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 12
  store i8 0, i8* %blocked, align 1, !tbaa !116
  %dont_block = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 11
  %3 = load i32, i32* %dont_block, align 8, !tbaa !65
  %inc = add nsw i32 %3, 1
  store i32 %inc, i32* %dont_block, align 8, !tbaa !65
  %orb_list = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 3
  call void @INIT_LIST_HEAD(%struct.list_head* %orb_list)
  %workfn = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 9
  store void (%struct.work_struct*)* @sbp2_login, void (%struct.work_struct*)** %workfn, align 8, !tbaa !134
  %work = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 10
  %work9 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work9, i32 0)
  %work10 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 10
  %work11 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work10, i32 0, i32 0
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work11, i32 0, i32 0
  %counter = getelementptr inbounds %union.anon.3, %union.anon.3* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !135
  %4 = bitcast %union.anon.3* %data to i8*
  %5 = bitcast %union.anon.3* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 8, i32 8, i1 false), !tbaa.struct !136
  %work12 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 10
  %work13 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work12, i32 0, i32 0
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work13, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.11, i32 0, i32 0), %struct.lock_class_key* @sbp2_add_logical_unit.__key, i32 0)
  %work14 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 10
  %work15 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work14, i32 0, i32 0
  %entry16 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work15, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry16)
  %work17 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 10
  %work18 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work17, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work18, i32 0, i32 2
  store void (%struct.work_struct*)* @sbp2_lu_workfn, void (%struct.work_struct*)** %func, align 8, !tbaa !137
  %work21 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 10
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work21, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2097152, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13, i32 0, i32 0), %struct.lock_class_key* @sbp2_add_logical_unit.__key.12)
  %work24 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 10
  %timer25 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work24, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer25, i32 0, i32 2
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !138
  %work26 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 10
  %6 = ptrtoint %struct.delayed_work* %work26 to i64
  %work27 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 10
  %timer28 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work27, i32 0, i32 1
  %data29 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer28, i32 0, i32 3
  store i64 %6, i64* %data29, align 8, !tbaa !139
  %link = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 1
  %lu_list = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 1
  call void @list_add_tail(%struct.list_head* %link, %struct.list_head* %lu_list)
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.then5, %entry
  %retval.0 = phi i32 [ -12, %if.then5 ], [ 0, %if.end6 ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_get_unit_unique_id(%struct.sbp2_target* %tgt, i32* %leaf) #2 {
entry:
  %arrayidx = getelementptr inbounds i32, i32* %leaf, i64 0
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !40
  %and = and i32 %0, -65536
  %cmp = icmp eq i32 %and, 131072
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %arrayidx1 = getelementptr inbounds i32, i32* %leaf, i64 1
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !40
  %conv = zext i32 %1 to i64
  %shl = shl i64 %conv, 32
  %arrayidx2 = getelementptr inbounds i32, i32* %leaf, i64 2
  %2 = load i32, i32* %arrayidx2, align 4, !tbaa !40
  %conv3 = zext i32 %2 to i64
  %or = or i64 %shl, %conv3
  %guid = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 3
  store i64 %or, i64* %guid, align 8, !tbaa !41
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_scan_logical_unit_dir(%struct.sbp2_target* %tgt, i32* %directory) #2 {
entry:
  %ci = alloca %struct.fw_csr_iterator, align 8
  %key = alloca i32, align 4
  %value = alloca i32, align 4
  %0 = bitcast %struct.fw_csr_iterator* %ci to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #8
  %1 = bitcast i32* %key to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  %2 = bitcast i32* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #8
  call void @fw_csr_iterator_init(%struct.fw_csr_iterator* %ci, i32* %directory)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call = call i32 @fw_csr_iterator_next(%struct.fw_csr_iterator* %ci, i32* %key, i32* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %3 = load i32, i32* %key, align 4, !tbaa !40
  %cmp = icmp eq i32 %3, 20
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %4 = load i32, i32* %value, align 4, !tbaa !40
  %call1 = call i32 @sbp2_add_logical_unit(%struct.sbp2_target* %tgt, i32 %4)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %while.body
  br label %while.cond

cleanup:                                          ; preds = %land.lhs.true, %while.cond
  %retval.0 = phi i32 [ -12, %land.lhs.true ], [ 0, %while.cond ]
  %5 = bitcast i32* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %5) #8
  %6 = bitcast i32* %key to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #8
  %7 = bitcast %struct.fw_csr_iterator* %ci to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %7) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_status_write(%struct.fw_card* %card, %struct.fw_request* %request, i32 %tcode, i32 %destination, i32 %source, i32 %generation, i64 %offset, i8* %payload, i64 %length, i8* %callback_data) #2 {
entry:
  %status = alloca %struct.sbp2_status, align 4
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i8* %callback_data to %struct.sbp2_logical_unit*
  %1 = bitcast %struct.sbp2_status* %status to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %1) #8
  %cmp = icmp ne i32 %tcode, 1
  %cmp1 = icmp ult i64 %length, 8
  %or.cond = or i1 %cmp, %cmp1
  %cmp3 = icmp ugt i64 %length, 32
  %or.cond1 = or i1 %or.cond, %cmp3
  br i1 %or.cond1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @fw_send_response(%struct.fw_card* %card, %struct.fw_request* %request, i32 6)
  br label %cleanup

if.end:                                           ; preds = %entry
  %2 = bitcast i8* %payload to i32*
  %call = call i32 @__be32_to_cpup(i32* %2)
  %status4 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  store i32 %call, i32* %status4, align 4, !tbaa !140
  %add.ptr = getelementptr i8, i8* %payload, i64 4
  %3 = bitcast i8* %add.ptr to i32*
  %call5 = call i32 @__be32_to_cpup(i32* %3)
  %orb_low = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 1
  store i32 %call5, i32* %orb_low, align 4, !tbaa !141
  %data = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 2
  %arraydecay = getelementptr inbounds [24 x i8], [24 x i8]* %data, i32 0, i32 0
  %call6 = call i8* @__memset(i8* %arraydecay, i32 0, i64 24)
  %cmp7 = icmp ugt i64 %length, 8
  br i1 %cmp7, label %if.then8, label %if.end13

if.then8:                                         ; preds = %if.end
  %data9 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 2
  %arraydecay10 = getelementptr inbounds [24 x i8], [24 x i8]* %data9, i32 0, i32 0
  %add.ptr11 = getelementptr i8, i8* %payload, i64 8
  %sub = sub i64 %length, 8
  %call12 = call i8* @__memcpy(i8* %arraydecay10, i8* %add.ptr11, i64 %sub)
  br label %if.end13

if.end13:                                         ; preds = %if.then8, %if.end
  %status14 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  %4 = load i32, i32* %status14, align 4, !tbaa !140
  %shr = lshr i32 %4, 30
  %and = and i32 %shr, 3
  %cmp15 = icmp eq i32 %and, 2
  br i1 %cmp15, label %if.then21, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %if.end13
  %status17 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  %5 = load i32, i32* %status17, align 4, !tbaa !140
  %shr18 = lshr i32 %5, 30
  %and19 = and i32 %shr18, 3
  %cmp20 = icmp eq i32 %and19, 3
  br i1 %cmp20, label %if.then21, label %do.body24

if.then21:                                        ; preds = %lor.lhs.false16, %if.end13
  %call22 = call %struct.device* @lu_dev(%struct.sbp2_logical_unit* %0)
  call void (%struct.device*, i8*, ...) @dev_notice(%struct.device* %call22, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.14, i32 0, i32 0))
  call void @fw_send_response(%struct.fw_card* %card, %struct.fw_request* %request, i32 0)
  br label %cleanup

do.body24:                                        ; preds = %lor.lhs.false16
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #8
  %7 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #8
  %cmp25 = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp25 to i32
  %8 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #8
  %9 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #8
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 0
  %10 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %lock = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %10, i32 0, i32 10
  %call26 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call27 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call26)
  %orb_list = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 3
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body24
  %link47.sink = phi %struct.list_head* [ %link47, %for.inc ], [ %orb_list, %do.body24 ]
  %next48 = getelementptr inbounds %struct.list_head, %struct.list_head* %link47.sink, i32 0, i32 0
  %11 = load %struct.list_head*, %struct.list_head** %next48, align 8, !tbaa !51
  %12 = bitcast %struct.list_head* %11 to i8*
  %add.ptr50 = getelementptr inbounds i8, i8* %12, i64 -296
  %13 = bitcast i8* %add.ptr50 to %struct.sbp2_orb*
  %link = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %13, i32 0, i32 6
  %orb_list32 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 3
  %cmp33 = icmp ne %struct.list_head* %link, %orb_list32
  br i1 %cmp33, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %status35 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  %14 = load i32, i32* %status35, align 4, !tbaa !140
  %and36 = and i32 %14, 65535
  %cmp37 = icmp eq i32 %and36, 0
  br i1 %cmp37, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %orb_low39 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 1
  %15 = load i32, i32* %orb_low39, align 4, !tbaa !141
  %conv40 = zext i32 %15 to i64
  %request_bus = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %13, i32 0, i32 2
  %16 = load i64, i64* %request_bus, align 8, !tbaa !103
  %cmp41 = icmp eq i64 %conv40, %16
  br i1 %cmp41, label %if.then43, label %for.inc

if.then43:                                        ; preds = %land.lhs.true
  %rcode = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %13, i32 0, i32 3
  store i32 0, i32* %rcode, align 8, !tbaa !107
  %link44 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %13, i32 0, i32 6
  call void @list_del(%struct.list_head* %link44)
  br label %for.end

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %link47 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %13, i32 0, i32 6
  br label %for.cond

for.end:                                          ; preds = %if.then43, %for.cond
  %tgt51 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 0
  %17 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt51, align 8, !tbaa !67
  %lock52 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %17, i32 0, i32 10
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock52, i64 %call27)
  %link53 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %13, i32 0, i32 6
  %orb_list54 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 3
  %cmp55 = icmp ne %struct.list_head* %link53, %orb_list54
  br i1 %cmp55, label %if.then57, label %if.else

if.then57:                                        ; preds = %for.end
  %callback = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %13, i32 0, i32 4
  %18 = load void (%struct.sbp2_orb*, %struct.sbp2_status*)*, void (%struct.sbp2_orb*, %struct.sbp2_status*)** %callback, align 8, !tbaa !108
  call void %18(%struct.sbp2_orb* %13, %struct.sbp2_status* %status)
  %kref = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %13, i32 0, i32 1
  call void @kref_put(%struct.kref* %kref, void (%struct.kref*)* @free_orb)
  br label %if.end60

if.else:                                          ; preds = %for.end
  %call59 = call %struct.device* @lu_dev(%struct.sbp2_logical_unit* %0)
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %call59, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.15, i32 0, i32 0))
  br label %if.end60

if.end60:                                         ; preds = %if.else, %if.then57
  call void @fw_send_response(%struct.fw_card* %card, %struct.fw_request* %request, i32 0)
  br label %cleanup

cleanup:                                          ; preds = %if.end60, %if.then21, %if.then
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then ], [ 1, %if.then21 ], [ 0, %if.end60 ]
  %19 = bitcast %struct.sbp2_status* %status to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %19) #8
  ret void
}

declare i32 @fw_core_add_address_handler(%struct.fw_address_handler*, %struct.timespec*) #1

; Function Attrs: nounwind uwtable
define internal void @sbp2_login(%struct.work_struct* %work) #2 {
entry:
  %response = alloca %struct.sbp2_login_response, align 4
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -120
  %1 = bitcast i8* %add.ptr to %struct.sbp2_logical_unit*
  %tgt1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %2 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt1, align 8, !tbaa !67
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %2)
  %3 = bitcast %struct.sbp2_login_response* %response to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %3) #8
  %call2 = call i32 @fw_device_is_shutdown(%struct.fw_device* %call)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %generation3 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 3
  %4 = load i32, i32* %generation3, align 4, !tbaa !59
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !142
  %node_id4 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 2
  %5 = load i32, i32* %node_id4, align 8, !tbaa !61
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %6 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %node_id5 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %6, i32 0, i32 4
  %7 = load i32, i32* %node_id5, align 8, !tbaa !143
  %has_sdev = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 11
  %8 = load i8, i8* %has_sdev, align 8, !tbaa !133, !range !84
  %tobool6 = trunc i8 %8 to i1
  br i1 %tobool6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end
  %node_id8 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 2
  %9 = load i32, i32* %node_id8, align 8, !tbaa !61
  %login_id = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 6
  %10 = load i32, i32* %login_id, align 4, !tbaa !58
  %call9 = call i32 @sbp2_send_management_orb(%struct.sbp2_logical_unit* %1, i32 %9, i32 %4, i32 7, i32 %10, i8* null)
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end
  %lun = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 5
  %11 = load i16, i16* %lun, align 8, !tbaa !57
  %conv = zext i16 %11 to i32
  %12 = bitcast %struct.sbp2_login_response* %response to i8*
  %call11 = call i32 @sbp2_send_management_orb(%struct.sbp2_logical_unit* %1, i32 %5, i32 %4, i32 0, i32 %conv, i8* %12)
  %cmp = icmp slt i32 %call11, 0
  br i1 %cmp, label %if.then13, label %if.end22

if.then13:                                        ; preds = %if.end10
  %retries = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 8
  %13 = load i32, i32* %retries, align 4, !tbaa !52
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %retries, align 4, !tbaa !52
  %cmp14 = icmp slt i32 %13, 5
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.then13
  call void @sbp2_queue_work(%struct.sbp2_logical_unit* %1, i64 50)
  br label %cleanup

if.else:                                          ; preds = %if.then13
  %call17 = call %struct.device* @tgt_dev(%struct.sbp2_target* %2)
  %lun18 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 5
  %14 = load i16, i16* %lun18, align 8, !tbaa !57
  %conv19 = zext i16 %14 to i32
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %call17, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.16, i32 0, i32 0), i32 %conv19)
  %tgt20 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %15 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt20, align 8, !tbaa !67
  call void @sbp2_unblock(%struct.sbp2_target* %15)
  br label %cleanup

if.end22:                                         ; preds = %if.end10
  %node_id23 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %2, i32 0, i32 5
  store i32 %5, i32* %node_id23, align 4, !tbaa !144
  %shl = shl i32 %7, 16
  %address_high = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %2, i32 0, i32 6
  store i32 %shl, i32* %address_high, align 8, !tbaa !145
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !146
  %generation24 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 7
  store i32 %4, i32* %generation24, align 8, !tbaa !117
  %command_block_agent = getelementptr inbounds %struct.sbp2_login_response, %struct.sbp2_login_response* %response, i32 0, i32 1
  %high = getelementptr inbounds %struct.anon.30, %struct.anon.30* %command_block_agent, i32 0, i32 0
  %16 = load i32, i32* %high, align 4, !tbaa !147
  %call25 = call i32 @__fswab32(i32 %16) #7
  %and = and i32 %call25, 65535
  %conv26 = zext i32 %and to i64
  %shl27 = shl i64 %conv26, 32
  %command_block_agent28 = getelementptr inbounds %struct.sbp2_login_response, %struct.sbp2_login_response* %response, i32 0, i32 1
  %low = getelementptr inbounds %struct.anon.30, %struct.anon.30* %command_block_agent28, i32 0, i32 1
  %17 = load i32, i32* %low, align 4, !tbaa !149
  %call29 = call i32 @__fswab32(i32 %17) #7
  %conv30 = zext i32 %call29 to i64
  %or = or i64 %shl27, %conv30
  %command_block_agent_address = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 4
  store i64 %or, i64* %command_block_agent_address, align 8, !tbaa !150
  %misc = getelementptr inbounds %struct.sbp2_login_response, %struct.sbp2_login_response* %response, i32 0, i32 0
  %18 = load i32, i32* %misc, align 4, !tbaa !151
  %call31 = call i32 @__fswab32(i32 %18) #7
  %and32 = and i32 %call31, 65535
  %login_id33 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 6
  store i32 %and32, i32* %login_id33, align 4, !tbaa !58
  %call34 = call %struct.device* @tgt_dev(%struct.sbp2_target* %2)
  %lun35 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 5
  %19 = load i16, i16* %lun35, align 8, !tbaa !57
  %conv36 = zext i16 %19 to i32
  %retries37 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 8
  %20 = load i32, i32* %retries37, align 4, !tbaa !52
  call void (%struct.device*, i8*, ...) @dev_notice(%struct.device* %call34, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.17, i32 0, i32 0), i32 %conv36, i32 %20)
  call void @sbp2_set_busy_timeout(%struct.sbp2_logical_unit* %1)
  %workfn = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 9
  store void (%struct.work_struct*)* @sbp2_reconnect, void (%struct.work_struct*)** %workfn, align 8, !tbaa !134
  call void @sbp2_agent_reset(%struct.sbp2_logical_unit* %1)
  %has_sdev38 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 11
  %21 = load i8, i8* %has_sdev38, align 8, !tbaa !133, !range !84
  %tobool39 = trunc i8 %21 to i1
  br i1 %tobool39, label %if.then40, label %if.end42

if.then40:                                        ; preds = %if.end22
  %call41 = call i32 @sbp2_cancel_orbs(%struct.sbp2_logical_unit* %1)
  call void @sbp2_conditionally_unblock(%struct.sbp2_logical_unit* %1)
  br label %cleanup

if.end42:                                         ; preds = %if.end22
  %tgt43 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %22 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt43, align 8, !tbaa !67
  %workarounds = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %22, i32 0, i32 7
  %23 = load i32, i32* %workarounds, align 4, !tbaa !129
  %and44 = and i32 %23, 16
  %tobool45 = icmp ne i32 %and44, 0
  br i1 %tobool45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.end42
  call void @ssleep(i32 12)
  br label %if.end47

if.end47:                                         ; preds = %if.then46, %if.end42
  %24 = bitcast %struct.sbp2_target* %2 to i8*
  %25 = bitcast i8* %24 to i64*
  %26 = bitcast i64* %25 to i8*
  %add.ptr50 = getelementptr inbounds i8, i8* %26, i64 -3744
  %27 = bitcast i8* %add.ptr50 to %struct.Scsi_Host*
  %lun51 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 5
  %28 = load i16, i16* %lun51, align 8, !tbaa !57
  %call52 = call i32 @sbp2_lun2int(i16 zeroext %28)
  %conv53 = sext i32 %call52 to i64
  %29 = bitcast %struct.sbp2_logical_unit* %1 to i8*
  %call54 = call %struct.scsi_device* @__scsi_add_device(%struct.Scsi_Host* %27, i32 0, i32 0, i64 %conv53, i8* %29)
  %30 = bitcast %struct.scsi_device* %call54 to i8*
  %call55 = call zeroext i1 @IS_ERR(i8* %30)
  br i1 %call55, label %out_logout_login, label %if.end57

if.end57:                                         ; preds = %if.end47
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !152
  %card58 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %31 = load %struct.fw_card*, %struct.fw_card** %card58, align 8, !tbaa !2
  %generation59 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %31, i32 0, i32 5
  %32 = load i32, i32* %generation59, align 4, !tbaa !118
  %cmp60 = icmp ne i32 %4, %32
  br i1 %cmp60, label %if.then62, label %if.end63

if.then62:                                        ; preds = %if.end57
  call void @scsi_remove_device(%struct.scsi_device* %call54)
  call void @scsi_device_put(%struct.scsi_device* %call54)
  br label %out_logout_login

if.end63:                                         ; preds = %if.end57
  %has_sdev64 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 11
  store i8 1, i8* %has_sdev64, align 8, !tbaa !133
  call void @scsi_device_put(%struct.scsi_device* %call54)
  call void @sbp2_allow_block(%struct.sbp2_target* %2)
  br label %cleanup

out_logout_login:                                 ; preds = %if.then62, %if.end47
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !153
  %generation65 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 3
  %33 = load i32, i32* %generation65, align 4, !tbaa !59
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !154
  %node_id66 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 2
  %34 = load i32, i32* %node_id66, align 8, !tbaa !61
  %login_id67 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 6
  %35 = load i32, i32* %login_id67, align 4, !tbaa !58
  %call68 = call i32 @sbp2_send_management_orb(%struct.sbp2_logical_unit* %1, i32 %34, i32 %33, i32 7, i32 %35, i8* null)
  %workfn69 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 9
  store void (%struct.work_struct*)* @sbp2_login, void (%struct.work_struct*)** %workfn69, align 8, !tbaa !134
  br label %cleanup

cleanup:                                          ; preds = %out_logout_login, %if.end63, %if.then40, %if.else, %if.then16, %entry
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then40 ], [ 0, %out_logout_login ], [ 1, %if.end63 ], [ 1, %entry ], [ 1, %if.else ], [ 1, %if.then16 ]
  %36 = bitcast %struct.sbp2_login_response* %response to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %36) #8
  ret void
}

declare void @__init_work(%struct.work_struct*, i32) #1

declare void @lockdep_init_map(%struct.lockdep_map*, i8*, %struct.lock_class_key*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @sbp2_lu_workfn(%struct.work_struct* %work) #2 {
entry:
  %call = call %struct.delayed_work* @to_delayed_work(%struct.work_struct* %work)
  %0 = bitcast %struct.delayed_work* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -120
  %1 = bitcast i8* %add.ptr to %struct.sbp2_logical_unit*
  %workfn = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 9
  %2 = load void (%struct.work_struct*)*, void (%struct.work_struct*)** %workfn, align 8, !tbaa !134
  call void %2(%struct.work_struct* %work)
  ret void
}

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #1

declare void @delayed_work_timer_fn(i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.delayed_work* @to_delayed_work(%struct.work_struct* %work) #3 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.delayed_work*
  ret %struct.delayed_work* %1
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_set_busy_timeout(%struct.sbp2_logical_unit* %lu) #2 {
entry:
  %d = alloca i32, align 4
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %1 = bitcast i32* %d to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  store i32 260049920, i32* %d, align 4, !tbaa !40
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %2 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %tgt1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %3 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt1, align 8, !tbaa !67
  %node_id = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %3, i32 0, i32 5
  %4 = load i32, i32* %node_id, align 4, !tbaa !144
  %generation = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 7
  %5 = load i32, i32* %generation, align 8, !tbaa !117
  %max_speed = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 4
  %6 = load i32, i32* %max_speed, align 8, !tbaa !48
  %7 = bitcast i32* %d to i8*
  %call2 = call i32 @fw_run_transaction(%struct.fw_card* %2, i32 0, i32 %4, i32 %5, i32 %6, i64 281474708275728, i8* %7, i64 4)
  %8 = bitcast i32* %d to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %8) #8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_reconnect(%struct.work_struct* %work) #2 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -120
  %1 = bitcast i8* %add.ptr to %struct.sbp2_logical_unit*
  %tgt1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %2 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt1, align 8, !tbaa !67
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %2)
  %call2 = call i32 @fw_device_is_shutdown(%struct.fw_device* %call)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %generation3 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 3
  %3 = load i32, i32* %generation3, align 4, !tbaa !59
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !155
  %node_id4 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 2
  %4 = load i32, i32* %node_id4, align 8, !tbaa !61
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %5 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %node_id5 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %5, i32 0, i32 4
  %6 = load i32, i32* %node_id5, align 8, !tbaa !143
  %login_id = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 6
  %7 = load i32, i32* %login_id, align 4, !tbaa !58
  %call6 = call i32 @sbp2_send_management_orb(%struct.sbp2_logical_unit* %1, i32 %4, i32 %3, i32 3, i32 %7, i8* null)
  %cmp = icmp slt i32 %call6, 0
  br i1 %cmp, label %if.then7, label %if.end16

if.then7:                                         ; preds = %if.end
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !156
  %card8 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %8 = load %struct.fw_card*, %struct.fw_card** %card8, align 8, !tbaa !2
  %generation9 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %8, i32 0, i32 5
  %9 = load i32, i32* %generation9, align 4, !tbaa !118
  %cmp10 = icmp eq i32 %3, %9
  br i1 %cmp10, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then7
  %retries = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 8
  %10 = load i32, i32* %retries, align 4, !tbaa !52
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %retries, align 4, !tbaa !52
  %cmp11 = icmp sge i32 %10, 5
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %lor.lhs.false, %if.then7
  %call13 = call %struct.device* @tgt_dev(%struct.sbp2_target* %2)
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %call13, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.22, i32 0, i32 0))
  %retries14 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 8
  store i32 0, i32* %retries14, align 4, !tbaa !52
  %workfn = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 9
  store void (%struct.work_struct*)* @sbp2_login, void (%struct.work_struct*)** %workfn, align 8, !tbaa !134
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %lor.lhs.false
  call void @sbp2_queue_work(%struct.sbp2_logical_unit* %1, i64 50)
  br label %cleanup.cont

if.end16:                                         ; preds = %if.end
  %node_id17 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %2, i32 0, i32 5
  store i32 %4, i32* %node_id17, align 4, !tbaa !144
  %shl = shl i32 %6, 16
  %address_high = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %2, i32 0, i32 6
  store i32 %shl, i32* %address_high, align 8, !tbaa !145
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !157
  %generation18 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 7
  store i32 %3, i32* %generation18, align 8, !tbaa !117
  %call19 = call %struct.device* @tgt_dev(%struct.sbp2_target* %2)
  %lun = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 5
  %11 = load i16, i16* %lun, align 8, !tbaa !57
  %conv = zext i16 %11 to i32
  %retries20 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 8
  %12 = load i32, i32* %retries20, align 4, !tbaa !52
  call void (%struct.device*, i8*, ...) @dev_notice(%struct.device* %call19, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.23, i32 0, i32 0), i32 %conv, i32 %12)
  call void @sbp2_agent_reset(%struct.sbp2_logical_unit* %1)
  %call21 = call i32 @sbp2_cancel_orbs(%struct.sbp2_logical_unit* %1)
  call void @sbp2_conditionally_unblock(%struct.sbp2_logical_unit* %1)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end16, %if.end15, %entry
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.end15 ], [ 0, %if.end16 ], [ 1, %entry ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_agent_reset(%struct.sbp2_logical_unit* %lu) #2 {
entry:
  %d = alloca i32, align 4
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %1 = bitcast i32* %d to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  store i32 0, i32* %d, align 4, !tbaa !40
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %2 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %tgt1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %3 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt1, align 8, !tbaa !67
  %node_id = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %3, i32 0, i32 5
  %4 = load i32, i32* %node_id, align 4, !tbaa !144
  %generation = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 7
  %5 = load i32, i32* %generation, align 8, !tbaa !117
  %max_speed = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 4
  %6 = load i32, i32* %max_speed, align 8, !tbaa !48
  %command_block_agent_address = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 4
  %7 = load i64, i64* %command_block_agent_address, align 8, !tbaa !150
  %add = add i64 %7, 4
  %8 = bitcast i32* %d to i8*
  %call2 = call i32 @fw_run_transaction(%struct.fw_card* %2, i32 0, i32 %4, i32 %5, i32 %6, i64 %add, i8* %8, i64 4)
  %9 = bitcast i32* %d to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %9) #8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_conditionally_unblock(%struct.sbp2_logical_unit* %lu) #2 {
entry:
  %tgt1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt1, align 8, !tbaa !67
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %card2 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %1 = load %struct.fw_card*, %struct.fw_card** %card2, align 8, !tbaa !2
  %2 = bitcast %struct.sbp2_target* %0 to i8*
  %3 = bitcast i8* %2 to i64*
  %4 = bitcast i64* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 -3744
  %5 = bitcast i8* %add.ptr to %struct.Scsi_Host*
  %lock = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 10
  call void @spin_lock_irq(%struct.spinlock* %lock)
  %blocked = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 12
  %6 = load i8, i8* %blocked, align 1, !tbaa !116, !range !84
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %generation = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 7
  %7 = load i32, i32* %generation, align 8, !tbaa !117
  %generation3 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %1, i32 0, i32 5
  %8 = load i32, i32* %generation3, align 4, !tbaa !118
  %cmp = icmp eq i32 %7, %8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %blocked4 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 12
  store i8 0, i8* %blocked4, align 1, !tbaa !116
  %blocked5 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 12
  %9 = load i32, i32* %blocked5, align 4, !tbaa !119
  %dec = add nsw i32 %9, -1
  store i32 %dec, i32* %blocked5, align 4, !tbaa !119
  %cmp6 = icmp eq i32 %dec, 0
  %frombool = zext i1 %cmp6 to i8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %unblock.0 = phi i8 [ %frombool, %if.then ], [ 0, %land.lhs.true ], [ 0, %entry ]
  %lock7 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 10
  call void @spin_unlock_irq(%struct.spinlock* %lock7)
  %tobool8 = trunc i8 %unblock.0 to i1
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  call void @scsi_unblock_requests(%struct.Scsi_Host* %5)
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @ssleep(i32 %seconds) #3 {
entry:
  %mul = mul i32 %seconds, 1000
  call void @msleep(i32 %mul)
  ret void
}

declare %struct.scsi_device* @__scsi_add_device(%struct.Scsi_Host*, i32, i32, i64, i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sbp2_allow_block(%struct.sbp2_target* %tgt) #3 {
entry:
  %lock = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 10
  call void @spin_lock_irq(%struct.spinlock* %lock)
  %dont_block = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 11
  %0 = load i32, i32* %dont_block, align 8, !tbaa !65
  %dec = add nsw i32 %0, -1
  store i32 %dec, i32* %dont_block, align 8, !tbaa !65
  %lock1 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 10
  call void @spin_unlock_irq(%struct.spinlock* %lock1)
  ret void
}

declare void @msleep(i32) #1

declare i32 @fw_run_transaction(%struct.fw_card*, i32, i32, i32, i32, i64, i8*, i64) #1

declare void @fw_send_response(%struct.fw_card*, %struct.fw_request*, i32) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @__be32_to_cpup(i32* %p) #5 {
entry:
  %call = call i32 @__swab32p(i32* %p)
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @__swab32p(i32* %p) #5 {
entry:
  %0 = load i32, i32* %p, align 4, !tbaa !40
  %call = call i32 @__fswab32(i32 %0) #7
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_scsi_queuecommand(%struct.Scsi_Host* %shost, %struct.scsi_cmnd* %cmd) #2 {
entry:
  %device = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 1
  %0 = load %struct.scsi_device*, %struct.scsi_device** %device, align 8, !tbaa !158
  %hostdata = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %0, i32 0, i32 21
  %1 = load i8*, i8** %hostdata, align 8, !tbaa !164
  %2 = bitcast i8* %1 to %struct.sbp2_logical_unit*
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %2, i32 0, i32 0
  %3 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %3)
  %call3 = call i8* @kzalloc(i64 1392, i32 17301536)
  %4 = bitcast i8* %call3 to %struct.sbp2_command_orb*
  %cmp = icmp eq %struct.sbp2_command_orb* %4, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %base = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %4, i32 0, i32 0
  %rcode = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base, i32 0, i32 3
  store i32 -1, i32* %rcode, align 8, !tbaa !167
  %base4 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %4, i32 0, i32 0
  %kref = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base4, i32 0, i32 1
  call void @kref_init(%struct.kref* %kref)
  %cmd5 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %4, i32 0, i32 2
  store %struct.scsi_cmnd* %cmd, %struct.scsi_cmnd** %cmd5, align 8, !tbaa !170
  %request = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %4, i32 0, i32 1
  %next = getelementptr inbounds %struct.anon.71, %struct.anon.71* %request, i32 0, i32 0
  %high = getelementptr inbounds %struct.anon.30, %struct.anon.30* %next, i32 0, i32 0
  store i32 128, i32* %high, align 8, !tbaa !171
  %tgt6 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %2, i32 0, i32 0
  %5 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt6, align 8, !tbaa !67
  %max_payload = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %5, i32 0, i32 9
  %6 = load i32, i32* %max_payload, align 4, !tbaa !50
  %shl = shl i32 %6, 20
  %max_speed = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 4
  %7 = load i32, i32* %max_speed, align 8, !tbaa !48
  %shl7 = shl i32 %7, 24
  %or = or i32 %shl, %shl7
  %or8 = or i32 %or, -2147483648
  %call9 = call i32 @__fswab32(i32 %or8) #7
  %request10 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %4, i32 0, i32 1
  %misc = getelementptr inbounds %struct.anon.71, %struct.anon.71* %request10, i32 0, i32 2
  store i32 %call9, i32* %misc, align 8, !tbaa !172
  %sc_data_direction = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 14
  %8 = load i32, i32* %sc_data_direction, align 8, !tbaa !173
  %cmp11 = icmp eq i32 %8, 2
  br i1 %cmp11, label %if.then12, label %if.end16

if.then12:                                        ; preds = %if.end
  %request13 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %4, i32 0, i32 1
  %misc14 = getelementptr inbounds %struct.anon.71, %struct.anon.71* %request13, i32 0, i32 2
  %9 = load i32, i32* %misc14, align 8, !tbaa !172
  %or15 = or i32 %9, 8
  store i32 %or15, i32* %misc14, align 8, !tbaa !172
  br label %if.end16

if.end16:                                         ; preds = %if.then12, %if.end
  %generation17 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 3
  %10 = load i32, i32* %generation17, align 4, !tbaa !59
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !174
  %call18 = call i32 @scsi_sg_count(%struct.scsi_cmnd* %cmd)
  %tobool = icmp ne i32 %call18, 0
  br i1 %tobool, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %if.end16
  %call19 = call i32 @sbp2_map_scatterlist(%struct.sbp2_command_orb* %4, %struct.fw_device* %call, %struct.sbp2_logical_unit* %2)
  %cmp20 = icmp slt i32 %call19, 0
  br i1 %cmp20, label %out, label %if.end22

if.end22:                                         ; preds = %land.lhs.true, %if.end16
  %request23 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %4, i32 0, i32 1
  %command_block = getelementptr inbounds %struct.anon.71, %struct.anon.71* %request23, i32 0, i32 3
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %command_block, i32 0, i32 0
  %cmnd = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 15
  %11 = load i8*, i8** %cmnd, align 8, !tbaa !175
  %cmd_len = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 13
  %12 = load i16, i16* %cmd_len, align 4, !tbaa !176
  %conv = zext i16 %12 to i64
  %call24 = call i8* @__memcpy(i8* %arraydecay, i8* %11, i64 %conv)
  %base25 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %4, i32 0, i32 0
  %callback = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base25, i32 0, i32 4
  store void (%struct.sbp2_orb*, %struct.sbp2_status*)* @complete_command_orb, void (%struct.sbp2_orb*, %struct.sbp2_status*)** %callback, align 8, !tbaa !177
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %13 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %device26 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %13, i32 0, i32 1
  %14 = load %struct.device*, %struct.device** %device26, align 8, !tbaa !35
  %request27 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %4, i32 0, i32 1
  %15 = bitcast %struct.anon.71* %request27 to i8*
  %call28 = call i64 @dma_map_single_attrs(%struct.device* %14, i8* %15, i64 36, i32 1, i64 0)
  %base29 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %4, i32 0, i32 0
  %request_bus = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base29, i32 0, i32 2
  store i64 %call28, i64* %request_bus, align 8, !tbaa !178
  %card30 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %16 = load %struct.fw_card*, %struct.fw_card** %card30, align 8, !tbaa !2
  %device31 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %16, i32 0, i32 1
  %17 = load %struct.device*, %struct.device** %device31, align 8, !tbaa !35
  %base32 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %4, i32 0, i32 0
  %request_bus33 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base32, i32 0, i32 2
  %18 = load i64, i64* %request_bus33, align 8, !tbaa !178
  %call34 = call i32 @dma_mapping_error(%struct.device* %17, i64 %18)
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %if.then36, label %if.end39

if.then36:                                        ; preds = %if.end22
  %card37 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %19 = load %struct.fw_card*, %struct.fw_card** %card37, align 8, !tbaa !2
  %device38 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %19, i32 0, i32 1
  %20 = load %struct.device*, %struct.device** %device38, align 8, !tbaa !35
  call void @sbp2_unmap_scatterlist(%struct.device* %20, %struct.sbp2_command_orb* %4)
  br label %out

if.end39:                                         ; preds = %if.end22
  %base40 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %4, i32 0, i32 0
  %tgt41 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %2, i32 0, i32 0
  %21 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt41, align 8, !tbaa !67
  %node_id = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %21, i32 0, i32 5
  %22 = load i32, i32* %node_id, align 4, !tbaa !144
  %command_block_agent_address = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %2, i32 0, i32 4
  %23 = load i64, i64* %command_block_agent_address, align 8, !tbaa !150
  %add = add i64 %23, 8
  call void @sbp2_send_orb(%struct.sbp2_orb* %base40, %struct.sbp2_logical_unit* %2, i32 %22, i32 %10, i64 %add)
  br label %out

out:                                              ; preds = %if.end39, %if.then36, %land.lhs.true
  %retval2.0 = phi i32 [ 4181, %if.then36 ], [ 0, %if.end39 ], [ 4181, %land.lhs.true ]
  %base42 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %4, i32 0, i32 0
  %kref43 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base42, i32 0, i32 1
  call void @kref_put(%struct.kref* %kref43, void (%struct.kref*)* @free_orb)
  br label %cleanup

cleanup:                                          ; preds = %out, %entry
  %retval.0 = phi i32 [ %retval2.0, %out ], [ 4181, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_scsi_abort(%struct.scsi_cmnd* %cmd) #2 {
entry:
  %device = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 1
  %0 = load %struct.scsi_device*, %struct.scsi_device** %device, align 8, !tbaa !158
  %hostdata = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %0, i32 0, i32 21
  %1 = load i8*, i8** %hostdata, align 8, !tbaa !164
  %2 = bitcast i8* %1 to %struct.sbp2_logical_unit*
  %call = call %struct.device* @lu_dev(%struct.sbp2_logical_unit* %2)
  call void (%struct.device*, i8*, ...) @dev_notice(%struct.device* %call, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.8, i32 0, i32 0))
  call void @sbp2_agent_reset(%struct.sbp2_logical_unit* %2)
  %call1 = call i32 @sbp2_cancel_orbs(%struct.sbp2_logical_unit* %2)
  ret i32 8194
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_scsi_slave_alloc(%struct.scsi_device* %sdev) #2 {
entry:
  %hostdata = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 21
  %0 = load i8*, i8** %hostdata, align 8, !tbaa !164
  %1 = bitcast i8* %0 to %struct.sbp2_logical_unit*
  %tobool = icmp ne %struct.sbp2_logical_unit* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %allow_restart = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 39
  %2 = bitcast i48* %allow_restart to i64*
  %bf.load = load i64, i64* %2, align 8
  %bf.clear = and i64 %bf.load, -67108865
  %bf.set = or i64 %bf.clear, 67108864
  store i64 %bf.set, i64* %2, align 8
  %request_queue = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 1
  %3 = load %struct.request_queue*, %struct.request_queue** %request_queue, align 8, !tbaa !179
  call void @blk_queue_update_dma_alignment(%struct.request_queue* %3, i32 3)
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %4 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %workarounds = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %4, i32 0, i32 7
  %5 = load i32, i32* %workarounds, align 4, !tbaa !129
  %and = and i32 %5, 2
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then2, label %cleanup

if.then2:                                         ; preds = %if.end
  %inquiry_len = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 26
  store i8 36, i8* %inquiry_len, align 8, !tbaa !180
  br label %cleanup

cleanup:                                          ; preds = %if.then2, %if.end, %entry
  %retval.0 = phi i32 [ -38, %entry ], [ 0, %if.then2 ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_scsi_slave_configure(%struct.scsi_device* %sdev) #2 {
entry:
  %hostdata = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 21
  %0 = load i8*, i8** %hostdata, align 8, !tbaa !164
  %1 = bitcast i8* %0 to %struct.sbp2_logical_unit*
  %use_10_for_rw = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 39
  %2 = bitcast i48* %use_10_for_rw to i64*
  %bf.load = load i64, i64* %2, align 8
  %bf.clear = and i64 %bf.load, -32769
  %bf.set = or i64 %bf.clear, 32768
  store i64 %bf.set, i64* %2, align 8
  %3 = load i8, i8* @sbp2_param_exclusive_login, align 1, !tbaa !83, !range !84
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %manage_start_stop = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 39
  %4 = bitcast i48* %manage_start_stop to i64*
  %bf.load1 = load i64, i64* %4, align 8
  %bf.clear2 = and i64 %bf.load1, -134217729
  %bf.set3 = or i64 %bf.clear2, 134217728
  store i64 %bf.set3, i64* %4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %type = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 22
  %5 = load i8, i8* %type, align 8, !tbaa !181
  %conv = sext i8 %5 to i32
  %cmp = icmp eq i32 %conv, 5
  br i1 %cmp, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.end
  %use_10_for_ms = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 39
  %6 = bitcast i48* %use_10_for_ms to i64*
  %bf.load6 = load i64, i64* %6, align 8
  %bf.clear7 = and i64 %bf.load6, -65537
  %bf.set8 = or i64 %bf.clear7, 65536
  store i64 %bf.set8, i64* %6, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then5, %if.end
  %type10 = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 22
  %7 = load i8, i8* %type10, align 8, !tbaa !181
  %conv11 = sext i8 %7 to i32
  %cmp12 = icmp eq i32 %conv11, 0
  br i1 %cmp12, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %if.end9
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %8 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %workarounds = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %8, i32 0, i32 7
  %9 = load i32, i32* %workarounds, align 4, !tbaa !129
  %and = and i32 %9, 4
  %tobool14 = icmp ne i32 %and, 0
  br i1 %tobool14, label %if.then15, label %if.end19

if.then15:                                        ; preds = %land.lhs.true
  %skip_ms_page_8 = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 39
  %10 = bitcast i48* %skip_ms_page_8 to i64*
  %bf.load16 = load i64, i64* %10, align 8
  %bf.clear17 = and i64 %bf.load16, -1048577
  %bf.set18 = or i64 %bf.clear17, 1048576
  store i64 %bf.set18, i64* %10, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then15, %land.lhs.true, %if.end9
  %tgt20 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %11 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt20, align 8, !tbaa !67
  %workarounds21 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %11, i32 0, i32 7
  %12 = load i32, i32* %workarounds21, align 4, !tbaa !129
  %and22 = and i32 %12, 8
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end28

if.then24:                                        ; preds = %if.end19
  %fix_capacity = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 39
  %13 = bitcast i48* %fix_capacity to i64*
  %bf.load25 = load i64, i64* %13, align 8
  %bf.clear26 = and i64 %bf.load25, -2147483649
  %bf.set27 = or i64 %bf.clear26, 2147483648
  store i64 %bf.set27, i64* %13, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.then24, %if.end19
  %tgt29 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %14 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt29, align 8, !tbaa !67
  %workarounds30 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %14, i32 0, i32 7
  %15 = load i32, i32* %workarounds30, align 4, !tbaa !129
  %and31 = and i32 %15, 32
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.then33, label %if.end37

if.then33:                                        ; preds = %if.end28
  %start_stop_pwr_cond = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 39
  %16 = bitcast i48* %start_stop_pwr_cond to i64*
  %bf.load34 = load i64, i64* %16, align 8
  %bf.clear35 = and i64 %bf.load34, -268435457
  %bf.set36 = or i64 %bf.clear35, 268435456
  store i64 %bf.set36, i64* %16, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.then33, %if.end28
  %tgt38 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %17 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt38, align 8, !tbaa !67
  %workarounds39 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %17, i32 0, i32 7
  %18 = load i32, i32* %workarounds39, align 4, !tbaa !129
  %and40 = and i32 %18, 1
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.end37
  %request_queue = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 1
  %19 = load %struct.request_queue*, %struct.request_queue** %request_queue, align 8, !tbaa !179
  call void @blk_queue_max_hw_sectors(%struct.request_queue* %19, i32 256)
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %if.end37
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i64 @sbp2_sysfs_ieee1394_id_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #2 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -632
  %1 = bitcast i8* %add.ptr to %struct.scsi_device*
  %tobool = icmp ne %struct.scsi_device* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %hostdata = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %1, i32 0, i32 21
  %2 = load i8*, i8** %hostdata, align 8, !tbaa !164
  %3 = bitcast i8* %2 to %struct.sbp2_logical_unit*
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %3, i32 0, i32 0
  %4 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %guid = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %4, i32 0, i32 3
  %5 = load i64, i64* %guid, align 8, !tbaa !41
  %tgt1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %3, i32 0, i32 0
  %6 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt1, align 8, !tbaa !67
  %directory_id = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 4
  %7 = load i32, i32* %directory_id, align 8, !tbaa !47
  %lun = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %3, i32 0, i32 5
  %8 = load i16, i16* %lun, align 8, !tbaa !57
  %conv = zext i16 %8 to i32
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.10, i32 0, i32 0), i64 %5, i32 %7, i32 %conv)
  %conv2 = sext i32 %call to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv2, %if.end ], [ 0, %entry ]
  ret i64 %retval.0
}

declare i32 @sprintf(i8*, i8*, ...) #1

declare void @blk_queue_max_hw_sectors(%struct.request_queue*, i32) #1

declare void @blk_queue_update_dma_alignment(%struct.request_queue*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @scsi_sg_count(%struct.scsi_cmnd* %cmd) #3 {
entry:
  %sdb = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 16
  %table = getelementptr inbounds %struct.scsi_data_buffer, %struct.scsi_data_buffer* %sdb, i32 0, i32 0
  %nents = getelementptr inbounds %struct.sg_table, %struct.sg_table* %table, i32 0, i32 1
  %0 = load i32, i32* %nents, align 8, !tbaa !182
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_map_scatterlist(%struct.sbp2_command_orb* %orb, %struct.fw_device* %device, %struct.sbp2_logical_unit* %lu) #2 {
entry:
  %cmd = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 2
  %0 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd, align 8, !tbaa !170
  %call = call %struct.scatterlist* @scsi_sglist(%struct.scsi_cmnd* %0)
  %cmd1 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 2
  %1 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd1, align 8, !tbaa !170
  %call2 = call i32 @scsi_dma_map(%struct.scsi_cmnd* %1)
  %cmp = icmp sle i32 %call2, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp3 = icmp eq i32 %call2, 1
  br i1 %cmp3, label %if.then4, label %if.end11

if.then4:                                         ; preds = %if.end
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %2 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %address_high = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %2, i32 0, i32 6
  %3 = load i32, i32* %address_high, align 8, !tbaa !145
  %call5 = call i32 @__fswab32(i32 %3) #7
  %request = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 1
  %data_descriptor = getelementptr inbounds %struct.anon.71, %struct.anon.71* %request, i32 0, i32 1
  %high = getelementptr inbounds %struct.anon.30, %struct.anon.30* %data_descriptor, i32 0, i32 0
  store i32 %call5, i32* %high, align 8, !tbaa !183
  %dma_address = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %call, i32 0, i32 4
  %4 = load i64, i64* %dma_address, align 8, !tbaa !184
  %conv = trunc i64 %4 to i32
  %call6 = call i32 @__fswab32(i32 %conv) #7
  %request7 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 1
  %data_descriptor8 = getelementptr inbounds %struct.anon.71, %struct.anon.71* %request7, i32 0, i32 1
  %low = getelementptr inbounds %struct.anon.30, %struct.anon.30* %data_descriptor8, i32 0, i32 1
  store i32 %call6, i32* %low, align 4, !tbaa !186
  %dma_length = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %call, i32 0, i32 5
  %5 = load i32, i32* %dma_length, align 8, !tbaa !187
  %call9 = call i32 @__fswab32(i32 %5) #7
  %request10 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 1
  %misc = getelementptr inbounds %struct.anon.71, %struct.anon.71* %request10, i32 0, i32 2
  %6 = load i32, i32* %misc, align 8, !tbaa !172
  %or = or i32 %6, %call9
  store i32 %or, i32* %misc, align 8, !tbaa !172
  br label %cleanup

if.end11:                                         ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end11
  %sg.0 = phi %struct.scatterlist* [ %call, %if.end11 ], [ %call24, %for.body ]
  %i.0 = phi i32 [ 0, %if.end11 ], [ %inc, %for.body ]
  %cmp12 = icmp slt i32 %i.0, %call2
  br i1 %cmp12, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %dma_length14 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg.0, i32 0, i32 5
  %7 = load i32, i32* %dma_length14, align 8, !tbaa !187
  %shl = shl i32 %7, 16
  %call15 = call i32 @__fswab32(i32 %shl) #7
  %page_table = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [128 x %struct.anon.30], [128 x %struct.anon.30]* %page_table, i64 0, i64 %idxprom
  %high16 = getelementptr inbounds %struct.anon.30, %struct.anon.30* %arrayidx, i32 0, i32 0
  store i32 %call15, i32* %high16, align 8, !tbaa !102
  %dma_address17 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg.0, i32 0, i32 4
  %8 = load i64, i64* %dma_address17, align 8, !tbaa !184
  %conv18 = trunc i64 %8 to i32
  %call19 = call i32 @__fswab32(i32 %conv18) #7
  %page_table20 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 3
  %idxprom21 = sext i32 %i.0 to i64
  %arrayidx22 = getelementptr inbounds [128 x %struct.anon.30], [128 x %struct.anon.30]* %page_table20, i64 0, i64 %idxprom21
  %low23 = getelementptr inbounds %struct.anon.30, %struct.anon.30* %arrayidx22, i32 0, i32 1
  store i32 %call19, i32* %low23, align 4, !tbaa !104
  %inc = add nsw i32 %i.0, 1
  %call24 = call %struct.scatterlist* @sg_next(%struct.scatterlist* %sg.0)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %device, i32 0, i32 5
  %9 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %device25 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %9, i32 0, i32 1
  %10 = load %struct.device*, %struct.device** %device25, align 8, !tbaa !35
  %page_table26 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 3
  %arraydecay = getelementptr inbounds [128 x %struct.anon.30], [128 x %struct.anon.30]* %page_table26, i32 0, i32 0
  %11 = bitcast %struct.anon.30* %arraydecay to i8*
  %call27 = call i64 @dma_map_single_attrs(%struct.device* %10, i8* %11, i64 1024, i32 1, i64 0)
  %page_table_bus = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 4
  store i64 %call27, i64* %page_table_bus, align 8, !tbaa !188
  %card28 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %device, i32 0, i32 5
  %12 = load %struct.fw_card*, %struct.fw_card** %card28, align 8, !tbaa !2
  %device29 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %12, i32 0, i32 1
  %13 = load %struct.device*, %struct.device** %device29, align 8, !tbaa !35
  %page_table_bus30 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 4
  %14 = load i64, i64* %page_table_bus30, align 8, !tbaa !188
  %call31 = call i32 @dma_mapping_error(%struct.device* %13, i64 %14)
  %tobool = icmp ne i32 %call31, 0
  br i1 %tobool, label %fail_page_table, label %if.end33

if.end33:                                         ; preds = %for.end
  %tgt34 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %15 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt34, align 8, !tbaa !67
  %address_high35 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %15, i32 0, i32 6
  %16 = load i32, i32* %address_high35, align 8, !tbaa !145
  %call36 = call i32 @__fswab32(i32 %16) #7
  %request37 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 1
  %data_descriptor38 = getelementptr inbounds %struct.anon.71, %struct.anon.71* %request37, i32 0, i32 1
  %high39 = getelementptr inbounds %struct.anon.30, %struct.anon.30* %data_descriptor38, i32 0, i32 0
  store i32 %call36, i32* %high39, align 8, !tbaa !183
  %page_table_bus40 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 4
  %17 = load i64, i64* %page_table_bus40, align 8, !tbaa !188
  %conv41 = trunc i64 %17 to i32
  %call42 = call i32 @__fswab32(i32 %conv41) #7
  %request43 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 1
  %data_descriptor44 = getelementptr inbounds %struct.anon.71, %struct.anon.71* %request43, i32 0, i32 1
  %low45 = getelementptr inbounds %struct.anon.30, %struct.anon.30* %data_descriptor44, i32 0, i32 1
  store i32 %call42, i32* %low45, align 4, !tbaa !186
  %or46 = or i32 524288, %call2
  %call47 = call i32 @__fswab32(i32 %or46) #7
  %request48 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 1
  %misc49 = getelementptr inbounds %struct.anon.71, %struct.anon.71* %request48, i32 0, i32 2
  %18 = load i32, i32* %misc49, align 8, !tbaa !172
  %or50 = or i32 %18, %call47
  store i32 %or50, i32* %misc49, align 8, !tbaa !172
  br label %cleanup

fail_page_table:                                  ; preds = %for.end
  %cmd51 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 2
  %19 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd51, align 8, !tbaa !170
  call void @scsi_dma_unmap(%struct.scsi_cmnd* %19)
  br label %cleanup

cleanup:                                          ; preds = %fail_page_table, %if.end33, %if.then4, %entry
  %retval.0 = phi i32 [ 0, %if.then4 ], [ 0, %if.end33 ], [ -12, %entry ], [ -12, %fail_page_table ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @complete_command_orb(%struct.sbp2_orb* %base_orb, %struct.sbp2_status* %status) #2 {
entry:
  %0 = bitcast %struct.sbp2_orb* %base_orb to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sbp2_command_orb*
  %lu = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base_orb, i32 0, i32 5
  %2 = load %struct.sbp2_logical_unit*, %struct.sbp2_logical_unit** %lu, align 8, !tbaa !105
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %2, i32 0, i32 0
  %3 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %3)
  %cmp = icmp ne %struct.sbp2_status* %status, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %status1 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  %4 = load i32, i32* %status1, align 4, !tbaa !140
  %shr = lshr i32 %4, 27
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %lu3 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base_orb, i32 0, i32 5
  %5 = load %struct.sbp2_logical_unit*, %struct.sbp2_logical_unit** %lu3, align 8, !tbaa !105
  call void @sbp2_agent_reset_no_wait(%struct.sbp2_logical_unit* %5)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %status4 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  %6 = load i32, i32* %status4, align 4, !tbaa !140
  %shr5 = lshr i32 %6, 28
  %and6 = and i32 %shr5, 3
  %Pivot4 = icmp slt i32 %and6, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %and6, 2
  br i1 %Pivot, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %and6, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %NodeBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %NodeBlock
  %result.0 = phi i32 [ 458752, %sw.default ], [ 0, %LeafBlock ], [ 131072, %NodeBlock ]
  %cmp9 = icmp eq i32 %result.0, 0
  br i1 %cmp9, label %land.lhs.true, label %if.end18

land.lhs.true:                                    ; preds = %sw.epilog
  %status10 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  %7 = load i32, i32* %status10, align 4, !tbaa !140
  %shr11 = lshr i32 %7, 24
  %and12 = and i32 %shr11, 7
  %cmp13 = icmp ugt i32 %and12, 1
  br i1 %cmp13, label %if.then14, label %if.end18

if.then14:                                        ; preds = %land.lhs.true
  %data = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 2
  %arraydecay = getelementptr inbounds [24 x i8], [24 x i8]* %data, i32 0, i32 0
  %cmd = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %1, i32 0, i32 2
  %8 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd, align 8, !tbaa !170
  %sense_buffer = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %8, i32 0, i32 21
  %9 = load i8*, i8** %sense_buffer, align 8, !tbaa !189
  %call15 = call i32 @sbp2_status_to_sense_data(i8* %arraydecay, i8* %9)
  br label %if.end18

if.else:                                          ; preds = %entry
  %lu17 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base_orb, i32 0, i32 5
  %10 = load %struct.sbp2_logical_unit*, %struct.sbp2_logical_unit** %lu17, align 8, !tbaa !105
  call void @sbp2_conditionally_block(%struct.sbp2_logical_unit* %10)
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then14, %land.lhs.true, %sw.epilog
  %result.2 = phi i32 [ 131072, %if.else ], [ %call15, %if.then14 ], [ %result.0, %land.lhs.true ], [ %result.0, %sw.epilog ]
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %11 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %device19 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %11, i32 0, i32 1
  %12 = load %struct.device*, %struct.device** %device19, align 8, !tbaa !35
  %base = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %1, i32 0, i32 0
  %request_bus = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base, i32 0, i32 2
  %13 = load i64, i64* %request_bus, align 8, !tbaa !178
  call void @dma_unmap_single_attrs(%struct.device* %12, i64 %13, i64 36, i32 1, i64 0)
  %card20 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %14 = load %struct.fw_card*, %struct.fw_card** %card20, align 8, !tbaa !2
  %device21 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %14, i32 0, i32 1
  %15 = load %struct.device*, %struct.device** %device21, align 8, !tbaa !35
  call void @sbp2_unmap_scatterlist(%struct.device* %15, %struct.sbp2_command_orb* %1)
  %cmd22 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %1, i32 0, i32 2
  %16 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd22, align 8, !tbaa !170
  %result23 = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %16, i32 0, i32 25
  store i32 %result.2, i32* %result23, align 8, !tbaa !190
  %cmd24 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %1, i32 0, i32 2
  %17 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd24, align 8, !tbaa !170
  %scsi_done = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %17, i32 0, i32 22
  %18 = load void (%struct.scsi_cmnd*)*, void (%struct.scsi_cmnd*)** %scsi_done, align 8, !tbaa !191
  %cmd25 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %1, i32 0, i32 2
  %19 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd25, align 8, !tbaa !170
  call void %18(%struct.scsi_cmnd* %19)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_unmap_scatterlist(%struct.device* %card_device, %struct.sbp2_command_orb* %orb) #2 {
entry:
  %cmd = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 2
  %0 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd, align 8, !tbaa !170
  call void @scsi_dma_unmap(%struct.scsi_cmnd* %0)
  %request = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 1
  %misc = getelementptr inbounds %struct.anon.71, %struct.anon.71* %request, i32 0, i32 2
  %1 = load i32, i32* %misc, align 8, !tbaa !172
  %and = and i32 %1, 2048
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %page_table_bus = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 4
  %2 = load i64, i64* %page_table_bus, align 8, !tbaa !188
  call void @dma_unmap_single_attrs(%struct.device* %card_device, i64 %2, i64 1024, i32 1, i64 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @scsi_dma_unmap(%struct.scsi_cmnd*) #1

; Function Attrs: nounwind uwtable
define internal void @sbp2_agent_reset_no_wait(%struct.sbp2_logical_unit* %lu) #2 {
entry:
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !67
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %call1 = call i8* @kmalloc(i64 256, i32 17301536)
  %1 = bitcast i8* %call1 to %struct.fw_transaction*
  %cmp = icmp eq %struct.fw_transaction* %1, null
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %2 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %tgt2 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %3 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt2, align 8, !tbaa !67
  %node_id = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %3, i32 0, i32 5
  %4 = load i32, i32* %node_id, align 4, !tbaa !144
  %generation = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 7
  %5 = load i32, i32* %generation, align 8, !tbaa !117
  %max_speed = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 4
  %6 = load i32, i32* %max_speed, align 8, !tbaa !48
  %command_block_agent_address = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 4
  %7 = load i64, i64* %command_block_agent_address, align 8, !tbaa !150
  %add = add i64 %7, 4
  %8 = bitcast %struct.fw_transaction* %1 to i8*
  call void @fw_send_request(%struct.fw_card* %2, %struct.fw_transaction* %1, i32 0, i32 %4, i32 %5, i32 %6, i64 %add, i8* bitcast (i32* @sbp2_agent_reset_no_wait.d to i8*), i64 4, void (%struct.fw_card*, i32, i8*, i64, i8*)* @complete_agent_reset_write_no_wait, i8* %8)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end ], [ 1, %entry ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_status_to_sense_data(i8* %sbp2_status, i8* %sense_data) #2 {
entry:
  %arrayidx = getelementptr inbounds i8, i8* %sbp2_status, i64 0
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !66
  %conv = zext i8 %0 to i32
  %shr = ashr i32 %conv, 6
  %and = and i32 %shr, 3
  %and.off = add i32 %and, -2
  %switch = icmp ult i32 %and.off, 2
  br i1 %switch, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %or = or i32 112, %and
  %arrayidx4 = getelementptr inbounds i8, i8* %sbp2_status, i64 1
  %1 = load i8, i8* %arrayidx4, align 1, !tbaa !66
  %conv5 = zext i8 %1 to i32
  %and6 = and i32 %conv5, 128
  %or7 = or i32 %or, %and6
  %conv8 = trunc i32 %or7 to i8
  %arrayidx9 = getelementptr inbounds i8, i8* %sense_data, i64 0
  store i8 %conv8, i8* %arrayidx9, align 1, !tbaa !66
  %arrayidx10 = getelementptr inbounds i8, i8* %sense_data, i64 1
  store i8 0, i8* %arrayidx10, align 1, !tbaa !66
  %arrayidx11 = getelementptr inbounds i8, i8* %sbp2_status, i64 1
  %2 = load i8, i8* %arrayidx11, align 1, !tbaa !66
  %conv12 = zext i8 %2 to i32
  %shl = shl i32 %conv12, 1
  %and13 = and i32 %shl, 224
  %arrayidx14 = getelementptr inbounds i8, i8* %sbp2_status, i64 1
  %3 = load i8, i8* %arrayidx14, align 1, !tbaa !66
  %conv15 = zext i8 %3 to i32
  %and16 = and i32 %conv15, 15
  %or17 = or i32 %and13, %and16
  %conv18 = trunc i32 %or17 to i8
  %arrayidx19 = getelementptr inbounds i8, i8* %sense_data, i64 2
  store i8 %conv18, i8* %arrayidx19, align 1, !tbaa !66
  %arrayidx20 = getelementptr inbounds i8, i8* %sbp2_status, i64 4
  %4 = load i8, i8* %arrayidx20, align 1, !tbaa !66
  %arrayidx21 = getelementptr inbounds i8, i8* %sense_data, i64 3
  store i8 %4, i8* %arrayidx21, align 1, !tbaa !66
  %arrayidx22 = getelementptr inbounds i8, i8* %sbp2_status, i64 5
  %5 = load i8, i8* %arrayidx22, align 1, !tbaa !66
  %arrayidx23 = getelementptr inbounds i8, i8* %sense_data, i64 4
  store i8 %5, i8* %arrayidx23, align 1, !tbaa !66
  %arrayidx24 = getelementptr inbounds i8, i8* %sbp2_status, i64 6
  %6 = load i8, i8* %arrayidx24, align 1, !tbaa !66
  %arrayidx25 = getelementptr inbounds i8, i8* %sense_data, i64 5
  store i8 %6, i8* %arrayidx25, align 1, !tbaa !66
  %arrayidx26 = getelementptr inbounds i8, i8* %sbp2_status, i64 7
  %7 = load i8, i8* %arrayidx26, align 1, !tbaa !66
  %arrayidx27 = getelementptr inbounds i8, i8* %sense_data, i64 6
  store i8 %7, i8* %arrayidx27, align 1, !tbaa !66
  %arrayidx28 = getelementptr inbounds i8, i8* %sense_data, i64 7
  store i8 10, i8* %arrayidx28, align 1, !tbaa !66
  %arrayidx29 = getelementptr inbounds i8, i8* %sbp2_status, i64 8
  %8 = load i8, i8* %arrayidx29, align 1, !tbaa !66
  %arrayidx30 = getelementptr inbounds i8, i8* %sense_data, i64 8
  store i8 %8, i8* %arrayidx30, align 1, !tbaa !66
  %arrayidx31 = getelementptr inbounds i8, i8* %sbp2_status, i64 9
  %9 = load i8, i8* %arrayidx31, align 1, !tbaa !66
  %arrayidx32 = getelementptr inbounds i8, i8* %sense_data, i64 9
  store i8 %9, i8* %arrayidx32, align 1, !tbaa !66
  %arrayidx33 = getelementptr inbounds i8, i8* %sbp2_status, i64 10
  %10 = load i8, i8* %arrayidx33, align 1, !tbaa !66
  %arrayidx34 = getelementptr inbounds i8, i8* %sense_data, i64 10
  store i8 %10, i8* %arrayidx34, align 1, !tbaa !66
  %arrayidx35 = getelementptr inbounds i8, i8* %sbp2_status, i64 11
  %11 = load i8, i8* %arrayidx35, align 1, !tbaa !66
  %arrayidx36 = getelementptr inbounds i8, i8* %sense_data, i64 11
  store i8 %11, i8* %arrayidx36, align 1, !tbaa !66
  %arrayidx37 = getelementptr inbounds i8, i8* %sbp2_status, i64 2
  %12 = load i8, i8* %arrayidx37, align 1, !tbaa !66
  %arrayidx38 = getelementptr inbounds i8, i8* %sense_data, i64 12
  store i8 %12, i8* %arrayidx38, align 1, !tbaa !66
  %arrayidx39 = getelementptr inbounds i8, i8* %sbp2_status, i64 3
  %13 = load i8, i8* %arrayidx39, align 1, !tbaa !66
  %arrayidx40 = getelementptr inbounds i8, i8* %sense_data, i64 13
  store i8 %13, i8* %arrayidx40, align 1, !tbaa !66
  %arrayidx41 = getelementptr inbounds i8, i8* %sbp2_status, i64 12
  %14 = load i8, i8* %arrayidx41, align 1, !tbaa !66
  %arrayidx42 = getelementptr inbounds i8, i8* %sense_data, i64 14
  store i8 %14, i8* %arrayidx42, align 1, !tbaa !66
  %arrayidx43 = getelementptr inbounds i8, i8* %sbp2_status, i64 13
  %15 = load i8, i8* %arrayidx43, align 1, !tbaa !66
  %arrayidx44 = getelementptr inbounds i8, i8* %sense_data, i64 15
  store i8 %15, i8* %arrayidx44, align 1, !tbaa !66
  %arrayidx45 = getelementptr inbounds i8, i8* %sbp2_status, i64 0
  %16 = load i8, i8* %arrayidx45, align 1, !tbaa !66
  %conv46 = zext i8 %16 to i32
  %and47 = and i32 %conv46, 63
  %Pivot18 = icmp slt i32 %and47, 8
  br i1 %Pivot18, label %NodeBlock5, label %NodeBlock15

NodeBlock15:                                      ; preds = %if.end
  %Pivot16 = icmp slt i32 %and47, 24
  br i1 %Pivot16, label %LeafBlock7, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %and47, 34
  br i1 %Pivot14, label %LeafBlock9, label %LeafBlock11

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %and47, 34
  br i1 %SwitchLeaf12, label %sw.bb, label %cleanup

LeafBlock9:                                       ; preds = %NodeBlock13
  %SwitchLeaf10 = icmp eq i32 %and47, 24
  br i1 %SwitchLeaf10, label %sw.bb, label %cleanup

LeafBlock7:                                       ; preds = %NodeBlock15
  %SwitchLeaf8 = icmp eq i32 %and47, 8
  br i1 %SwitchLeaf8, label %sw.bb, label %cleanup

NodeBlock5:                                       ; preds = %if.end
  %Pivot6 = icmp slt i32 %and47, 2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %and47, 4
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %and47, 4
  br i1 %SwitchLeaf4, label %sw.bb, label %cleanup

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and47, 2
  br i1 %SwitchLeaf2, label %sw.bb, label %cleanup

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %and47, 0
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock11
  %or48 = or i32 0, %and47
  br label %cleanup

cleanup:                                          ; preds = %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock11, %entry
  %retval.0 = phi i32 [ %or48, %sw.bb ], [ 458752, %entry ], [ 458752, %LeafBlock ], [ 458752, %LeafBlock1 ], [ 458752, %LeafBlock3 ], [ 458752, %LeafBlock7 ], [ 458752, %LeafBlock9 ], [ 458752, %LeafBlock11 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @complete_agent_reset_write_no_wait(%struct.fw_card* %card, i32 %rcode, i8* %payload, i64 %length, i8* %data) #2 {
entry:
  call void @kfree(i8* %data)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.scatterlist* @scsi_sglist(%struct.scsi_cmnd* %cmd) #3 {
entry:
  %sdb = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 16
  %table = getelementptr inbounds %struct.scsi_data_buffer, %struct.scsi_data_buffer* %sdb, i32 0, i32 0
  %sgl = getelementptr inbounds %struct.sg_table, %struct.sg_table* %table, i32 0, i32 0
  %0 = load %struct.scatterlist*, %struct.scatterlist** %sgl, align 8, !tbaa !192
  ret %struct.scatterlist* %0
}

declare i32 @scsi_dma_map(%struct.scsi_cmnd*) #1

declare %struct.scatterlist* @sg_next(%struct.scatterlist*) #1

; Function Attrs: nounwind uwtable
define internal void @sbp2_cleanup() #0 section ".exit.text" {
entry:
  call void @driver_unregister(%struct.device_driver* getelementptr inbounds (%struct.fw_driver, %struct.fw_driver* @sbp2_driver, i32 0, i32 0))
  ret void
}

declare void @driver_unregister(%struct.device_driver*) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind }
attributes #5 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { inlinehint nounwind readnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind readnone }
attributes #8 = { nounwind }

!llvm.ident = !{!0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{!3, !8, i64 32}
!3 = !{!"fw_device", !4, i64 0, !8, i64 8, !5, i64 16, !5, i64 20, !5, i64 24, !8, i64 32, !9, i64 40, !21, i64 1464, !11, i64 1624, !8, i64 1640, !17, i64 1648, !5, i64 1656, !5, i64 1660, !5, i64 1660, !5, i64 1660, !5, i64 1660, !5, i64 1660, !8, i64 1664, !14, i64 1672, !33, i64 1864}
!4 = !{!"", !5, i64 0}
!5 = !{!"int", !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C/C++ TBAA"}
!8 = !{!"any pointer", !6, i64 0}
!9 = !{!"device", !8, i64 0, !8, i64 8, !10, i64 16, !8, i64 280, !8, i64 288, !21, i64 296, !8, i64 456, !8, i64 464, !8, i64 472, !8, i64 480, !24, i64 488, !25, i64 528, !8, i64 1104, !8, i64 1112, !8, i64 1120, !11, i64 1128, !5, i64 1144, !8, i64 1152, !8, i64 1160, !30, i64 1168, !17, i64 1176, !8, i64 1184, !11, i64 1192, !8, i64 1208, !8, i64 1216, !31, i64 1224, !8, i64 1232, !8, i64 1240, !5, i64 1248, !5, i64 1252, !22, i64 1256, !11, i64 1328, !32, i64 1344, !8, i64 1376, !8, i64 1384, !8, i64 1392, !8, i64 1400, !8, i64 1408, !27, i64 1416, !27, i64 1416}
!10 = !{!"kobject", !8, i64 0, !11, i64 8, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !12, i64 56, !14, i64 64, !5, i64 256, !5, i64 256, !5, i64 256, !5, i64 256, !5, i64 256}
!11 = !{!"list_head", !8, i64 0, !8, i64 8}
!12 = !{!"kref", !13, i64 0}
!13 = !{!"refcount_struct", !4, i64 0}
!14 = !{!"delayed_work", !15, i64 0, !19, i64 80, !8, i64 176, !5, i64 184}
!15 = !{!"work_struct", !16, i64 0, !11, i64 8, !8, i64 24, !18, i64 32}
!16 = !{!"", !17, i64 0}
!17 = !{!"long", !6, i64 0}
!18 = !{!"lockdep_map", !8, i64 0, !6, i64 8, !8, i64 24, !5, i64 32, !17, i64 40}
!19 = !{!"timer_list", !20, i64 0, !17, i64 16, !8, i64 24, !17, i64 32, !5, i64 40, !18, i64 48}
!20 = !{!"hlist_node", !8, i64 0, !8, i64 8}
!21 = !{!"mutex", !16, i64 0, !22, i64 8, !23, i64 80, !11, i64 88, !8, i64 104, !18, i64 112}
!22 = !{!"spinlock", !6, i64 0}
!23 = !{!"optimistic_spin_queue", !4, i64 0}
!24 = !{!"dev_links_info", !11, i64 0, !11, i64 16, !6, i64 32}
!25 = !{!"dev_pm_info", !26, i64 0, !5, i64 4, !5, i64 4, !27, i64 4, !27, i64 4, !27, i64 4, !27, i64 4, !27, i64 4, !27, i64 4, !27, i64 5, !22, i64 8, !11, i64 80, !28, i64 96, !8, i64 192, !27, i64 200, !27, i64 200, !27, i64 200, !19, i64 208, !17, i64 304, !15, i64 312, !29, i64 392, !8, i64 480, !4, i64 488, !4, i64 492, !5, i64 496, !5, i64 496, !5, i64 496, !5, i64 496, !5, i64 496, !5, i64 496, !27, i64 497, !5, i64 497, !5, i64 497, !5, i64 497, !5, i64 497, !5, i64 497, !5, i64 500, !6, i64 504, !6, i64 508, !5, i64 512, !5, i64 516, !17, i64 520, !17, i64 528, !17, i64 536, !17, i64 544, !8, i64 552, !8, i64 560, !8, i64 568}
!26 = !{!"pm_message", !5, i64 0}
!27 = !{!"_Bool", !6, i64 0}
!28 = !{!"completion", !5, i64 0, !29, i64 8}
!29 = !{!"__wait_queue_head", !22, i64 0, !11, i64 72}
!30 = !{!"long long", !6, i64 0}
!31 = !{!"dev_archdata", !8, i64 0}
!32 = !{!"klist_node", !8, i64 0, !11, i64 8, !12, i64 24}
!33 = !{!"fw_attribute_group", !6, i64 0, !34, i64 16, !6, i64 56}
!34 = !{!"attribute_group", !8, i64 0, !8, i64 8, !8, i64 16, !8, i64 24, !8, i64 32}
!35 = !{!36, !8, i64 8}
!36 = !{!"fw_card", !8, i64 0, !8, i64 8, !12, i64 16, !28, i64 24, !5, i64 120, !5, i64 124, !5, i64 128, !30, i64 136, !11, i64 144, !30, i64 160, !5, i64 168, !5, i64 172, !5, i64 176, !5, i64 180, !30, i64 184, !5, i64 192, !5, i64 196, !5, i64 200, !22, i64 208, !8, i64 280, !8, i64 288, !8, i64 296, !6, i64 304, !5, i64 308, !27, i64 312, !5, i64 316, !11, i64 320, !11, i64 336, !14, i64 352, !27, i64 544, !14, i64 552, !5, i64 744, !5, i64 748, !5, i64 752, !27, i64 756, !27, i64 757, !27, i64 758, !27, i64 759, !5, i64 760, !6, i64 764, !5, i64 1788}
!37 = !{!38, !8, i64 0}
!38 = !{!"sbp2_target", !8, i64 0, !11, i64 8, !30, i64 24, !30, i64 32, !5, i64 40, !5, i64 44, !5, i64 48, !5, i64 52, !5, i64 56, !5, i64 60, !22, i64 64, !5, i64 136, !5, i64 140}
!39 = !{!3, !8, i64 1640}
!40 = !{!5, !5, i64 0}
!41 = !{!38, !30, i64 32}
!42 = !{!43, !44, i64 716}
!43 = !{!"Scsi_Host", !11, i64 0, !11, i64 16, !11, i64 32, !22, i64 48, !8, i64 120, !21, i64 128, !11, i64 288, !8, i64 304, !8, i64 312, !29, i64 320, !8, i64 408, !8, i64 416, !6, i64 424, !4, i64 664, !4, i64 668, !5, i64 672, !5, i64 676, !5, i64 680, !5, i64 684, !17, i64 688, !5, i64 696, !5, i64 700, !30, i64 704, !5, i64 712, !44, i64 716, !5, i64 720, !5, i64 724, !44, i64 728, !44, i64 730, !44, i64 732, !5, i64 736, !17, i64 744, !5, i64 752, !17, i64 760, !5, i64 768, !5, i64 768, !5, i64 768, !5, i64 768, !5, i64 768, !5, i64 768, !5, i64 768, !5, i64 769, !5, i64 769, !5, i64 769, !5, i64 769, !5, i64 769, !6, i64 770, !8, i64 792, !8, i64 800, !5, i64 808, !5, i64 812, !5, i64 816, !6, i64 820, !8, i64 824, !17, i64 832, !17, i64 840, !6, i64 848, !6, i64 849, !5, i64 852, !6, i64 856, !9, i64 864, !9, i64 2288, !11, i64 3712, !8, i64 3728, !8, i64 3736, !6, i64 3744}
!44 = !{!"short", !6, i64 0}
!45 = !{!46, !8, i64 1424}
!46 = !{!"fw_unit", !9, i64 0, !8, i64 1424, !33, i64 1432}
!47 = !{!38, !5, i64 40}
!48 = !{!3, !5, i64 24}
!49 = !{!36, !5, i64 192}
!50 = !{!38, !5, i64 60}
!51 = !{!8, !8, i64 0}
!52 = !{!53, !5, i64 108}
!53 = !{!"sbp2_logical_unit", !8, i64 0, !11, i64 8, !54, i64 24, !11, i64 72, !30, i64 88, !44, i64 96, !5, i64 100, !5, i64 104, !5, i64 108, !8, i64 112, !14, i64 120, !27, i64 312, !27, i64 313}
!54 = !{!"fw_address_handler", !30, i64 0, !30, i64 8, !8, i64 16, !8, i64 24, !11, i64 32}
!55 = !{!11, !8, i64 0}
!56 = !{!53, !8, i64 8}
!57 = !{!53, !44, i64 96}
!58 = !{!53, !5, i64 100}
!59 = !{!3, !5, i64 20}
!60 = !{i32 -2142516407}
!61 = !{!3, !5, i64 16}
!62 = !{!43, !5, i64 680}
!63 = !{!46, !8, i64 0}
!64 = !{!9, !8, i64 480}
!65 = !{!38, !5, i64 136}
!66 = !{!6, !6, i64 0}
!67 = !{!53, !8, i64 0}
!68 = !{!69, !30, i64 360}
!69 = !{!"sbp2_management_orb", !70, i64 0, !73, i64 312, !6, i64 344, !30, i64 360, !28, i64 368, !75, i64 464}
!70 = !{!"sbp2_orb", !71, i64 0, !12, i64 256, !30, i64 264, !5, i64 272, !8, i64 280, !8, i64 288, !11, i64 296}
!71 = !{!"fw_transaction", !5, i64 0, !5, i64 4, !11, i64 8, !8, i64 24, !27, i64 32, !19, i64 40, !72, i64 136, !8, i64 240, !8, i64 248}
!72 = !{!"fw_packet", !5, i64 0, !5, i64 4, !6, i64 8, !17, i64 24, !8, i64 32, !17, i64 40, !30, i64 48, !27, i64 56, !5, i64 60, !8, i64 64, !5, i64 72, !11, i64 80, !8, i64 96}
!73 = !{!"", !74, i64 0, !74, i64 8, !5, i64 16, !5, i64 20, !74, i64 24}
!74 = !{!"sbp2_pointer", !5, i64 0, !5, i64 4}
!75 = !{!"sbp2_status", !5, i64 0, !5, i64 4, !6, i64 8}
!76 = !{!69, !5, i64 320}
!77 = !{!69, !5, i64 324}
!78 = !{!69, !5, i64 328}
!79 = !{!69, !5, i64 332}
!80 = !{!53, !30, i64 24}
!81 = !{!69, !5, i64 336}
!82 = !{!69, !5, i64 340}
!83 = !{!27, !27, i64 0}
!84 = !{i8 0, i8 2}
!85 = !{!38, !5, i64 56}
!86 = !{!69, !8, i64 280}
!87 = !{!69, !30, i64 264}
!88 = !{!38, !30, i64 24}
!89 = !{!69, !5, i64 272}
!90 = !{!69, !5, i64 464}
!91 = !{!11, !8, i64 8}
!92 = !{!44, !44, i64 0}
!93 = !{!30, !30, i64 0}
!94 = !{i32 -2146920567}
!95 = !{i32 -2146920529}
!96 = !{i32 -2142824184, i32 -2142824159, i32 -2142823889, i32 -2142824092, i32 -2142824061, i32 -2142824031}
!97 = !{!98, !8, i64 32}
!98 = !{!"dma_map_ops", !8, i64 0, !8, i64 8, !8, i64 16, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !8, i64 56, !8, i64 64, !8, i64 72, !8, i64 80, !8, i64 88, !8, i64 96, !8, i64 104, !8, i64 112, !8, i64 120, !8, i64 128, !5, i64 136}
!99 = !{!17, !17, i64 0}
!100 = !{!98, !8, i64 112}
!101 = !{!28, !5, i64 0}
!102 = !{!74, !5, i64 0}
!103 = !{!70, !30, i64 264}
!104 = !{!74, !5, i64 4}
!105 = !{!70, !8, i64 288}
!106 = !{!70, !8, i64 296}
!107 = !{!70, !5, i64 272}
!108 = !{!70, !8, i64 280}
!109 = !{i32 -2142822961, i32 -2142822936, i32 -2142822666, i32 -2142822869, i32 -2142822838, i32 -2142822808}
!110 = !{!98, !8, i64 40}
!111 = !{!9, !8, i64 1152}
!112 = !{!9, !8, i64 456}
!113 = !{i32 -2146921234}
!114 = !{i32 -2146921196}
!115 = !{i32 733056}
!116 = !{!53, !27, i64 313}
!117 = !{!53, !5, i64 104}
!118 = !{!36, !5, i64 124}
!119 = !{!38, !5, i64 140}
!120 = !{!9, !8, i64 1184}
!121 = !{!122, !5, i64 0}
!122 = !{!"device_dma_parameters", !5, i64 0, !17, i64 8}
!123 = !{!124, !8, i64 0}
!124 = !{!"fw_csr_iterator", !8, i64 0, !8, i64 8}
!125 = !{!126, !5, i64 0}
!126 = !{!"", !5, i64 0, !5, i64 4, !5, i64 8}
!127 = !{!126, !5, i64 4}
!128 = !{!126, !5, i64 8}
!129 = !{!38, !5, i64 52}
!130 = !{!53, !30, i64 32}
!131 = !{!53, !8, i64 40}
!132 = !{!53, !8, i64 48}
!133 = !{!53, !27, i64 312}
!134 = !{!53, !8, i64 112}
!135 = !{!16, !17, i64 0}
!136 = !{i64 0, i64 8, !99}
!137 = !{!15, !8, i64 24}
!138 = !{!19, !8, i64 24}
!139 = !{!19, !17, i64 32}
!140 = !{!75, !5, i64 0}
!141 = !{!75, !5, i64 4}
!142 = !{i32 -2142533186}
!143 = !{!36, !5, i64 120}
!144 = !{!38, !5, i64 44}
!145 = !{!38, !5, i64 48}
!146 = !{i32 -2142533038}
!147 = !{!148, !5, i64 4}
!148 = !{!"sbp2_login_response", !5, i64 0, !74, i64 4, !5, i64 12}
!149 = !{!148, !5, i64 8}
!150 = !{!53, !30, i64 88}
!151 = !{!148, !5, i64 0}
!152 = !{i32 -2142530400}
!153 = !{i32 -2142530330}
!154 = !{i32 -2142530260}
!155 = !{i32 -2142529827}
!156 = !{i32 -2142529741}
!157 = !{i32 -2142529613}
!158 = !{!159, !8, i64 48}
!159 = !{!"scsi_cmnd", !160, i64 0, !8, i64 48, !11, i64 56, !11, i64 72, !14, i64 88, !5, i64 280, !17, i64 288, !17, i64 296, !5, i64 304, !5, i64 308, !6, i64 312, !6, i64 313, !6, i64 314, !44, i64 316, !6, i64 320, !8, i64 328, !161, i64 336, !8, i64 360, !5, i64 368, !5, i64 372, !8, i64 376, !8, i64 384, !8, i64 392, !163, i64 400, !8, i64 464, !5, i64 472, !5, i64 476, !6, i64 480}
!160 = !{!"scsi_request", !6, i64 0, !8, i64 16, !44, i64 24, !5, i64 28, !5, i64 32, !8, i64 40}
!161 = !{!"scsi_data_buffer", !162, i64 0, !5, i64 16, !5, i64 20}
!162 = !{!"sg_table", !8, i64 0, !5, i64 8, !5, i64 12}
!163 = !{!"scsi_pointer", !8, i64 0, !5, i64 8, !8, i64 16, !5, i64 24, !30, i64 32, !5, i64 40, !5, i64 44, !5, i64 48, !5, i64 52, !5, i64 56}
!164 = !{!165, !8, i64 216}
!165 = !{!"scsi_device", !8, i64 0, !8, i64 8, !11, i64 16, !11, i64 32, !4, i64 48, !4, i64 52, !22, i64 56, !11, i64 128, !11, i64 144, !44, i64 160, !44, i64 162, !44, i64 164, !44, i64 166, !17, i64 168, !17, i64 176, !17, i64 184, !5, i64 192, !5, i64 196, !30, i64 200, !5, i64 208, !5, i64 212, !8, i64 216, !6, i64 224, !6, i64 225, !6, i64 226, !21, i64 232, !6, i64 392, !8, i64 400, !8, i64 408, !8, i64 416, !8, i64 424, !5, i64 432, !8, i64 440, !5, i64 448, !8, i64 456, !6, i64 464, !8, i64 472, !5, i64 480, !5, i64 484, !5, i64 488, !5, i64 488, !5, i64 488, !5, i64 488, !5, i64 488, !5, i64 488, !5, i64 488, !5, i64 488, !5, i64 489, !5, i64 489, !5, i64 489, !5, i64 489, !5, i64 489, !5, i64 489, !5, i64 489, !5, i64 489, !5, i64 490, !5, i64 490, !5, i64 490, !5, i64 490, !5, i64 490, !5, i64 490, !5, i64 490, !5, i64 490, !5, i64 491, !5, i64 491, !5, i64 491, !5, i64 491, !5, i64 491, !5, i64 491, !5, i64 491, !5, i64 491, !5, i64 492, !5, i64 492, !5, i64 492, !5, i64 492, !5, i64 492, !5, i64 492, !5, i64 492, !5, i64 492, !5, i64 493, !5, i64 493, !5, i64 493, !5, i64 493, !4, i64 496, !6, i64 504, !6, i64 512, !11, i64 520, !15, i64 536, !5, i64 616, !4, i64 620, !4, i64 624, !4, i64 628, !9, i64 632, !9, i64 2056, !166, i64 3480, !15, i64 3560, !8, i64 3640, !8, i64 3648, !6, i64 3656, !6, i64 3660, !6, i64 3664}
!166 = !{!"execute_work", !15, i64 0}
!167 = !{!168, !5, i64 272}
!168 = !{!"sbp2_command_orb", !70, i64 0, !169, i64 312, !8, i64 352, !6, i64 360, !30, i64 1384}
!169 = !{!"", !74, i64 0, !74, i64 8, !5, i64 16, !6, i64 20}
!170 = !{!168, !8, i64 352}
!171 = !{!168, !5, i64 312}
!172 = !{!168, !5, i64 328}
!173 = !{!159, !6, i64 320}
!174 = !{i32 -2142508080}
!175 = !{!159, !8, i64 328}
!176 = !{!159, !44, i64 316}
!177 = !{!168, !8, i64 280}
!178 = !{!168, !30, i64 264}
!179 = !{!165, !8, i64 8}
!180 = !{!165, !6, i64 392}
!181 = !{!165, !6, i64 224}
!182 = !{!159, !5, i64 344}
!183 = !{!168, !5, i64 320}
!184 = !{!185, !30, i64 24}
!185 = !{!"scatterlist", !17, i64 0, !17, i64 8, !5, i64 16, !5, i64 20, !30, i64 24, !5, i64 32}
!186 = !{!168, !5, i64 324}
!187 = !{!185, !5, i64 32}
!188 = !{!168, !30, i64 1384}
!189 = !{!159, !8, i64 384}
!190 = !{!159, !5, i64 472}
!191 = !{!159, !8, i64 392}
!192 = !{!159, !8, i64 336}

; ModuleID = 'tests/regression/kernel_modules/firewire-sbp2/firewire-sbp2_old.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.52 }
%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.52 = type { i8* }
%struct.ieee1394_device_id = type { i32, i32, i32, i32, i32, i64 }
%struct.fw_driver = type { %struct.device_driver, void (%struct.fw_unit*)*, %struct.ieee1394_device_id* }
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.shrink_control*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %union.anon.52, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.arch_spinlock, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i32 }
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.mutex = type { %union.anon.1, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8*, i8*, %struct.lockdep_map }
%struct.task_struct = type { i64, i8*, %union.anon.1, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.hlist_head, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, i8, i32, i32, i32, i32, i32, i32, i8, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, %struct.load_weight, %struct.load_weight, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, i64, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %union.anon.46, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %union.anon.1, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i64, %struct.callback_head, %struct.callback_head, %struct.pipe_inode_info*, %struct.bio_vec, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, %struct.ftrace_ret_stack*, i64, %union.anon.1, %union.anon.1, i64, i64, %struct.memcg_batch_info, i32, %union.anon.1, %struct.uprobe_task*, i32, i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.cpumask = type { [64 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgprot*, %union.anon.1, %union.anon.1, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.task_struct*, %struct.file*, %struct.mmu_notifier_mm*, %struct.page*, %struct.cpumask, i64, i64, i64, i32, i32, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head, %struct.lockdep_map }
%struct.mm_rss_stat = type { [3 x %struct.pgprot] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %union.anon.1, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.file = type { %union.anon.46, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.pgprot, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i64 }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %union.anon.1, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.46, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %struct.pgprot, i8* }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %union.anon.1, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [44 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.pgprot, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type { i64, i64, i64, i64, i32, i8 }
%struct.kstatfs = type opaque
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %union.anon.1, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.1, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type { i64, i64, %union.anon.1, i64, i32, %struct.device, %struct.kobject*, i32, i32, %struct.partition_meta_info*, i32, i64, [2 x %union.anon.1], %struct.disk_stats*, %union.anon.1, %struct.callback_head }
%struct.partition_meta_info = type { [37 x i8], [64 x i8] }
%struct.disk_stats = type { [2 x i64], [2 x i64], [2 x i64], [2 x i64], i64, i64 }
%struct.gendisk = type { i32, i32, i32, [32 x i8], i8* (%struct.gendisk*, i16*)*, i32, i32, %struct.disk_part_tbl*, %struct.hd_struct, %struct.block_device_operations*, %struct.request_queue*, i8*, i32, %struct.device*, %struct.kobject*, %struct.timer_rand_state*, %union.anon.1, %struct.disk_events*, %struct.blk_integrity*, i32 }
%struct.disk_part_tbl = type { %struct.callback_head, i32, %struct.hd_struct*, [0 x %struct.hd_struct*] }
%struct.block_device_operations = type { i32 (%struct.block_device*, i32)*, void (%struct.gendisk*, i32)*, i32 (%struct.block_device*, i32, i32, i64)*, i32 (%struct.block_device*, i32, i32, i64)*, i32 (%struct.block_device*, i64, i8**, i64*)*, i32 (%struct.gendisk*, i32)*, i32 (%struct.gendisk*)*, void (%struct.gendisk*)*, i32 (%struct.gendisk*)*, i32 (%struct.block_device*, %struct.hd_geometry*)*, void (%struct.block_device*, i64)*, %struct.module* }
%struct.hd_geometry = type opaque
%struct.timer_rand_state = type opaque
%struct.disk_events = type opaque
%struct.blk_integrity = type { void (%struct.blk_integrity_exchg*)*, i32 (%struct.blk_integrity_exchg*)*, void (i8*, i8*, i32)*, void (i8*, i8*, i32)*, i16, i16, i16, i16, i8*, %struct.kobject }
%struct.blk_integrity_exchg = type { i8*, i8*, i64, i32, i16, i8* }
%struct.request_queue = type { %struct.list_head, %struct.request*, %struct.elevator_queue*, [2 x i32], i32, %struct.request_list, void (%struct.request_queue*)*, void (%struct.request_queue*, %struct.bio*)*, i32 (%struct.request_queue*, %struct.request*)*, void (%struct.request_queue*, %struct.request*)*, i32 (%struct.request_queue*, %struct.bvec_merge_data*, %struct.bio_vec*)*, void (%struct.request*)*, i32 (%struct.request*)*, i32 (%struct.request*)*, i32 (%struct.request_queue*)*, i64, %struct.request*, %struct.delayed_work, %struct.backing_dev_info, i8*, i64, i32, i32, %struct.spinlock, %struct.spinlock*, %struct.kobject, %struct.device*, i32, i32, i64, i32, i32, i32, i32, i8*, i32, i32, %struct.blk_queue_tag*, %struct.list_head, i32, [2 x i32], i32, i32, %struct.timer_list, %struct.list_head, %struct.list_head, [1 x i64], %struct.blkcg_gq*, %struct.list_head, %struct.queue_limits, i32, i32, i32, %struct.blk_trace*, i32, i8, i64, [2 x %struct.list_head], %struct.list_head, %struct.request, %struct.mutex, i32, i32 (%struct.bsg_job*)*, i32, %struct.bsg_class_device, %struct.list_head, %struct.throtl_data*, %struct.callback_head }
%struct.elevator_queue = type { %struct.elevator_type*, i8*, %struct.kobject, %struct.mutex, i8, [64 x %struct.hlist_head] }
%struct.elevator_type = type { %struct.kmem_cache*, %struct.elevator_ops, i64, i64, %struct.elv_fs_entry*, [16 x i8], %struct.module*, [21 x i8], %struct.list_head }
%struct.kmem_cache = type { %struct.kmem_cache_cpu*, i64, i64, i32, i32, i32, i32, %struct.pgprot, %struct.pgprot, %struct.pgprot, i32, i32, void (i8*)*, i32, i32, i32, i8*, %struct.list_head, %struct.kobject, %struct.memcg_cache_params*, i32, i32, [1024 x %struct.kmem_cache_node*] }
%struct.kmem_cache_cpu = type { i8**, i64, %struct.page*, %struct.page*, [26 x i32] }
%struct.memcg_cache_params = type { i8, %union.anon.32 }
%union.anon.32 = type { %struct.anon.33 }
%struct.anon.33 = type { %struct.mem_cgroup*, %struct.list_head, %struct.kmem_cache*, i8, %union.anon.1, %struct.work_struct }
%struct.mem_cgroup = type opaque
%struct.work_struct = type { %struct.pgprot, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%struct.kmem_cache_node = type opaque
%struct.elevator_ops = type { i32 (%struct.request_queue*, %struct.request**, %struct.bio*)*, void (%struct.request_queue*, %struct.request*, i32)*, void (%struct.request_queue*, %struct.request*, %struct.request*)*, i32 (%struct.request_queue*, %struct.request*, %struct.bio*)*, void (%struct.request_queue*, %struct.request*, %struct.bio*)*, i32 (%struct.request_queue*, i32)*, void (%struct.request_queue*, %struct.request*)*, void (%struct.request_queue*, %struct.request*)*, void (%struct.request_queue*, %struct.request*)*, void (%struct.request_queue*, %struct.request*)*, %struct.request* (%struct.request_queue*, %struct.request*)*, %struct.request* (%struct.request_queue*, %struct.request*)*, void (%struct.io_cq*)*, void (%struct.io_cq*)*, i32 (%struct.request_queue*, %struct.request*, %struct.bio*, i32)*, void (%struct.request*)*, i32 (%struct.request_queue*, i32)*, i32 (%struct.request_queue*)*, void (%struct.elevator_queue*)* }
%struct.bio = type { i64, %struct.bio*, %struct.block_device*, i64, i64, i16, i16, i32, i32, i32, i32, void (%struct.bio*, i32)*, i8*, %struct.io_context*, %struct.cgroup_subsys_state*, %struct.bio_integrity_payload*, i32, %union.anon.1, %struct.bio_vec*, %struct.bio_set*, [0 x %struct.bio_vec] }
%struct.cgroup_subsys_state = type opaque
%struct.bio_integrity_payload = type { %struct.bio*, i64, i8*, void (%struct.bio*, i32)*, i32, i16, i16, i16, i8, %struct.work_struct, %struct.bio_vec*, [0 x %struct.bio_vec] }
%struct.bio_set = type { %struct.kmem_cache*, i32, %struct.mempool_s*, %struct.mempool_s*, %struct.mempool_s*, %struct.mempool_s*, %struct.spinlock, %struct.bio_list, %struct.work_struct, %struct.workqueue_struct* }
%struct.mempool_s = type { %struct.spinlock, i32, i32, i8**, i8*, i8* (i32, i8*)*, void (i8*, i8*)*, %struct.__wait_queue_head }
%struct.bio_list = type { %struct.bio*, %struct.bio* }
%struct.workqueue_struct = type opaque
%struct.io_cq = type { %struct.request_queue*, %struct.io_context*, %union.anon.46, %union.anon.47, i32 }
%union.anon.47 = type { %struct.hlist_node }
%struct.elv_fs_entry = type { %struct.attribute, i64 (%struct.elevator_queue*, i8*)*, i64 (%struct.elevator_queue*, i8*, i64)* }
%struct.request_list = type { %struct.request_queue*, %struct.blkcg_gq*, [2 x i32], [2 x i32], %struct.mempool_s*, [2 x %struct.__wait_queue_head], i32 }
%struct.bvec_merge_data = type { %struct.block_device*, i64, i32, i64 }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.backing_dev_info = type { %struct.list_head, i64, i64, i32, i32 (i8*, i32)*, i8*, i8*, [4 x %struct.percpu_counter], i64, i64, i64, i64, i64, i64, i64, %struct.fprop_local_percpu, i32, i32, i32, i32, %struct.bdi_writeback, %struct.spinlock, %struct.list_head, %struct.device*, %struct.timer_list, %struct.dentry*, %struct.dentry* }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.fprop_local_percpu = type { %struct.percpu_counter, i32, %struct.raw_spinlock }
%struct.bdi_writeback = type { %struct.backing_dev_info*, i32, i64, %struct.delayed_work, %struct.list_head, %struct.list_head, %struct.list_head, %struct.spinlock }
%struct.blk_queue_tag = type { %struct.request**, i64*, i32, i32, i32, %union.anon.1 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8], %struct.lockdep_map }
%struct.tvec_base = type opaque
%struct.blkcg_gq = type opaque
%struct.queue_limits = type { i64, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i8, i8, i8, i8 }
%struct.blk_trace = type opaque
%struct.request = type { %struct.list_head, %struct.call_single_data, %struct.request_queue*, i32, i32, i64, i32, i32, i64, %struct.bio*, %struct.bio*, %struct.hlist_node, %union.anon.48, %union.anon.49, %struct.gendisk*, %struct.hd_struct*, i64, %struct.request_list*, i64, i64, i16, i16, i16, i32, i8*, i8*, i32, i32, [16 x i8], i8*, i16, i32, i32, i32, i8*, i64, %struct.list_head, i32, i32, void (%struct.request*, i32)*, i8*, %struct.request* }
%struct.call_single_data = type { %struct.list_head, void (i8*)*, i8*, i16 }
%union.anon.48 = type { %struct.rb_node }
%union.anon.49 = type { %struct.anon.51 }
%struct.anon.51 = type { i32, %struct.list_head, void (%struct.request*, i32)* }
%struct.bsg_job = type opaque
%struct.bsg_class_device = type { %struct.device*, %struct.device*, i32, %struct.request_queue*, %struct.arch_spinlock, void (%struct.device*)* }
%struct.throtl_data = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head, [3 x %struct.lockdep_map] }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.pgprot }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.1, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.36, i64, %union.anon.1, %union.anon.1, %union.anon.1, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.38, i32, i32, %struct.hlist_head, %union.anon.1, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.load_weight*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.36 = type { %struct.callback_head }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.pid = type { %union.anon.1, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.read_descriptor_t = type { i64, i64, %union.anon.52, i32 }
%struct.swap_info_struct = type opaque
%union.anon.38 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.poll_table_struct = type opaque
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %struct.pgprot, i32, i32, i8*, %struct.lockdep_map }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.mmu_notifier_mm = type opaque
%struct.page = type { i64, %struct.address_space*, %struct.anon.3, %union.anon.46, %struct.pgprot, i64 }
%struct.anon.3 = type { %struct.pgprot, %struct.pgprot }
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type { %struct.__wait_queue_head, %union.anon.1, i64*, %struct.page*, i64 }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.load_weight = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %union.anon.1, %union.anon.1, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %union.anon.1, i32, %union.anon.48, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %struct.pgprot, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.46, %struct.pgprot }
%struct.key_type = type opaque
%struct.key_user = type opaque
%struct.user_struct = type { %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %struct.pgprot, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.pgprot }
%struct.user_namespace = type opaque
%struct.group_info = type { %union.anon.1, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.16 }
%union.anon.16 = type { %struct.exception_table_entry }
%struct.exception_table_entry = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.19, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.22 }
%union.anon.19 = type { %struct.load_weight }
%union.anon.22 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type { %union.anon.1, %union.anon.1, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %struct.pgprot, [2 x %struct.if_dqinfo], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, i64, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.load_weight], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %struct.pgprot, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %struct.pgprot }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %struct.pgprot, i64 ()*, %struct.pgprot, %struct.pgprot }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %struct.pgprot, i32, i32, i64, i64, i64, %struct.pgprot, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %union.anon.1, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.raw_spinlock = type { %struct.arch_spinlock, i32, i32, i8*, %struct.lockdep_map }
%union.anon.46 = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, i8* }
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32 }
%struct.blk_plug = type { i64, %struct.list_head, %struct.list_head }
%struct.reclaim_state = type opaque
%struct.io_context = type { %struct.pgprot, %union.anon.1, %union.anon.1, %struct.spinlock, i16, i32, i64, %struct.radix_tree_root, %struct.io_cq*, %struct.hlist_head, %struct.work_struct }
%struct.siginfo = type { i32, i32, i32, %union.anon.24 }
%union.anon.24 = type { %struct.anon.28, [80 x i8] }
%struct.anon.28 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.bio_vec = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.load_weight, %struct.load_weight, i64, i64, i32, i32, %struct.load_weight, %struct.load_weight, i64, i32 }
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.memcg_batch_info = type { i32, %struct.mem_cgroup*, i64, i64 }
%struct.uprobe_task = type { i32, %struct.arch_uprobe_task, %struct.return_instance*, i32, %struct.uprobe*, i64, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.return_instance = type opaque
%struct.uprobe = type opaque
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class = type { %struct.list_head, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.lockdep_subclass_key = type { i8 }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.dev_pm_info = type { %union.anon.1, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %union.anon.1, %union.anon.1, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, i64, i64, i64, i64, i64, i8 }
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.shrink_control = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i8*, i64, %struct.sigset_t*)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, %struct.sigset_t*)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, %struct.sigset_t*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32, %struct.sigset_t*)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_node = type opaque
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.arch_spinlock }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.iommu_group = type opaque
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, i8, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.load_weight*, void ()**, i32 }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.arch_spinlock, void ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.driver_private = type opaque
%struct.fw_unit = type { %struct.device, i32*, %struct.fw_attribute_group }
%struct.fw_attribute_group = type { [2 x %struct.attribute_group*], %struct.attribute_group, [13 x %struct.attribute*] }
%struct.scsi_host_template = type { %struct.module*, i8*, i32 (%struct.scsi_host_template*)*, i32 (%struct.Scsi_Host*)*, i8* (%struct.Scsi_Host*)*, i32 (%struct.scsi_device*, i32, i8*)*, i32 (%struct.scsi_device*, i32, i8*)*, i32 (%struct.Scsi_Host*, %struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*, void (%struct.scsi_cmnd*)*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.scsi_device*)*, i32 (%struct.scsi_device*)*, void (%struct.scsi_device*)*, i32 (%struct.scsi_target*)*, void (%struct.scsi_target*)*, i32 (%struct.Scsi_Host*, i64)*, void (%struct.Scsi_Host*)*, i32 (%struct.scsi_device*, i32, i32)*, i32 (%struct.scsi_device*, i32)*, i32 (%struct.scsi_device*, %struct.block_device*, i64, i32*)*, void (%struct.scsi_device*)*, i32 (%struct.seq_file*, %struct.Scsi_Host*)*, i32 (%struct.Scsi_Host*, i8*, i32)*, i32 (%struct.scsi_cmnd*)*, i32 (%struct.Scsi_Host*, i32)*, i8*, %struct.proc_dir_entry*, i32, i32, i16, i16, i16, i64, i16, i8, i8, i32, %struct.device_attribute**, %struct.device_attribute**, %struct.list_head, i64 }
%struct.Scsi_Host = type { %struct.list_head, %struct.list_head, %struct.scsi_host_cmd_pool*, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.spinlock, %struct.spinlock*, %struct.mutex, %struct.list_head, %struct.task_struct*, %struct.completion*, %struct.__wait_queue_head, %struct.scsi_host_template*, %struct.scsi_transport_template*, %struct.blk_queue_tag*, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32, i16, i32, i32, i16, i16, i16, i16, i64, i64, i16, [20 x i8], %struct.workqueue_struct*, i32, i32, i32, i8, %struct.request_queue*, i64, i64, i8, i8, i32, i32, %struct.device, %struct.device, %struct.list_head, i8*, %struct.device*, [0 x i64] }
%struct.scsi_host_cmd_pool = type opaque
%struct.scsi_transport_template = type opaque
%struct.scsi_device = type <{ %struct.Scsi_Host*, %struct.request_queue*, %struct.list_head, %struct.list_head, i32, [4 x i8], %struct.spinlock, %struct.list_head, %struct.list_head, %struct.scsi_cmnd*, i16, i16, i16, i16, i64, i64, i64, i32, i32, i32, i32, i32, [4 x i8], i8*, i8, i8, i8, i8, [4 x i8], i8*, i8*, i8*, i8*, i8, [7 x i8], %struct.scsi_target*, i32, i48, %union.anon.1, [1 x i64], %struct.list_head, %struct.work_struct, i32, i32, %union.anon.1, %union.anon.1, %union.anon.1, [4 x i8], %struct.device, %struct.device, %struct.execute_work, %struct.work_struct, %struct.scsi_dh_data*, i32, [4 x i8], [0 x i64] }>
%struct.scsi_cmnd = type { %struct.scsi_device*, %struct.list_head, %struct.list_head, i32, i64, i64, i32, i32, i8, i8, i16, i32, i8*, %struct.scsi_data_buffer, %struct.scsi_data_buffer*, i32, i32, %struct.request*, i8*, void (%struct.scsi_cmnd*)*, %struct.scsi_pointer, i8*, i32, i8 }
%struct.scsi_data_buffer = type { %struct.sg_table, i32, i32 }
%struct.scsi_pointer = type { i8*, i32, %struct.scatterlist*, i32, i64, i32, i32, i32, i32, i32 }
%struct.scsi_target = type { %struct.scsi_device*, %struct.list_head, %struct.list_head, %struct.device, i32, i32, i32, i8, i32, i32, i32, i32, i8, %struct.execute_work, i32, i8*, [0 x i64] }
%struct.execute_work = type { %struct.work_struct }
%struct.scsi_dh_data = type { %struct.scsi_device_handler*, %struct.scsi_device*, %struct.arch_spinlock, [0 x i8] }
%struct.scsi_device_handler = type { %struct.list_head, %struct.module*, i8*, %struct.tracepoint_func*, i32 (%struct.scsi_device*, %struct.scsi_sense_hdr*)*, i32 (%struct.scsi_device*)*, void (%struct.scsi_device*)*, i32 (%struct.scsi_device*, void (i8*, i32)*, i8*)*, i32 (%struct.scsi_device*, %struct.request*)*, i32 (%struct.scsi_device*, i8*)*, i1 (%struct.scsi_device*)* }
%struct.scsi_sense_hdr = type opaque
%struct.proc_dir_entry = type opaque
%struct.anon.55 = type { i32, i32, i32 }
%struct.fw_device = type { %union.anon.1, %struct.fw_node*, i32, i32, i32, %struct.fw_card*, %struct.device, %struct.mutex, %struct.list_head, i32*, i64, i32, i16, %struct.delayed_work, %struct.fw_attribute_group }
%struct.fw_node = type opaque
%struct.fw_card = type { %struct.fw_card_driver*, %struct.device*, %struct.arch_spinlock, %struct.completion, i32, i32, i32, i64, %struct.list_head, i64, i32, i32, i32, i32, i64, i32, i32, i32, %struct.spinlock, %struct.fw_node*, %struct.fw_node*, %struct.fw_node*, i8, i32, i8, i32, %struct.list_head, %struct.list_head, %struct.delayed_work, i8, %struct.delayed_work, i32, i32, i32, i8, i8, i8, i8, i32, [256 x i32], i32 }
%struct.fw_card_driver = type opaque
%struct.sbp2_target = type { %struct.fw_unit*, %struct.list_head, i64, i64, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.sbp2_logical_unit = type { %struct.sbp2_target*, %struct.list_head, %struct.fw_address_handler, %struct.list_head, i64, i16, i32, i32, i32, %struct.delayed_work, i8, i8 }
%struct.fw_address_handler = type { i64, i64, void (%struct.fw_card*, %struct.fw_request*, i32, i32, i32, i32, i64, i8*, i64, i8*)*, i8*, %struct.list_head }
%struct.fw_request = type opaque
%struct.scsi_lun = type { [8 x i8] }
%struct.sbp2_management_orb = type { %struct.sbp2_orb, %struct.anon.54, [4 x i32], i64, %struct.completion, %struct.sbp2_status }
%struct.sbp2_orb = type { %struct.fw_transaction, %struct.arch_spinlock, i64, i32, void (%struct.sbp2_orb*, %struct.sbp2_status*)*, %struct.list_head }
%struct.fw_transaction = type { i32, i32, %struct.list_head, %struct.fw_card*, i8, %struct.timer_list, %struct.fw_packet, void (%struct.fw_card*, i32, i8*, i64, i8*)*, i8* }
%struct.fw_packet = type { i32, i32, [4 x i32], i64, i8*, i64, i64, i8, i32, void (%struct.fw_packet*, %struct.fw_card*, i32)*, i32, %struct.list_head, i8* }
%struct.anon.54 = type { %struct.exception_table_entry, %struct.exception_table_entry, i32, i32, %struct.exception_table_entry }
%struct.sbp2_status = type { i32, i32, [24 x i8] }
%struct.fw_csr_iterator = type { i32*, i32* }
%struct.sbp2_login_response = type { i32, %struct.exception_table_entry, i32 }
%struct.sbp2_command_orb = type { %struct.sbp2_orb, %struct.anon.53, %struct.scsi_cmnd*, %struct.sbp2_logical_unit*, [128 x %struct.exception_table_entry], i64 }
%struct.anon.53 = type { %struct.exception_table_entry, %struct.exception_table_entry, i32, [16 x i8] }

@llvm.used = appending global [10 x i8*] [i8* bitcast (%struct.kernel_param* @__param_exclusive_login to i8*), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__UNIQUE_ID_exclusive_logintype69, i32 0, i32 0), i8* getelementptr inbounds ([99 x i8], [99 x i8]* @__UNIQUE_ID_exclusive_login71, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_workarounds to i8*), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__UNIQUE_ID_workaroundstype115, i32 0, i32 0), i8* getelementptr inbounds ([272 x i8], [272 x i8]* @__UNIQUE_ID_workarounds125, i32 0, i32 0), i8* getelementptr inbounds ([46 x i8], [46 x i8]* @__UNIQUE_ID_author1631, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__UNIQUE_ID_description1632, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license1633, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__UNIQUE_ID_alias1637, i32 0, i32 0)], section "llvm.metadata"
@__param_exclusive_login = internal constant %struct.kernel_param { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__param_str_exclusive_login, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 420, i16 -1, %union.anon.52 { i8* @sbp2_param_exclusive_login } }, section "__param", align 8
@__UNIQUE_ID_exclusive_logintype69 = internal constant [30 x i8] c"parmtype=exclusive_login:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_exclusive_login71 = internal constant [99 x i8] c"parm=exclusive_login:Exclusive login to sbp2 device (default = Y, use N for concurrent initiators)\00", section ".modinfo", align 1
@__param_workarounds = internal constant %struct.kernel_param { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__param_str_workarounds, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 420, i16 -1, %union.anon.52 { i8* bitcast (i32* @sbp2_param_workarounds to i8*) } }, section "__param", align 8
@__UNIQUE_ID_workaroundstype115 = internal constant [25 x i8] c"parmtype=workarounds:int\00", section ".modinfo", align 1
@__UNIQUE_ID_workarounds125 = internal constant [272 x i8] c"parm=workarounds:Work around device bugs (default = 0, 128kB max transfer = 0x1, 36 byte inquiry = 0x2, skip mode page 8 = 0x4, fix capacity = 0x8, delay inquiry = 0x10, set power condition in start stop unit = 0x20, override internal blacklist = 0x100, or a combination)\00", section ".modinfo", align 1
@__UNIQUE_ID_author1631 = internal constant [46 x i8] c"author=Kristian Hoegsberg <krh@bitplanet.net>\00", section ".modinfo", align 1
@__UNIQUE_ID_description1632 = internal constant [31 x i8] c"description=SCSI over IEEE1394\00", section ".modinfo", align 1
@__UNIQUE_ID_license1633 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__UNIQUE_ID_alias1637 = internal constant [11 x i8] c"alias=sbp2\00", section ".modinfo", align 1
@__param_str_workarounds = internal constant [12 x i8] c"workarounds\00", align 1
@param_ops_int = external global %struct.kernel_param_ops, align 8
@sbp2_param_workarounds = internal global i32 0, align 4
@__param_str_exclusive_login = internal constant [16 x i8] c"exclusive_login\00", align 16
@param_ops_bool = external global %struct.kernel_param_ops, align 8
@sbp2_param_exclusive_login = internal global i8 1, align 1
@sbp2_id_table = internal constant [2 x %struct.ieee1394_device_id] [%struct.ieee1394_device_id { i32 12, i32 0, i32 0, i32 24734, i32 66691, i64 0 }, %struct.ieee1394_device_id zeroinitializer], align 16
@sbp2_driver = internal global %struct.fw_driver { %struct.device_driver { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str, i32 0, i32 0), %struct.bus_type* @fw_bus_type, %struct.module* @__this_module, i8* null, i8 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* @sbp2_probe, i32 (%struct.device*)* @sbp2_remove, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* null, %struct.driver_private* null }, void (%struct.fw_unit*)* @sbp2_update, %struct.ieee1394_device_id* getelementptr inbounds ([2 x %struct.ieee1394_device_id], [2 x %struct.ieee1394_device_id]* @sbp2_id_table, i32 0, i32 0) }, align 8
@.str = private unnamed_addr constant [14 x i8] c"firewire_sbp2\00", align 1
@fw_bus_type = external global %struct.bus_type, align 8
@__this_module = external global %struct.module, align 8
@fw_workqueue = external global %struct.workqueue_struct*, align 8
@.str.27 = private unnamed_addr constant [24 x i8] c"released target %d:0:0\0A\00", align 1
@.str.18 = private unnamed_addr constant [35 x i8] c"ORB reply timed out, rcode 0x%02x\0A\00", align 1
@.str.19 = private unnamed_addr constant [39 x i8] c"management write failed, rcode 0x%02x\0A\00", align 1
@.str.20 = private unnamed_addr constant [21 x i8] c"error status: %d:%d\0A\00", align 1
@.str.7 = private unnamed_addr constant [21 x i8] c"include/linux/kref.h\00", align 1
@.str.6 = private unnamed_addr constant [41 x i8] c"include/asm-generic/dma-mapping-common.h\00", align 1
@dma_ops = external global %struct.dma_map_ops*, align 8
@kref_get.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.21 = private unnamed_addr constant [9 x i8] c"&x->wait\00", align 1
@init_completion.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.2 = private unnamed_addr constant [24 x i8] c"drivers/firewire/sbp2.c\00", align 1
@scsi_driver_template = internal global %struct.scsi_host_template { %struct.module* @__this_module, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.3, i32 0, i32 0), i32 (%struct.scsi_host_template*)* null, i32 (%struct.Scsi_Host*)* null, i8* (%struct.Scsi_Host*)* null, i32 (%struct.scsi_device*, i32, i8*)* null, i32 (%struct.scsi_device*, i32, i8*)* null, i32 (%struct.Scsi_Host*, %struct.scsi_cmnd*)* @sbp2_scsi_queuecommand, i32 (%struct.scsi_cmnd*, void (%struct.scsi_cmnd*)*)* null, i32 (%struct.scsi_cmnd*)* @sbp2_scsi_abort, i32 (%struct.scsi_cmnd*)* null, i32 (%struct.scsi_cmnd*)* null, i32 (%struct.scsi_cmnd*)* null, i32 (%struct.scsi_cmnd*)* null, i32 (%struct.scsi_device*)* @sbp2_scsi_slave_alloc, i32 (%struct.scsi_device*)* @sbp2_scsi_slave_configure, void (%struct.scsi_device*)* null, i32 (%struct.scsi_target*)* null, void (%struct.scsi_target*)* null, i32 (%struct.Scsi_Host*, i64)* null, void (%struct.Scsi_Host*)* null, i32 (%struct.scsi_device*, i32, i32)* null, i32 (%struct.scsi_device*, i32)* null, i32 (%struct.scsi_device*, %struct.block_device*, i64, i32*)* null, void (%struct.scsi_device*)* null, i32 (%struct.seq_file*, %struct.Scsi_Host*)* null, i32 (%struct.Scsi_Host*, i8*, i32)* null, i32 (%struct.scsi_cmnd*)* null, i32 (%struct.Scsi_Host*, i32)* null, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), %struct.proc_dir_entry* null, i32 1, i32 -1, i16 128, i16 0, i16 0, i64 0, i16 1, i8 0, i8 8, i32 0, %struct.device_attribute** null, %struct.device_attribute** getelementptr inbounds ([2 x %struct.device_attribute*], [2 x %struct.device_attribute*]* @sbp2_scsi_sysfs_attrs, i32 0, i32 0), %struct.list_head zeroinitializer, i64 0 }, align 8
@.str.25 = private unnamed_addr constant [82 x i8] c"Please notify linux1394-devel@lists.sf.net if you need the workarounds parameter\0A\00", align 1
@sbp2_workarounds_table = internal constant [11 x %struct.anon.55] [%struct.anon.55 { i32 10240, i32 4112, i32 38 }, %struct.anon.55 { i32 10240, i32 0, i32 32 }, %struct.anon.55 { i32 512, i32 -1, i32 2 }, %struct.anon.55 { i32 75776, i32 -1, i32 32 }, %struct.anon.55 { i32 10532864, i32 -1, i32 1 }, %struct.anon.55 { i32 9728, i32 -1, i32 1 }, %struct.anon.55 { i32 665344, i32 0, i32 9 }, %struct.anon.55 { i32 665344, i32 33, i32 8 }, %struct.anon.55 { i32 665344, i32 34, i32 8 }, %struct.anon.55 { i32 665344, i32 35, i32 8 }, %struct.anon.55 { i32 665344, i32 126, i32 8 }], align 16
@.str.26 = private unnamed_addr constant [62 x i8] c"workarounds 0x%x (firmware_revision 0x%06x, model_id 0x%06x)\0A\00", align 1
@.str.24 = private unnamed_addr constant [36 x i8] c"%ds mgt_ORB_timeout limited to 40s\0A\00", align 1
@fw_high_memory_region = external constant %struct.load_weight, align 8
@.str.11 = private unnamed_addr constant [21 x i8] c"(&(&lu->work)->work)\00", align 1
@sbp2_add_logical_unit.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.13 = private unnamed_addr constant [22 x i8] c"(&(&lu->work)->timer)\00", align 1
@sbp2_add_logical_unit.__key.12 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.16 = private unnamed_addr constant [29 x i8] c"failed to login to LUN %04x\0A\00", align 1
@.str.17 = private unnamed_addr constant [36 x i8] c"logged in to LUN %04x (%d retries)\0A\00", align 1
@.str.22 = private unnamed_addr constant [21 x i8] c"failed to reconnect\0A\00", align 1
@.str.23 = private unnamed_addr constant [38 x i8] c"reconnected to LUN %04x (%d retries)\0A\00", align 1
@.str.14 = private unnamed_addr constant [43 x i8] c"non-ORB related status write, not handled\0A\00", align 1
@.str.15 = private unnamed_addr constant [30 x i8] c"status write for unknown ORB\0A\00", align 1
@.str.3 = private unnamed_addr constant [16 x i8] c"SBP-2 IEEE-1394\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c"sbp2\00", align 1
@sbp2_scsi_sysfs_attrs = internal global [2 x %struct.device_attribute*] [%struct.device_attribute* @dev_attr_ieee1394_id, %struct.device_attribute* null], align 16
@dev_attr_ieee1394_id = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.9, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sbp2_sysfs_ieee1394_id_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.9 = private unnamed_addr constant [12 x i8] c"ieee1394_id\00", align 1
@.str.10 = private unnamed_addr constant [19 x i8] c"%016llx:%06x:%04x\0A\00", align 1
@.str.8 = private unnamed_addr constant [17 x i8] c"sbp2_scsi_abort\0A\00", align 1
@.str.5 = private unnamed_addr constant [37 x i8] c"cannot handle bidirectional command\0A\00", align 1
@sbp2_agent_reset_no_wait.d = internal global i32 0, align 4

@__mod_ieee1394_device_table = alias %struct.ieee1394_device_id, getelementptr inbounds ([2 x %struct.ieee1394_device_id], [2 x %struct.ieee1394_device_id]* @sbp2_id_table, i32 0, i32 0)
@init_module = alias i32 (), i32 ()* @sbp2_init
@cleanup_module = alias void (), void ()* @sbp2_cleanup

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_init() #0 section ".init.text" {
entry:
  %call = call i32 @driver_register(%struct.device_driver* getelementptr inbounds (%struct.fw_driver, %struct.fw_driver* @sbp2_driver, i32 0, i32 0))
  ret i32 %call
}

declare i32 @driver_register(%struct.device_driver*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_probe(%struct.device* %dev) #2 {
entry:
  %model = alloca i32, align 4
  %firmware_revision = alloca i32, align 4
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %_min3 = alloca i32, align 4
  %call = call %struct.fw_unit* @fw_unit(%struct.device* %dev)
  %call1 = call %struct.fw_device* @fw_parent_device(%struct.fw_unit* %call)
  %0 = bitcast i32* %model to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = bitcast i32* %firmware_revision to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  %is_local = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call1, i32 0, i32 12
  %bf.load = load i16, i16* %is_local, align 4
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call1, i32 0, i32 5
  %2 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %device2 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %2, i32 0, i32 1
  %3 = load %struct.device*, %struct.device** %device2, align 8, !tbaa !32
  %call3 = call i32 @dma_get_max_seg_size(%struct.device* %3)
  %cmp = icmp ugt i32 %call3, 65532
  br i1 %cmp, label %if.then4, label %if.end25

if.then4:                                         ; preds = %if.end
  %card5 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call1, i32 0, i32 5
  %4 = load %struct.fw_card*, %struct.fw_card** %card5, align 8, !tbaa !2
  %device6 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %4, i32 0, i32 1
  %5 = load %struct.device*, %struct.device** %device6, align 8, !tbaa !32
  %call7 = call i32 @dma_set_max_seg_size(%struct.device* %5, i32 65532)
  %tobool8 = icmp ne i32 %call7, 0
  %lnot = xor i1 %tobool8, true
  %lnot9 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot9 to i32
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv = sext i32 %lnot.ext14 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool15 = icmp ne i64 %expval, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.then4
  call void @warn_slowpath_null(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.2, i32 0, i32 0), i32 1148)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.then4
  %tobool18 = icmp ne i32 %lnot.ext, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  br label %if.end25

if.end25:                                         ; preds = %if.end17, %if.end
  %call26 = call %struct.Scsi_Host* @scsi_host_alloc(%struct.scsi_host_template* @scsi_driver_template, i32 72)
  %cmp27 = icmp eq %struct.Scsi_Host* %call26, null
  br i1 %cmp27, label %cleanup, label %if.end30

if.end30:                                         ; preds = %if.end25
  %hostdata = getelementptr inbounds %struct.Scsi_Host, %struct.Scsi_Host* %call26, i32 0, i32 54
  %arraydecay = getelementptr inbounds [0 x i64], [0 x i64]* %hostdata, i32 0, i32 0
  %6 = bitcast i64* %arraydecay to %struct.sbp2_target*
  %device31 = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %call, i32 0, i32 0
  %7 = bitcast %struct.sbp2_target* %6 to i8*
  %call32 = call i32 @dev_set_drvdata(%struct.device* %device31, i8* %7)
  %unit33 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 0
  store %struct.fw_unit* %call, %struct.fw_unit** %unit33, align 8, !tbaa !34
  %lu_list = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %lu_list)
  %config_rom = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call1, i32 0, i32 9
  %8 = load i32*, i32** %config_rom, align 8, !tbaa !36
  %arrayidx = getelementptr inbounds i32, i32* %8, i64 3
  %9 = load i32, i32* %arrayidx, align 4, !tbaa !37
  %conv34 = zext i32 %9 to i64
  %shl = shl i64 %conv34, 32
  %config_rom35 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call1, i32 0, i32 9
  %10 = load i32*, i32** %config_rom35, align 8, !tbaa !36
  %arrayidx36 = getelementptr inbounds i32, i32* %10, i64 4
  %11 = load i32, i32* %arrayidx36, align 4, !tbaa !37
  %conv37 = zext i32 %11 to i64
  %or = or i64 %shl, %conv37
  %guid = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 3
  store i64 %or, i64* %guid, align 8, !tbaa !38
  %call38 = call i32 @fw_device_enable_phys_dma(%struct.fw_device* %call1)
  %cmp39 = icmp slt i32 %call38, 0
  br i1 %cmp39, label %fail_shost_put, label %if.end42

if.end42:                                         ; preds = %if.end30
  %max_cmd_len = getelementptr inbounds %struct.Scsi_Host, %struct.Scsi_Host* %call26, i32 0, i32 26
  store i16 16, i16* %max_cmd_len, align 8, !tbaa !39
  %device43 = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %call, i32 0, i32 0
  %card44 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call1, i32 0, i32 5
  %12 = load %struct.fw_card*, %struct.fw_card** %card44, align 8, !tbaa !2
  %device45 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %12, i32 0, i32 1
  %13 = load %struct.device*, %struct.device** %device45, align 8, !tbaa !32
  %call46 = call i32 @scsi_add_host_with_dma(%struct.Scsi_Host* %call26, %struct.device* %device43, %struct.device* %13)
  %cmp47 = icmp slt i32 %call46, 0
  br i1 %cmp47, label %fail_shost_put, label %if.end50

if.end50:                                         ; preds = %if.end42
  %directory = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %call, i32 0, i32 1
  %14 = load i32*, i32** %directory, align 8, !tbaa !42
  %config_rom51 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call1, i32 0, i32 9
  %15 = load i32*, i32** %config_rom51, align 8, !tbaa !36
  %sub.ptr.lhs.cast = ptrtoint i32* %14 to i64
  %sub.ptr.rhs.cast = ptrtoint i32* %15 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %mul = mul nsw i64 %sub.ptr.div, 4
  %add = add nsw i64 %mul, 1024
  %and = and i64 %add, 16777215
  %conv52 = trunc i64 %and to i32
  %directory_id = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 4
  store i32 %conv52, i32* %directory_id, align 8, !tbaa !44
  store i32 -16777216, i32* %firmware_revision, align 4, !tbaa !37
  store i32 -16777216, i32* %model, align 4, !tbaa !37
  %directory53 = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %call, i32 0, i32 1
  %16 = load i32*, i32** %directory53, align 8, !tbaa !42
  %call54 = call i32 @sbp2_scan_unit_dir(%struct.sbp2_target* %6, i32* %16, i32* %model, i32* %firmware_revision)
  %cmp55 = icmp slt i32 %call54, 0
  br i1 %cmp55, label %fail_remove, label %if.end58

if.end58:                                         ; preds = %if.end50
  call void @sbp2_clamp_management_orb_timeout(%struct.sbp2_target* %6)
  %17 = load i32, i32* %model, align 4, !tbaa !37
  %18 = load i32, i32* %firmware_revision, align 4, !tbaa !37
  call void @sbp2_init_workarounds(%struct.sbp2_target* %6, i32 %17, i32 %18)
  %19 = bitcast i32* %_min1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %19) #8
  %max_speed = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call1, i32 0, i32 4
  %20 = load i32, i32* %max_speed, align 8, !tbaa !45
  %add59 = add i32 %20, 7
  store i32 %add59, i32* %_min1, align 4, !tbaa !37
  %21 = bitcast i32* %_min2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %21) #8
  store i32 10, i32* %_min2, align 4, !tbaa !37
  %22 = bitcast i32* %_min3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %22) #8
  %card60 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call1, i32 0, i32 5
  %23 = load %struct.fw_card*, %struct.fw_card** %card60, align 8, !tbaa !2
  %max_receive = getelementptr inbounds %struct.fw_card, %struct.fw_card* %23, i32 0, i32 15
  %24 = load i32, i32* %max_receive, align 8, !tbaa !46
  %sub = sub i32 %24, 1
  store i32 %sub, i32* %_min3, align 4, !tbaa !37
  %cmp61 = icmp eq i32* %_min1, %_min2
  %conv62 = zext i1 %cmp61 to i32
  %cmp63 = icmp eq i32* %_min1, %_min3
  %conv64 = zext i1 %cmp63 to i32
  %25 = load i32, i32* %_min1, align 4, !tbaa !37
  %26 = load i32, i32* %_min2, align 4, !tbaa !37
  %cmp66 = icmp ult i32 %25, %26
  br i1 %cmp66, label %cond.true, label %cond.false71

cond.true:                                        ; preds = %if.end58
  %27 = load i32, i32* %_min1, align 4, !tbaa !37
  %28 = load i32, i32* %_min3, align 4, !tbaa !37
  %cmp68 = icmp ult i32 %27, %28
  %29 = load i32, i32* %_min1, align 4
  %30 = load i32, i32* %_min3, align 4
  %cond = select i1 %cmp68, i32 %29, i32 %30
  br label %cond.end78

cond.false71:                                     ; preds = %if.end58
  %31 = load i32, i32* %_min2, align 4, !tbaa !37
  %32 = load i32, i32* %_min3, align 4, !tbaa !37
  %cmp72 = icmp ult i32 %31, %32
  %33 = load i32, i32* %_min2, align 4
  %34 = load i32, i32* %_min3, align 4
  %cond77 = select i1 %cmp72, i32 %33, i32 %34
  br label %cond.end78

cond.end78:                                       ; preds = %cond.false71, %cond.true
  %cond79 = phi i32 [ %cond, %cond.true ], [ %cond77, %cond.false71 ]
  %35 = bitcast i32* %_min3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %35) #8
  %36 = bitcast i32* %_min2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %36) #8
  %37 = bitcast i32* %_min1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %37) #8
  %max_payload = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 9
  store i32 %cond79, i32* %max_payload, align 4, !tbaa !47
  %lu_list80 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 1
  br label %for.cond

for.cond:                                         ; preds = %for.body, %cond.end78
  %link86.sink = phi %struct.list_head* [ %link86, %for.body ], [ %lu_list80, %cond.end78 ]
  %next87 = getelementptr inbounds %struct.list_head, %struct.list_head* %link86.sink, i32 0, i32 0
  %38 = load %struct.list_head*, %struct.list_head** %next87, align 8, !tbaa !48
  %39 = bitcast %struct.list_head* %38 to i8*
  %add.ptr89 = getelementptr inbounds i8, i8* %39, i64 -8
  %40 = bitcast i8* %add.ptr89 to %struct.sbp2_logical_unit*
  %link = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %40, i32 0, i32 1
  %lu_list82 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 1
  %cmp83 = icmp ne %struct.list_head* %link, %lu_list82
  br i1 %cmp83, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  call void @sbp2_queue_work(%struct.sbp2_logical_unit* %40, i64 50)
  %link86 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %40, i32 0, i32 1
  br label %for.cond

fail_remove:                                      ; preds = %if.end50
  %call90 = call i32 @sbp2_remove(%struct.device* %dev)
  br label %cleanup

fail_shost_put:                                   ; preds = %if.end42, %if.end30
  call void @scsi_host_put(%struct.Scsi_Host* %call26)
  br label %cleanup

cleanup:                                          ; preds = %fail_shost_put, %fail_remove, %for.cond, %if.end25, %entry
  %retval.0 = phi i32 [ -12, %fail_shost_put ], [ -12, %fail_remove ], [ -19, %entry ], [ -12, %if.end25 ], [ 0, %for.cond ]
  %41 = bitcast i32* %firmware_revision to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %41) #8
  %42 = bitcast i32* %model to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %42) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_remove(%struct.device* %dev) #2 {
entry:
  %call = call %struct.fw_unit* @fw_unit(%struct.device* %dev)
  %call1 = call %struct.fw_device* @fw_parent_device(%struct.fw_unit* %call)
  %device2 = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %call, i32 0, i32 0
  %call3 = call i8* @dev_get_drvdata(%struct.device* %device2)
  %0 = bitcast i8* %call3 to %struct.sbp2_target*
  %1 = bitcast %struct.sbp2_target* %0 to i8*
  %2 = bitcast i8* %1 to i64*
  %3 = bitcast i64* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -3016
  %4 = bitcast i8* %add.ptr to %struct.Scsi_Host*
  call void @sbp2_unblock(%struct.sbp2_target* %0)
  %lu_list = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 1
  %next5 = getelementptr inbounds %struct.list_head, %struct.list_head* %lu_list, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next5, align 8, !tbaa !49
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr7 = getelementptr inbounds i8, i8* %6, i64 -8
  %7 = bitcast i8* %add.ptr7 to %struct.sbp2_logical_unit*
  br label %for.cond

for.cond:                                         ; preds = %if.end23, %entry
  %.sink = phi %struct.sbp2_logical_unit* [ %10, %if.end23 ], [ %7, %entry ]
  %lu.0 = phi %struct.sbp2_logical_unit* [ %7, %entry ], [ %10, %if.end23 ]
  %link26 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %.sink, i32 0, i32 1
  %next27 = getelementptr inbounds %struct.list_head, %struct.list_head* %link26, i32 0, i32 0
  %8 = load %struct.list_head*, %struct.list_head** %next27, align 8, !tbaa !50
  %9 = bitcast %struct.list_head* %8 to i8*
  %add.ptr29 = getelementptr inbounds i8, i8* %9, i64 -8
  %10 = bitcast i8* %add.ptr29 to %struct.sbp2_logical_unit*
  %link12 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu.0, i32 0, i32 1
  %lu_list13 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %link12, %lu_list13
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %work = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu.0, i32 0, i32 9
  %call14 = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %work)
  %lun = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu.0, i32 0, i32 5
  %11 = load i16, i16* %lun, align 8, !tbaa !53
  %call15 = call i32 @sbp2_lun2int(i16 zeroext %11)
  %call16 = call %struct.scsi_device* @scsi_device_lookup(%struct.Scsi_Host* %4, i32 0, i32 0, i32 %call15)
  %tobool = icmp ne %struct.scsi_device* %call16, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  call void @scsi_remove_device(%struct.scsi_device* %call16)
  call void @scsi_device_put(%struct.scsi_device* %call16)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %login_id = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu.0, i32 0, i32 6
  %12 = load i32, i32* %login_id, align 4, !tbaa !54
  %cmp17 = icmp ne i32 %12, 65536
  br i1 %cmp17, label %if.then18, label %if.end23

if.then18:                                        ; preds = %if.end
  %generation19 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call1, i32 0, i32 3
  %13 = load i32, i32* %generation19, align 4, !tbaa !55
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !56
  %node_id20 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call1, i32 0, i32 2
  %14 = load i32, i32* %node_id20, align 8, !tbaa !57
  %login_id21 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu.0, i32 0, i32 6
  %15 = load i32, i32* %login_id21, align 4, !tbaa !54
  %call22 = call i32 @sbp2_send_management_orb(%struct.sbp2_logical_unit* %lu.0, i32 %14, i32 %13, i32 7, i32 %15, i8* null)
  br label %if.end23

if.end23:                                         ; preds = %if.then18, %if.end
  %address_handler = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu.0, i32 0, i32 2
  call void @fw_core_remove_address_handler(%struct.fw_address_handler* %address_handler)
  %link24 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu.0, i32 0, i32 1
  call void @list_del(%struct.list_head* %link24)
  %16 = bitcast %struct.sbp2_logical_unit* %lu.0 to i8*
  call void @kfree(i8* %16)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @scsi_remove_host(%struct.Scsi_Host* %4)
  %host_no = getelementptr inbounds %struct.Scsi_Host, %struct.Scsi_Host* %4, i32 0, i32 19
  %17 = load i32, i32* %host_no, align 4, !tbaa !58
  %call30 = call i32 (%struct.device*, i8*, ...) @dev_notice(%struct.device* %dev, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.27, i32 0, i32 0), i32 %17)
  call void @scsi_host_put(%struct.Scsi_Host* %4)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_update(%struct.fw_unit* %unit) #2 {
entry:
  %device = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %unit, i32 0, i32 0
  %call = call i8* @dev_get_drvdata(%struct.device* %device)
  %0 = bitcast i8* %call to %struct.sbp2_target*
  %call1 = call %struct.fw_device* @fw_parent_device(%struct.fw_unit* %unit)
  %call2 = call i32 @fw_device_enable_phys_dma(%struct.fw_device* %call1)
  %lu_list = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 1
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %link5.sink = phi %struct.list_head* [ %link5, %for.body ], [ %lu_list, %entry ]
  %next6 = getelementptr inbounds %struct.list_head, %struct.list_head* %link5.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next6, align 8, !tbaa !48
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr8 = getelementptr inbounds i8, i8* %2, i64 -8
  %3 = bitcast i8* %add.ptr8 to %struct.sbp2_logical_unit*
  %link = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %3, i32 0, i32 1
  %lu_list3 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %link, %lu_list3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @sbp2_conditionally_block(%struct.sbp2_logical_unit* %3)
  %retries = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %3, i32 0, i32 8
  store i32 0, i32* %retries, align 4, !tbaa !59
  call void @sbp2_queue_work(%struct.sbp2_logical_unit* %3, i64 0)
  %link5 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %3, i32 0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare i8* @dev_get_drvdata(%struct.device*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.fw_device* @fw_parent_device(%struct.fw_unit* %unit) #3 {
entry:
  %device = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %unit, i32 0, i32 0
  %parent = getelementptr inbounds %struct.device, %struct.device* %device, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !60
  %call = call %struct.fw_device* @fw_device(%struct.device* %0)
  ret %struct.fw_device* %call
}

declare i32 @fw_device_enable_phys_dma(%struct.fw_device*) #1

; Function Attrs: nounwind uwtable
define internal void @sbp2_conditionally_block(%struct.sbp2_logical_unit* %lu) #2 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tgt1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt1, align 8, !tbaa !61
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %card2 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %1 = load %struct.fw_card*, %struct.fw_card** %card2, align 8, !tbaa !2
  %2 = bitcast %struct.sbp2_target* %0 to i8*
  %3 = bitcast i8* %2 to i64*
  %4 = bitcast i64* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 -3016
  %5 = bitcast i8* %add.ptr to %struct.Scsi_Host*
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #8
  %7 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %8 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #8
  %9 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #8
  %lock = getelementptr inbounds %struct.fw_card, %struct.fw_card* %1, i32 0, i32 18
  %call5 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call6 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call5)
  %dont_block = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 10
  %10 = load i32, i32* %dont_block, align 8, !tbaa !62
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.end19, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %blocked = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 11
  %11 = load i8, i8* %blocked, align 1, !tbaa !63, !range !64
  %tobool9 = trunc i8 %11 to i1
  br i1 %tobool9, label %if.end19, label %land.lhs.true10

land.lhs.true10:                                  ; preds = %land.lhs.true
  %generation = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 7
  %12 = load i32, i32* %generation, align 8, !tbaa !65
  %generation11 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %1, i32 0, i32 5
  %13 = load i32, i32* %generation11, align 4, !tbaa !66
  %cmp12 = icmp ne i32 %12, %13
  br i1 %cmp12, label %if.then, label %if.end19

if.then:                                          ; preds = %land.lhs.true10
  %blocked14 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 11
  store i8 1, i8* %blocked14, align 1, !tbaa !63
  %blocked15 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 11
  %14 = load i32, i32* %blocked15, align 4, !tbaa !67
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %blocked15, align 4, !tbaa !67
  %cmp16 = icmp eq i32 %inc, 1
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then
  call void @scsi_block_requests(%struct.Scsi_Host* %5)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.then, %land.lhs.true10, %land.lhs.true, %entry
  %lock20 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %1, i32 0, i32 18
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock20, i64 %call6)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_queue_work(%struct.sbp2_logical_unit* %lu, i64 %delay) #2 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @fw_workqueue, align 8, !tbaa !48
  %work = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 9
  call void @queue_delayed_work(%struct.workqueue_struct* %0, %struct.delayed_work* %work, i64 %delay)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_delayed_work(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #3 {
entry:
  %call = call zeroext i1 @queue_delayed_work_on(i32 4096, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret void
}

declare zeroext i1 @queue_delayed_work_on(i32, %struct.workqueue_struct*, %struct.delayed_work*, i64) #1

; Function Attrs: nounwind uwtable
define internal %struct.fw_device* @target_parent_device(%struct.sbp2_target* %tgt) #2 {
entry:
  %unit = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 0
  %0 = load %struct.fw_unit*, %struct.fw_unit** %unit, align 8, !tbaa !34
  %call = call %struct.fw_device* @fw_parent_device(%struct.fw_unit* %0)
  ret %struct.fw_device* %call
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #4

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare void @scsi_block_requests(%struct.Scsi_Host*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #3 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.fw_device* @fw_device(%struct.device* %dev) #3 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -40
  %1 = bitcast i8* %add.ptr to %struct.fw_device*
  ret %struct.fw_device* %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.fw_unit* @fw_unit(%struct.device* %dev) #3 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.fw_unit*
  ret %struct.fw_unit* %1
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_unblock(%struct.sbp2_target* %tgt) #2 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %tgt)
  %card1 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %0 = load %struct.fw_card*, %struct.fw_card** %card1, align 8, !tbaa !2
  %1 = bitcast %struct.sbp2_target* %tgt to i8*
  %2 = bitcast i8* %1 to i64*
  %3 = bitcast i64* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -3016
  %4 = bitcast i8* %add.ptr to %struct.Scsi_Host*
  %5 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #8
  %6 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %7 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #8
  %8 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #8
  %lock = getelementptr inbounds %struct.fw_card, %struct.fw_card* %0, i32 0, i32 18
  %call4 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call5 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call4)
  %dont_block = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 10
  %9 = load i32, i32* %dont_block, align 8, !tbaa !62
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %dont_block, align 8, !tbaa !62
  %lock8 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %0, i32 0, i32 18
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock8, i64 %call5)
  call void @scsi_unblock_requests(%struct.Scsi_Host* %4)
  ret void
}

declare zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_lun2int(i16 zeroext %lun) #2 {
entry:
  %eight_bytes_lun = alloca %struct.scsi_lun, align 1
  %0 = bitcast %struct.scsi_lun* %eight_bytes_lun to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast %struct.scsi_lun* %eight_bytes_lun to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 8, i32 1, i1 false)
  %conv = zext i16 %lun to i32
  %shr = ashr i32 %conv, 8
  %and = and i32 %shr, 255
  %conv1 = trunc i32 %and to i8
  %scsi_lun = getelementptr inbounds %struct.scsi_lun, %struct.scsi_lun* %eight_bytes_lun, i32 0, i32 0
  %arrayidx = getelementptr inbounds [8 x i8], [8 x i8]* %scsi_lun, i64 0, i64 0
  store i8 %conv1, i8* %arrayidx, align 1, !tbaa !68
  %conv2 = zext i16 %lun to i32
  %and3 = and i32 %conv2, 255
  %conv4 = trunc i32 %and3 to i8
  %scsi_lun5 = getelementptr inbounds %struct.scsi_lun, %struct.scsi_lun* %eight_bytes_lun, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [8 x i8], [8 x i8]* %scsi_lun5, i64 0, i64 1
  store i8 %conv4, i8* %arrayidx6, align 1, !tbaa !68
  %call = call i32 @scsilun_to_int(%struct.scsi_lun* %eight_bytes_lun)
  %2 = bitcast %struct.scsi_lun* %eight_bytes_lun to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  ret i32 %call
}

declare %struct.scsi_device* @scsi_device_lookup(%struct.Scsi_Host*, i32, i32, i32) #1

declare void @scsi_remove_device(%struct.scsi_device*) #1

declare void @scsi_device_put(%struct.scsi_device*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_send_management_orb(%struct.sbp2_logical_unit* %lu, i32 %node_id, i32 %generation, i32 %function, i32 %lun_or_login_id, i8* %response) #2 {
entry:
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !61
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %cmp = icmp eq i32 %function, 7
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call2 = call i32 @fw_device_is_shutdown(%struct.fw_device* %call)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %call3 = call i8* @kzalloc(i64 520, i32 16)
  %1 = bitcast i8* %call3 to %struct.sbp2_management_orb*
  %cmp4 = icmp eq %struct.sbp2_management_orb* %1, null
  br i1 %cmp4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %base = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %kref = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base, i32 0, i32 1
  call void @kref_init(%struct.arch_spinlock* %kref)
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %2 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %device7 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %2, i32 0, i32 1
  %3 = load %struct.device*, %struct.device** %device7, align 8, !tbaa !32
  %response8 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 2
  %4 = bitcast [4 x i32]* %response8 to i8*
  %call9 = call i64 @dma_map_single_attrs(%struct.device* %3, i8* %4, i64 16, i32 2, %struct.sigset_t* null)
  %response_bus = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 3
  store i64 %call9, i64* %response_bus, align 8, !tbaa !69
  %card10 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %5 = load %struct.fw_card*, %struct.fw_card** %card10, align 8, !tbaa !2
  %device11 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %5, i32 0, i32 1
  %6 = load %struct.device*, %struct.device** %device11, align 8, !tbaa !32
  %response_bus12 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 3
  %7 = load i64, i64* %response_bus12, align 8, !tbaa !69
  %call13 = call i32 @dma_mapping_error(%struct.device* %6, i64 %7)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %fail_mapping_response, label %if.end16

if.end16:                                         ; preds = %if.end6
  %request = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %response17 = getelementptr inbounds %struct.anon.54, %struct.anon.54* %request, i32 0, i32 1
  %high = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %response17, i32 0, i32 0
  store i32 0, i32* %high, align 8, !tbaa !77
  %response_bus18 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 3
  %8 = load i64, i64* %response_bus18, align 8, !tbaa !69
  %conv = trunc i64 %8 to i32
  %call19 = call i32 @__fswab32(i32 %conv) #6
  %request20 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %response21 = getelementptr inbounds %struct.anon.54, %struct.anon.54* %request20, i32 0, i32 1
  %low = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %response21, i32 0, i32 1
  store i32 %call19, i32* %low, align 4, !tbaa !78
  %shl = shl i32 %function, 16
  %or = or i32 -2147483648, %shl
  %or22 = or i32 %or, %lun_or_login_id
  %call23 = call i32 @__fswab32(i32 %or22) #6
  %request24 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %misc = getelementptr inbounds %struct.anon.54, %struct.anon.54* %request24, i32 0, i32 2
  store i32 %call23, i32* %misc, align 8, !tbaa !79
  %request25 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %length = getelementptr inbounds %struct.anon.54, %struct.anon.54* %request25, i32 0, i32 3
  store i32 268435456, i32* %length, align 4, !tbaa !80
  %address_handler = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 2
  %offset = getelementptr inbounds %struct.fw_address_handler, %struct.fw_address_handler* %address_handler, i32 0, i32 0
  %9 = load i64, i64* %offset, align 8, !tbaa !81
  %shr = lshr i64 %9, 32
  %conv26 = trunc i64 %shr to i32
  %call27 = call i32 @__fswab32(i32 %conv26) #6
  %request28 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %status_fifo = getelementptr inbounds %struct.anon.54, %struct.anon.54* %request28, i32 0, i32 4
  %high29 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %status_fifo, i32 0, i32 0
  store i32 %call27, i32* %high29, align 8, !tbaa !82
  %address_handler30 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 2
  %offset31 = getelementptr inbounds %struct.fw_address_handler, %struct.fw_address_handler* %address_handler30, i32 0, i32 0
  %10 = load i64, i64* %offset31, align 8, !tbaa !81
  %conv32 = trunc i64 %10 to i32
  %call33 = call i32 @__fswab32(i32 %conv32) #6
  %request34 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %status_fifo35 = getelementptr inbounds %struct.anon.54, %struct.anon.54* %request34, i32 0, i32 4
  %low36 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %status_fifo35, i32 0, i32 1
  store i32 %call33, i32* %low36, align 4, !tbaa !83
  %cmp37 = icmp eq i32 %function, 0
  br i1 %cmp37, label %if.then39, label %if.end48

if.then39:                                        ; preds = %if.end16
  %11 = load i8, i8* @sbp2_param_exclusive_login, align 1, !tbaa !84, !range !64
  %tobool40 = trunc i8 %11 to i1
  %12 = zext i1 %tobool40 to i64
  %cond = select i1 %tobool40, i32 268435456, i32 0
  %or42 = or i32 2097152, %cond
  %call43 = call i32 @__fswab32(i32 %or42) #6
  %request44 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %misc45 = getelementptr inbounds %struct.anon.54, %struct.anon.54* %request44, i32 0, i32 2
  %13 = load i32, i32* %misc45, align 8, !tbaa !79
  %or46 = or i32 %13, %call43
  store i32 %or46, i32* %misc45, align 8, !tbaa !79
  %tgt47 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %14 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt47, align 8, !tbaa !61
  %mgt_orb_timeout = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %14, i32 0, i32 8
  %15 = load i32, i32* %mgt_orb_timeout, align 8, !tbaa !85
  br label %if.end48

if.end48:                                         ; preds = %if.then39, %if.end16
  %timeout.0 = phi i32 [ %15, %if.then39 ], [ 2000, %if.end16 ]
  %done = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 4
  call void @init_completion(%struct.completion* %done)
  %base49 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %callback = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base49, i32 0, i32 4
  store void (%struct.sbp2_orb*, %struct.sbp2_status*)* @complete_management_orb, void (%struct.sbp2_orb*, %struct.sbp2_status*)** %callback, align 8, !tbaa !86
  %card50 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %16 = load %struct.fw_card*, %struct.fw_card** %card50, align 8, !tbaa !2
  %device51 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %16, i32 0, i32 1
  %17 = load %struct.device*, %struct.device** %device51, align 8, !tbaa !32
  %request52 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 1
  %18 = bitcast %struct.anon.54* %request52 to i8*
  %call53 = call i64 @dma_map_single_attrs(%struct.device* %17, i8* %18, i64 32, i32 1, %struct.sigset_t* null)
  %base54 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %request_bus = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base54, i32 0, i32 2
  store i64 %call53, i64* %request_bus, align 8, !tbaa !87
  %card55 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %19 = load %struct.fw_card*, %struct.fw_card** %card55, align 8, !tbaa !2
  %device56 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %19, i32 0, i32 1
  %20 = load %struct.device*, %struct.device** %device56, align 8, !tbaa !32
  %base57 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %request_bus58 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base57, i32 0, i32 2
  %21 = load i64, i64* %request_bus58, align 8, !tbaa !87
  %call59 = call i32 @dma_mapping_error(%struct.device* %20, i64 %21)
  %tobool60 = icmp ne i32 %call59, 0
  br i1 %tobool60, label %fail_mapping_request, label %if.end62

if.end62:                                         ; preds = %if.end48
  %base63 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %tgt64 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %22 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt64, align 8, !tbaa !61
  %management_agent_address = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %22, i32 0, i32 2
  %23 = load i64, i64* %management_agent_address, align 8, !tbaa !88
  call void @sbp2_send_orb(%struct.sbp2_orb* %base63, %struct.sbp2_logical_unit* %lu, i32 %node_id, i32 %generation, i64 %23)
  %done65 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 4
  %call66 = call i64 @msecs_to_jiffies(i32 %timeout.0)
  %call67 = call i64 @wait_for_completion_timeout(%struct.completion* %done65, i64 %call66)
  %call68 = call i32 @sbp2_cancel_orbs(%struct.sbp2_logical_unit* %lu)
  %cmp69 = icmp eq i32 %call68, 0
  br i1 %cmp69, label %if.then71, label %if.end75

if.then71:                                        ; preds = %if.end62
  %call72 = call %struct.device* @lu_dev(%struct.sbp2_logical_unit* %lu)
  %base73 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %rcode = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base73, i32 0, i32 3
  %24 = load i32, i32* %rcode, align 8, !tbaa !89
  %call74 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %call72, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.18, i32 0, i32 0), i32 %24)
  br label %out

if.end75:                                         ; preds = %if.end62
  %base76 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %rcode77 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base76, i32 0, i32 3
  %25 = load i32, i32* %rcode77, align 8, !tbaa !89
  %cmp78 = icmp ne i32 %25, 0
  br i1 %cmp78, label %if.then80, label %if.end85

if.then80:                                        ; preds = %if.end75
  %call81 = call %struct.device* @lu_dev(%struct.sbp2_logical_unit* %lu)
  %base82 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %rcode83 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base82, i32 0, i32 3
  %26 = load i32, i32* %rcode83, align 8, !tbaa !89
  %call84 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %call81, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.19, i32 0, i32 0), i32 %26)
  br label %out

if.end85:                                         ; preds = %if.end75
  %status = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 5
  %status86 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  %27 = load i32, i32* %status86, align 8, !tbaa !90
  %shr87 = lshr i32 %27, 28
  %and = and i32 %shr87, 3
  %cmp88 = icmp ne i32 %and, 0
  br i1 %cmp88, label %if.then96, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end85
  %status90 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 5
  %status91 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status90, i32 0, i32 0
  %28 = load i32, i32* %status91, align 8, !tbaa !90
  %shr92 = lshr i32 %28, 16
  %and93 = and i32 %shr92, 255
  %cmp94 = icmp ne i32 %and93, 0
  br i1 %cmp94, label %if.then96, label %out

if.then96:                                        ; preds = %lor.lhs.false, %if.end85
  %call97 = call %struct.device* @lu_dev(%struct.sbp2_logical_unit* %lu)
  %status98 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 5
  %status99 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status98, i32 0, i32 0
  %29 = load i32, i32* %status99, align 8, !tbaa !90
  %shr100 = lshr i32 %29, 28
  %and101 = and i32 %shr100, 3
  %status102 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 5
  %status103 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status102, i32 0, i32 0
  %30 = load i32, i32* %status103, align 8, !tbaa !90
  %shr104 = lshr i32 %30, 16
  %and105 = and i32 %shr104, 255
  %call106 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %call97, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.20, i32 0, i32 0), i32 %and101, i32 %and105)
  br label %out

out:                                              ; preds = %if.then96, %lor.lhs.false, %if.then80, %if.then71
  %retval1.0 = phi i32 [ -5, %if.then71 ], [ -5, %if.then80 ], [ -5, %if.then96 ], [ 0, %lor.lhs.false ]
  %card108 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %31 = load %struct.fw_card*, %struct.fw_card** %card108, align 8, !tbaa !2
  %device109 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %31, i32 0, i32 1
  %32 = load %struct.device*, %struct.device** %device109, align 8, !tbaa !32
  %base110 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %request_bus111 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base110, i32 0, i32 2
  %33 = load i64, i64* %request_bus111, align 8, !tbaa !87
  call void @dma_unmap_single_attrs(%struct.device* %32, i64 %33, i64 32, i32 1, %struct.sigset_t* null)
  br label %fail_mapping_request

fail_mapping_request:                             ; preds = %out, %if.end48
  %retval1.1 = phi i32 [ %retval1.0, %out ], [ -12, %if.end48 ]
  %card112 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %34 = load %struct.fw_card*, %struct.fw_card** %card112, align 8, !tbaa !2
  %device113 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %34, i32 0, i32 1
  %35 = load %struct.device*, %struct.device** %device113, align 8, !tbaa !32
  %response_bus114 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 3
  %36 = load i64, i64* %response_bus114, align 8, !tbaa !69
  call void @dma_unmap_single_attrs(%struct.device* %35, i64 %36, i64 16, i32 2, %struct.sigset_t* null)
  br label %fail_mapping_response

fail_mapping_response:                            ; preds = %fail_mapping_request, %if.end6
  %retval1.2 = phi i32 [ %retval1.1, %fail_mapping_request ], [ -12, %if.end6 ]
  %tobool115 = icmp ne i8* %response, null
  br i1 %tobool115, label %if.then116, label %if.end126

if.then116:                                       ; preds = %fail_mapping_response
  %cmp117 = icmp uge i64 16, 64
  %response120 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 2
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %response120, i32 0, i32 0
  %37 = bitcast i32* %arraydecay to i8*
  br i1 %cmp117, label %if.then119, label %if.else122

if.then119:                                       ; preds = %if.then116
  %call121 = call i8* @__memcpy(i8* %response, i8* %37, i64 16)
  br label %if.end126

if.else122:                                       ; preds = %if.then116
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %response, i8* %37, i64 16, i32 1, i1 false)
  br label %if.end126

if.end126:                                        ; preds = %if.else122, %if.then119, %fail_mapping_response
  %base127 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 0
  %kref128 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base127, i32 0, i32 1
  call void @kref_put(%struct.arch_spinlock* %kref128, void (%struct.arch_spinlock*)* @free_orb)
  br label %cleanup

cleanup:                                          ; preds = %if.end126, %if.end, %land.lhs.true
  %retval.0 = phi i32 [ %retval1.2, %if.end126 ], [ 0, %land.lhs.true ], [ -12, %if.end ]
  ret i32 %retval.0
}

declare void @fw_core_remove_address_handler(%struct.fw_address_handler*) #1

declare void @list_del(%struct.list_head*) #1

declare void @kfree(i8*) #1

declare void @scsi_remove_host(%struct.Scsi_Host*) #1

declare i32 @dev_notice(%struct.device*, i8*, ...) #1

declare void @scsi_host_put(%struct.Scsi_Host*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @fw_device_is_shutdown(%struct.fw_device* %device) #3 {
entry:
  %state = getelementptr inbounds %struct.fw_device, %struct.fw_device* %device, i32 0, i32 0
  %call = call i32 @atomic_read(%union.anon.1* %state)
  %cmp = icmp eq i32 %call, 3
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init(%struct.arch_spinlock* %kref) #3 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  call void @atomic_set(%union.anon.1* %refcount, i32 1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @dma_map_single_attrs(%struct.device* %dev, i8* %ptr, i64 %size, i32 %dir, %struct.sigset_t* %attrs) #3 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %conv = trunc i64 %size to i32
  call void @kmemcheck_mark_initialized()
  %call1 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %do.body6, label %do.end11

do.body6:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0), i32 19, i64 12) #8, !srcloc !91
  br label %do.body7

do.body7:                                         ; preds = %do.body7, %do.body6
  br label %do.body7

do.end11:                                         ; preds = %entry
  %map_page = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 4
  %0 = load i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.sigset_t*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.sigset_t*)** %map_page, align 8, !tbaa !92
  %1 = ptrtoint i8* %ptr to i64
  %call12 = call i64 @__phys_addr(i64 %1)
  %shr = lshr i64 %call12, 12
  %add.ptr = getelementptr inbounds %struct.page, %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr
  %2 = ptrtoint i8* %ptr to i64
  %and = and i64 %2, 4095
  %call13 = call i64 %0(%struct.device* %dev, %struct.page* %add.ptr, i64 %and, i64 %size, i32 %dir, %struct.sigset_t* %attrs)
  %3 = ptrtoint i8* %ptr to i64
  %call14 = call i64 @__phys_addr(i64 %3)
  %shr15 = lshr i64 %call14, 12
  %add.ptr16 = getelementptr inbounds %struct.page, %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr15
  %4 = ptrtoint i8* %ptr to i64
  %and17 = and i64 %4, 4095
  call void @debug_dma_map_page(%struct.device* %dev, %struct.page* %add.ptr16, i64 %and17, i64 %size, i32 %dir, i64 %call13, i1 zeroext true)
  ret i64 %call13
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @dma_mapping_error(%struct.device* %dev, i64 %dma_addr) #3 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  call void @debug_dma_mapping_error(%struct.device* %dev, i64 %dma_addr)
  %mapping_error = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 12
  %0 = load i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)** %mapping_error, align 8, !tbaa !94
  %tobool = icmp ne i32 (%struct.device*, i64)* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mapping_error1 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 12
  %1 = load i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)** %mapping_error1, align 8, !tbaa !94
  %call2 = call i32 %1(%struct.device* %dev, i64 %dma_addr)
  br label %cleanup

if.end:                                           ; preds = %entry
  %cmp = icmp eq i64 %dma_addr, 0
  %conv = zext i1 %cmp to i32
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call2, %if.then ], [ %conv, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32(i32 %val) #5 {
entry:
  %call = call i32 @__arch_swab32(i32 %val) #6
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @init_completion(%struct.completion* %x) #3 {
entry:
  %done = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 0
  store i32 0, i32* %done, align 8, !tbaa !95
  %wait = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 1
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wait, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.21, i32 0, i32 0), %struct.lock_class_key* @init_completion.__key)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @complete_management_orb(%struct.sbp2_orb* %base_orb, %struct.sbp2_status* %status) #2 {
entry:
  %0 = bitcast %struct.sbp2_orb* %base_orb to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sbp2_management_orb*
  %tobool = icmp ne %struct.sbp2_status* %status, null
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %cmp = icmp uge i64 32, 64
  %status2 = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 5
  %2 = bitcast %struct.sbp2_status* %status2 to i8*
  %3 = bitcast %struct.sbp2_status* %status to i8*
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.then
  %call = call i8* @__memcpy(i8* %2, i8* %3, i64 32)
  br label %if.end5

if.else:                                          ; preds = %if.then
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 32, i32 4, i1 false)
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then1, %entry
  %done = getelementptr inbounds %struct.sbp2_management_orb, %struct.sbp2_management_orb* %1, i32 0, i32 4
  call void @complete(%struct.completion* %done)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_send_orb(%struct.sbp2_orb* %orb, %struct.sbp2_logical_unit* %lu, i32 %node_id, i32 %generation, i64 %offset) #2 {
entry:
  %orb_pointer = alloca %struct.exception_table_entry, align 4
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !61
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %1 = bitcast %struct.exception_table_entry* %orb_pointer to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %high = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %orb_pointer, i32 0, i32 0
  store i32 0, i32* %high, align 4, !tbaa !96
  %request_bus = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb, i32 0, i32 2
  %2 = load i64, i64* %request_bus, align 8, !tbaa !97
  %conv = trunc i64 %2 to i32
  %call1 = call i32 @__fswab32(i32 %conv) #6
  %low = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %orb_pointer, i32 0, i32 1
  store i32 %call1, i32* %low, align 4, !tbaa !98
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #8
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv3 = zext i1 %cmp to i32
  %5 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #8
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #8
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %7 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %lock = getelementptr inbounds %struct.fw_card, %struct.fw_card* %7, i32 0, i32 18
  %call4 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call5 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call4)
  %link = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb, i32 0, i32 5
  %orb_list = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 3
  call void @list_add_tail(%struct.list_head* %link, %struct.list_head* %orb_list)
  %card8 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %8 = load %struct.fw_card*, %struct.fw_card** %card8, align 8, !tbaa !2
  %lock9 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %8, i32 0, i32 18
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock9, i64 %call5)
  %kref = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb, i32 0, i32 1
  call void @kref_get(%struct.arch_spinlock* %kref)
  %kref10 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb, i32 0, i32 1
  call void @kref_get(%struct.arch_spinlock* %kref10)
  %card11 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %9 = load %struct.fw_card*, %struct.fw_card** %card11, align 8, !tbaa !2
  %t = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb, i32 0, i32 0
  %max_speed = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 4
  %10 = load i32, i32* %max_speed, align 8, !tbaa !45
  %11 = bitcast %struct.exception_table_entry* %orb_pointer to i8*
  %12 = bitcast %struct.sbp2_orb* %orb to i8*
  call void @fw_send_request(%struct.fw_card* %9, %struct.fw_transaction* %t, i32 1, i32 %node_id, i32 %generation, i32 %10, i64 %offset, i8* %11, i64 8, void (%struct.fw_card*, i32, i8*, i64, i8*)* @complete_transaction, i8* %12)
  %13 = bitcast %struct.exception_table_entry* %orb_pointer to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #8
  ret void
}

declare i64 @msecs_to_jiffies(i32) #1

declare i64 @wait_for_completion_timeout(%struct.completion*, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_cancel_orbs(%struct.sbp2_logical_unit* %lu) #2 {
entry:
  %list = alloca %struct.list_head, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !61
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %1 = bitcast %struct.list_head* %list to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %1) #8
  call void @INIT_LIST_HEAD(%struct.list_head* %list)
  %2 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #8
  %5 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #8
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %6 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %lock = getelementptr inbounds %struct.fw_card, %struct.fw_card* %6, i32 0, i32 18
  %call3 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call4 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call3)
  %orb_list = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 3
  call void @list_splice_init(%struct.list_head* %orb_list, %struct.list_head* %list)
  %card7 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %7 = load %struct.fw_card*, %struct.fw_card** %card7, align 8, !tbaa !2
  %lock8 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %7, i32 0, i32 18
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock8, i64 %call4)
  %next9 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %8 = load %struct.list_head*, %struct.list_head** %next9, align 8, !tbaa !49
  %9 = bitcast %struct.list_head* %8 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %9, i64 -320
  %10 = bitcast i8* %add.ptr to %struct.sbp2_orb*
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %.sink = phi %struct.sbp2_orb* [ %13, %for.inc ], [ %10, %entry ]
  %orb.0 = phi %struct.sbp2_orb* [ %10, %entry ], [ %13, %for.inc ]
  %retval1.0 = phi i32 [ -2, %entry ], [ 0, %for.inc ]
  %link24 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %.sink, i32 0, i32 5
  %next25 = getelementptr inbounds %struct.list_head, %struct.list_head* %link24, i32 0, i32 0
  %11 = load %struct.list_head*, %struct.list_head** %next25, align 8, !tbaa !99
  %12 = bitcast %struct.list_head* %11 to i8*
  %add.ptr27 = getelementptr inbounds i8, i8* %12, i64 -320
  %13 = bitcast i8* %add.ptr27 to %struct.sbp2_orb*
  %link15 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb.0, i32 0, i32 5
  %cmp16 = icmp ne %struct.list_head* %link15, %list
  br i1 %cmp16, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %card18 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %14 = load %struct.fw_card*, %struct.fw_card** %card18, align 8, !tbaa !2
  %t = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb.0, i32 0, i32 0
  %call19 = call i32 @fw_cancel_transaction(%struct.fw_card* %14, %struct.fw_transaction* %t)
  %cmp20 = icmp eq i32 %call19, 0
  br i1 %cmp20, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %rcode = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb.0, i32 0, i32 3
  store i32 17, i32* %rcode, align 8, !tbaa !100
  %callback = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb.0, i32 0, i32 4
  %15 = load void (%struct.sbp2_orb*, %struct.sbp2_status*)*, void (%struct.sbp2_orb*, %struct.sbp2_status*)** %callback, align 8, !tbaa !101
  call void %15(%struct.sbp2_orb* %orb.0, %struct.sbp2_status* null)
  %kref = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %orb.0, i32 0, i32 1
  call void @kref_put(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* @free_orb)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %for.body
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %16 = bitcast %struct.list_head* %list to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %16) #8
  ret i32 %retval1.0
}

; Function Attrs: nounwind uwtable
define internal %struct.device* @lu_dev(%struct.sbp2_logical_unit* %lu) #2 {
entry:
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !61
  %unit = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 0
  %1 = load %struct.fw_unit*, %struct.fw_unit** %unit, align 8, !tbaa !34
  %device = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %1, i32 0, i32 0
  ret %struct.device* %device
}

declare i32 @dev_err(%struct.device*, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @dma_unmap_single_attrs(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, %struct.sigset_t* %attrs) #3 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %call1 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.end10

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.6, i32 0, i32 0), i32 36, i64 12) #8, !srcloc !102
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.end10:                                         ; preds = %entry
  %unmap_page = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 5
  %0 = load void (%struct.device*, i64, i64, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32, %struct.sigset_t*)** %unmap_page, align 8, !tbaa !103
  %tobool11 = icmp ne void (%struct.device*, i64, i64, i32, %struct.sigset_t*)* %0, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %do.end10
  %unmap_page13 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 5
  %1 = load void (%struct.device*, i64, i64, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32, %struct.sigset_t*)** %unmap_page13, align 8, !tbaa !103
  call void %1(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, %struct.sigset_t* %attrs)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %do.end10
  call void @debug_dma_unmap_page(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, i1 zeroext true)
  ret void
}

declare i8* @__memcpy(i8*, i8*, i64) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #4

; Function Attrs: nounwind uwtable
define internal void @free_orb(%struct.arch_spinlock* %kref) #2 {
entry:
  %0 = bitcast %struct.arch_spinlock* %kref to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -288
  %1 = bitcast i8* %add.ptr to %struct.sbp2_orb*
  %2 = bitcast %struct.sbp2_orb* %1 to i8*
  call void @kfree(i8* %2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* %release) #3 {
entry:
  call void @kref_sub(%struct.arch_spinlock* %kref, i32 1, void (%struct.arch_spinlock*)* %release)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_sub(%struct.arch_spinlock* %kref, i32 %count, void (%struct.arch_spinlock*)* %release) #3 {
entry:
  %cmp = icmp eq void (%struct.arch_spinlock*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 71)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool7 = icmp ne i32 %lnot.ext, 0
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  %expval13 = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_sub_and_test(i32 %count, %union.anon.1* %refcount)
  %tobool14 = icmp ne i32 %call, 0
  br i1 %tobool14, label %if.then15, label %return

if.then15:                                        ; preds = %if.end
  call void %release(%struct.arch_spinlock* %kref)
  br label %return

return:                                           ; preds = %if.then15, %if.end
  %retval.0 = phi i32 [ 1, %if.then15 ], [ 0, %if.end ]
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #6

declare void @warn_slowpath_null(i8*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_sub_and_test(i32 %i, %union.anon.1* %v) #3 {
entry:
  %c = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c) #8
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subl $2,$0; sete $1", "=*m,=*qm,ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32 %i, i32* %counter) #8, !srcloc !104
  %0 = load i8, i8* %c, align 1, !tbaa !68
  %conv = zext i8 %0 to i32
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c) #8
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev) #3 {
entry:
  %tobool = icmp ne %struct.device* %dev, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %archdata = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 17
  %dma_ops = getelementptr inbounds %struct.dev_archdata, %struct.dev_archdata* %archdata, i32 0, i32 0
  %0 = load %struct.dma_map_ops*, %struct.dma_map_ops** %dma_ops, align 8, !tbaa !105
  %tobool4 = icmp ne %struct.dma_map_ops* %0, null
  br i1 %tobool4, label %if.else, label %return

if.else:                                          ; preds = %lor.lhs.false
  %archdata5 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 17
  %dma_ops6 = getelementptr inbounds %struct.dev_archdata, %struct.dev_archdata* %archdata5, i32 0, i32 0
  br label %return

return:                                           ; preds = %if.else, %lor.lhs.false, %entry
  %dma_ops6.sink = phi %struct.dma_map_ops** [ %dma_ops6, %if.else ], [ @dma_ops, %lor.lhs.false ], [ @dma_ops, %entry ]
  %1 = load %struct.dma_map_ops*, %struct.dma_map_ops** %dma_ops6.sink, align 8, !tbaa !48
  ret %struct.dma_map_ops* %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @valid_dma_direction(i32 %dma_direction) #3 {
entry:
  %switch = icmp ult i32 %dma_direction, 3
  %. = select i1 %switch, i1 true, i1 false
  %lor.ext = zext i1 %. to i32
  ret i32 %lor.ext
}

declare void @debug_dma_unmap_page(%struct.device*, i64, i64, i32, i1 zeroext) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !49
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !106
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_splice_init(%struct.list_head* %list, %struct.list_head* %head) #3 {
entry:
  %call = call i32 @list_empty(%struct.list_head* %list)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !49
  call void @__list_splice(%struct.list_head* %list, %struct.list_head* %head, %struct.list_head* %0)
  call void @INIT_LIST_HEAD(%struct.list_head* %list)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i32 @fw_cancel_transaction(%struct.fw_card*, %struct.fw_transaction*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !49
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_splice(%struct.list_head* %list, %struct.list_head* %prev, %struct.list_head* %next) #3 {
entry:
  %next1 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next1, align 8, !tbaa !49
  %prev2 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  %1 = load %struct.list_head*, %struct.list_head** %prev2, align 8, !tbaa !106
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !106
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  store %struct.list_head* %0, %struct.list_head** %next4, align 8, !tbaa !49
  %next5 = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next5, align 8, !tbaa !49
  %prev6 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %1, %struct.list_head** %prev6, align 8, !tbaa !106
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #3 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !106
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get(%struct.arch_spinlock* %kref) #3 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_add_return(i32 1, %union.anon.1* %refcount)
  %cmp = icmp slt i32 %call, 2
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @kref_get.__warned, align 1, !tbaa !84, !range !64
  %tobool7 = trunc i8 %0 to i1
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 47)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  %tobool23 = icmp ne i32 %lnot.ext13, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end
  store i8 1, i8* @kref_get.__warned, align 1, !tbaa !84
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end, %entry
  %tobool35 = icmp ne i32 %lnot.ext, 0
  %lnot36 = xor i1 %tobool35, true
  %lnot38 = xor i1 %lnot36, true
  %lnot.ext39 = zext i1 %lnot38 to i32
  %conv40 = sext i32 %lnot.ext39 to i64
  %expval41 = call i64 @llvm.expect.i64(i64 %conv40, i64 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @complete_transaction(%struct.fw_card* %card, i32 %rcode, i8* %payload, i64 %length, i8* %data) #2 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i8* %data to %struct.sbp2_orb*
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #8
  %lock = getelementptr inbounds %struct.fw_card, %struct.fw_card* %card, i32 0, i32 18
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %rcode5 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 3
  %5 = load i32, i32* %rcode5, align 8, !tbaa !100
  %cmp6 = icmp eq i32 %5, -1
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %rcode8 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 3
  store i32 %rcode, i32* %rcode8, align 8, !tbaa !100
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rcode9 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 3
  %6 = load i32, i32* %rcode9, align 8, !tbaa !100
  %cmp10 = icmp ne i32 %6, 0
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %link = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 5
  call void @list_del(%struct.list_head* %link)
  %lock13 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %card, i32 0, i32 18
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock13, i64 %call2)
  %callback = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 4
  %7 = load void (%struct.sbp2_orb*, %struct.sbp2_status*)*, void (%struct.sbp2_orb*, %struct.sbp2_status*)** %callback, align 8, !tbaa !101
  call void %7(%struct.sbp2_orb* %0, %struct.sbp2_status* null)
  %kref = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 1
  call void @kref_put(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* @free_orb)
  br label %if.end16

if.else:                                          ; preds = %if.end
  %lock15 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %card, i32 0, i32 18
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock15, i64 %call2)
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then12
  %kref17 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %0, i32 0, i32 1
  call void @kref_put(%struct.arch_spinlock* %kref17, void (%struct.arch_spinlock*)* @free_orb)
  ret void
}

declare void @fw_send_request(%struct.fw_card*, %struct.fw_transaction*, i32, i32, i32, i32, i64, i8*, i64, void (%struct.fw_card*, i32, i8*, i64, i8*)*, i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return(i32 %i, %union.anon.1* %v) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #8, !srcloc !107
  %add = add nsw i32 %i, %0
  ret i32 %add
}

declare void @__list_add(%struct.list_head*, %struct.list_head*, %struct.list_head*) #1

declare void @complete(%struct.completion*) #1

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #1

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32(i32 %val) #5 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #6, !srcloc !108
  ret i32 %0
}

declare void @debug_dma_mapping_error(%struct.device*, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @kmemcheck_mark_initialized() #3 {
entry:
  ret void
}

declare i64 @__phys_addr(i64) #1

declare void @debug_dma_map_page(%struct.device*, %struct.page*, i64, i64, i32, i64, i1 zeroext) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set(%union.anon.1* %v, i32 %i) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !109
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #7 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

declare i8* @__kmalloc(i64, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read(%union.anon.1* %v) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !37
  ret i32 %0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #4

declare i32 @scsilun_to_int(%struct.scsi_lun*) #1

declare void @scsi_unblock_requests(%struct.Scsi_Host*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @dma_get_max_seg_size(%struct.device* %dev) #3 {
entry:
  %dma_parms = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 14
  %0 = load %struct.shrink_control*, %struct.shrink_control** %dma_parms, align 8, !tbaa !110
  %tobool = icmp ne %struct.shrink_control* %0, null
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %dma_parms1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 14
  %1 = load %struct.shrink_control*, %struct.shrink_control** %dma_parms1, align 8, !tbaa !110
  %max_segment_size = getelementptr inbounds %struct.shrink_control, %struct.shrink_control* %1, i32 0, i32 0
  %2 = load i32, i32* %max_segment_size, align 8, !tbaa !111
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi i32 [ %2, %cond.true ], [ 65536, %entry ]
  ret i32 %cond
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @dma_set_max_seg_size(%struct.device* %dev, i32 %size) #3 {
entry:
  %dma_parms = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 14
  %0 = load %struct.shrink_control*, %struct.shrink_control** %dma_parms, align 8, !tbaa !110
  %tobool = icmp ne %struct.shrink_control* %0, null
  br i1 %tobool, label %if.then, label %return

if.then:                                          ; preds = %entry
  %dma_parms1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 14
  %1 = load %struct.shrink_control*, %struct.shrink_control** %dma_parms1, align 8, !tbaa !110
  %max_segment_size = getelementptr inbounds %struct.shrink_control, %struct.shrink_control* %1, i32 0, i32 0
  store i32 %size, i32* %max_segment_size, align 8, !tbaa !111
  br label %return

return:                                           ; preds = %if.then, %entry
  %retval.0 = phi i32 [ 0, %if.then ], [ -5, %entry ]
  ret i32 %retval.0
}

declare %struct.Scsi_Host* @scsi_host_alloc(%struct.scsi_host_template*, i32) #1

declare i32 @dev_set_drvdata(%struct.device*, i8*) #1

declare i32 @scsi_add_host_with_dma(%struct.Scsi_Host*, %struct.device*, %struct.device*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_scan_unit_dir(%struct.sbp2_target* %tgt, i32* %directory, i32* %model, i32* %firmware_revision) #2 {
entry:
  %ci = alloca %struct.fw_csr_iterator, align 8
  %key = alloca i32, align 4
  %value = alloca i32, align 4
  %0 = bitcast %struct.fw_csr_iterator* %ci to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #8
  %1 = bitcast i32* %key to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  %2 = bitcast i32* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #8
  call void @fw_csr_iterator_init(%struct.fw_csr_iterator* %ci, i32* %directory)
  br label %while.cond

while.cond:                                       ; preds = %sw.epilog, %entry
  %call = call i32 @fw_csr_iterator_next(%struct.fw_csr_iterator* %ci, i32* %key, i32* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %3 = load i32, i32* %key, align 4, !tbaa !37
  %Pivot26 = icmp slt i32 %3, 60
  br i1 %Pivot26, label %NodeBlock9, label %NodeBlock23

NodeBlock23:                                      ; preds = %while.body
  %Pivot24 = icmp slt i32 %3, 141
  br i1 %Pivot24, label %NodeBlock15, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %3, 212
  br i1 %Pivot22, label %LeafBlock17, label %LeafBlock19

LeafBlock19:                                      ; preds = %NodeBlock21
  %SwitchLeaf20 = icmp eq i32 %3, 212
  br i1 %SwitchLeaf20, label %sw.bb11, label %sw.epilog

LeafBlock17:                                      ; preds = %NodeBlock21
  %SwitchLeaf18 = icmp eq i32 %3, 141
  br i1 %SwitchLeaf18, label %sw.bb9, label %sw.epilog

NodeBlock15:                                      ; preds = %NodeBlock23
  %Pivot16 = icmp slt i32 %3, 84
  br i1 %Pivot16, label %LeafBlock11, label %LeafBlock13

LeafBlock13:                                      ; preds = %NodeBlock15
  %SwitchLeaf14 = icmp eq i32 %3, 84
  br i1 %SwitchLeaf14, label %sw.bb, label %sw.epilog

LeafBlock11:                                      ; preds = %NodeBlock15
  %SwitchLeaf12 = icmp eq i32 %3, 60
  br i1 %SwitchLeaf12, label %sw.bb3, label %sw.epilog

NodeBlock9:                                       ; preds = %while.body
  %Pivot10 = icmp slt i32 %3, 32
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %3, 58
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %3, 58
  br i1 %SwitchLeaf6, label %sw.bb4, label %sw.epilog

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %3, 32
  br i1 %SwitchLeaf4, label %sw.bb1, label %sw.epilog

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %3, 23
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %3, 23
  br i1 %SwitchLeaf2, label %sw.bb2, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %3, 20
  br i1 %SwitchLeaf, label %sw.bb6, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock13
  %4 = load i32, i32* %value, align 4, !tbaa !37
  %mul = mul nsw i32 4, %4
  %conv = sext i32 %mul to i64
  %add = add i64 281474708275200, %conv
  %management_agent_address = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 2
  store i64 %add, i64* %management_agent_address, align 8, !tbaa !88
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock3
  %5 = load i32, i32* %value, align 4, !tbaa !37
  %directory_id = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 4
  store i32 %5, i32* %directory_id, align 8, !tbaa !44
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock1
  %6 = load i32, i32* %value, align 4, !tbaa !37
  store i32 %6, i32* %model, align 4, !tbaa !37
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock11
  %7 = load i32, i32* %value, align 4, !tbaa !37
  store i32 %7, i32* %firmware_revision, align 4, !tbaa !37
  br label %sw.epilog

sw.bb4:                                           ; preds = %LeafBlock5
  %8 = load i32, i32* %value, align 4, !tbaa !37
  %shr = ashr i32 %8, 8
  %and = and i32 %shr, 255
  %mul5 = mul nsw i32 %and, 500
  %mgt_orb_timeout = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 8
  store i32 %mul5, i32* %mgt_orb_timeout, align 8, !tbaa !85
  br label %sw.epilog

sw.bb6:                                           ; preds = %LeafBlock
  %9 = load i32, i32* %value, align 4, !tbaa !37
  %call7 = call i32 @sbp2_add_logical_unit(%struct.sbp2_target* %tgt, i32 %9)
  %cmp = icmp slt i32 %call7, 0
  br i1 %cmp, label %cleanup, label %sw.epilog

sw.bb9:                                           ; preds = %LeafBlock17
  %p = getelementptr inbounds %struct.fw_csr_iterator, %struct.fw_csr_iterator* %ci, i32 0, i32 0
  %10 = load i32*, i32** %p, align 8, !tbaa !113
  %add.ptr = getelementptr inbounds i32, i32* %10, i64 -1
  %11 = load i32, i32* %value, align 4, !tbaa !37
  %idx.ext = sext i32 %11 to i64
  %add.ptr10 = getelementptr inbounds i32, i32* %add.ptr, i64 %idx.ext
  call void @sbp2_get_unit_unique_id(%struct.sbp2_target* %tgt, i32* %add.ptr10)
  br label %sw.epilog

sw.bb11:                                          ; preds = %LeafBlock19
  %p12 = getelementptr inbounds %struct.fw_csr_iterator, %struct.fw_csr_iterator* %ci, i32 0, i32 0
  %12 = load i32*, i32** %p12, align 8, !tbaa !113
  %add.ptr13 = getelementptr inbounds i32, i32* %12, i64 -1
  %13 = load i32, i32* %value, align 4, !tbaa !37
  %idx.ext14 = sext i32 %13 to i64
  %add.ptr15 = getelementptr inbounds i32, i32* %add.ptr13, i64 %idx.ext14
  %call16 = call i32 @sbp2_scan_logical_unit_dir(%struct.sbp2_target* %tgt, i32* %add.ptr15)
  %cmp17 = icmp slt i32 %call16, 0
  br i1 %cmp17, label %cleanup, label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb11, %sw.bb9, %sw.bb6, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock11, %LeafBlock13, %LeafBlock17, %LeafBlock19
  br label %while.cond

cleanup:                                          ; preds = %sw.bb11, %sw.bb6, %while.cond
  %retval.0 = phi i32 [ -12, %sw.bb6 ], [ -12, %sw.bb11 ], [ 0, %while.cond ]
  %14 = bitcast i32* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %14) #8
  %15 = bitcast i32* %key to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %15) #8
  %16 = bitcast %struct.fw_csr_iterator* %ci to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %16) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_clamp_management_orb_timeout(%struct.sbp2_target* %tgt) #2 {
entry:
  %mgt_orb_timeout = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 8
  %0 = load i32, i32* %mgt_orb_timeout, align 8, !tbaa !85
  %cmp = icmp ugt i32 %0, 40000
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %struct.device* @tgt_dev(%struct.sbp2_target* %tgt)
  %div = udiv i32 %0, 1000
  %call1 = call i32 (%struct.device*, i8*, ...) @dev_notice(%struct.device* %call, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.24, i32 0, i32 0), i32 %div)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %cmp2 = icmp ult i32 %0, 5000
  %. = select i1 %cmp2, i32 5000, i32 %0
  %cmp3 = icmp ugt i32 %., 40000
  %cond7 = select i1 %cmp3, i32 40000, i32 %.
  %mgt_orb_timeout8 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 8
  store i32 %cond7, i32* %mgt_orb_timeout8, align 8, !tbaa !85
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_init_workarounds(%struct.sbp2_target* %tgt, i32 %model, i32 %firmware_revision) #2 {
entry:
  %0 = load i32, i32* @sbp2_param_workarounds, align 4, !tbaa !37
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %struct.device* @tgt_dev(%struct.sbp2_target* %tgt)
  %call1 = call i32 (%struct.device*, i8*, ...) @dev_notice(%struct.device* %call, i8* getelementptr inbounds ([82 x i8], [82 x i8]* @.str.25, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %and = and i32 %0, 256
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %out, label %if.end4

if.end4:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %i.0 = phi i32 [ 0, %if.end4 ], [ %inc, %for.inc ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 11
  br i1 %cmp, label %for.body, label %out

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [11 x %struct.anon.55], [11 x %struct.anon.55]* @sbp2_workarounds_table, i64 0, i64 %idxprom
  %firmware_revision6 = getelementptr inbounds %struct.anon.55, %struct.anon.55* %arrayidx, i32 0, i32 0
  %1 = load i32, i32* %firmware_revision6, align 4, !tbaa !115
  %and7 = and i32 %firmware_revision, -256
  %cmp8 = icmp ne i32 %1, %and7
  br i1 %cmp8, label %for.inc, label %if.end11

if.end11:                                         ; preds = %for.body
  %idxprom12 = sext i32 %i.0 to i64
  %arrayidx13 = getelementptr inbounds [11 x %struct.anon.55], [11 x %struct.anon.55]* @sbp2_workarounds_table, i64 0, i64 %idxprom12
  %model14 = getelementptr inbounds %struct.anon.55, %struct.anon.55* %arrayidx13, i32 0, i32 1
  %2 = load i32, i32* %model14, align 4, !tbaa !117
  %cmp15 = icmp ne i32 %2, %model
  br i1 %cmp15, label %land.lhs.true, label %if.end23

land.lhs.true:                                    ; preds = %if.end11
  %idxprom17 = sext i32 %i.0 to i64
  %arrayidx18 = getelementptr inbounds [11 x %struct.anon.55], [11 x %struct.anon.55]* @sbp2_workarounds_table, i64 0, i64 %idxprom17
  %model19 = getelementptr inbounds %struct.anon.55, %struct.anon.55* %arrayidx18, i32 0, i32 1
  %3 = load i32, i32* %model19, align 4, !tbaa !117
  %cmp20 = icmp ne i32 %3, -1
  br i1 %cmp20, label %for.inc, label %if.end23

if.end23:                                         ; preds = %land.lhs.true, %if.end11
  %idxprom24 = sext i32 %i.0 to i64
  %arrayidx25 = getelementptr inbounds [11 x %struct.anon.55], [11 x %struct.anon.55]* @sbp2_workarounds_table, i64 0, i64 %idxprom24
  %workarounds = getelementptr inbounds %struct.anon.55, %struct.anon.55* %arrayidx25, i32 0, i32 2
  %4 = load i32, i32* %workarounds, align 4, !tbaa !118
  %or = or i32 %0, %4
  br label %out

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

out:                                              ; preds = %if.end23, %for.cond, %if.end
  %w.1 = phi i32 [ %0, %if.end ], [ %or, %if.end23 ], [ %0, %for.cond ]
  %tobool26 = icmp ne i32 %w.1, 0
  br i1 %tobool26, label %if.then27, label %if.end30

if.then27:                                        ; preds = %out
  %call28 = call %struct.device* @tgt_dev(%struct.sbp2_target* %tgt)
  %call29 = call i32 (%struct.device*, i8*, ...) @dev_notice(%struct.device* %call28, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.26, i32 0, i32 0), i32 %w.1, i32 %firmware_revision, i32 %model)
  br label %if.end30

if.end30:                                         ; preds = %if.then27, %out
  %workarounds31 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 7
  store i32 %w.1, i32* %workarounds31, align 4, !tbaa !119
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.device* @tgt_dev(%struct.sbp2_target* %tgt) #2 {
entry:
  %unit = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 0
  %0 = load %struct.fw_unit*, %struct.fw_unit** %unit, align 8, !tbaa !34
  %device = getelementptr inbounds %struct.fw_unit, %struct.fw_unit* %0, i32 0, i32 0
  ret %struct.device* %device
}

declare void @fw_csr_iterator_init(%struct.fw_csr_iterator*, i32*) #1

declare i32 @fw_csr_iterator_next(%struct.fw_csr_iterator*, i32*, i32*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_add_logical_unit(%struct.sbp2_target* %tgt, i32 %lun_entry) #2 {
entry:
  %.compoundliteral = alloca %struct.pgprot, align 8
  %call = call i8* @kmalloc(i64 344, i32 208)
  %0 = bitcast i8* %call to %struct.sbp2_logical_unit*
  %tobool = icmp ne %struct.sbp2_logical_unit* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %address_handler = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 2
  %length = getelementptr inbounds %struct.fw_address_handler, %struct.fw_address_handler* %address_handler, i32 0, i32 1
  store i64 256, i64* %length, align 8, !tbaa !120
  %address_handler1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 2
  %address_callback = getelementptr inbounds %struct.fw_address_handler, %struct.fw_address_handler* %address_handler1, i32 0, i32 2
  store void (%struct.fw_card*, %struct.fw_request*, i32, i32, i32, i32, i64, i8*, i64, i8*)* @sbp2_status_write, void (%struct.fw_card*, %struct.fw_request*, i32, i32, i32, i32, i64, i8*, i64, i8*)** %address_callback, align 8, !tbaa !121
  %1 = bitcast %struct.sbp2_logical_unit* %0 to i8*
  %address_handler2 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 2
  %callback_data = getelementptr inbounds %struct.fw_address_handler, %struct.fw_address_handler* %address_handler2, i32 0, i32 3
  store i8* %1, i8** %callback_data, align 8, !tbaa !122
  %address_handler3 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 2
  %call4 = call i32 @fw_core_add_address_handler(%struct.fw_address_handler* %address_handler3, %struct.load_weight* @fw_high_memory_region)
  %cmp = icmp slt i32 %call4, 0
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %2 = bitcast %struct.sbp2_logical_unit* %0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

if.end6:                                          ; preds = %if.end
  %tgt7 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 0
  store %struct.sbp2_target* %tgt, %struct.sbp2_target** %tgt7, align 8, !tbaa !61
  %and = and i32 %lun_entry, 65535
  %conv = trunc i32 %and to i16
  %lun = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 5
  store i16 %conv, i16* %lun, align 8, !tbaa !53
  %login_id = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 6
  store i32 65536, i32* %login_id, align 4, !tbaa !54
  %retries = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 8
  store i32 0, i32* %retries, align 4, !tbaa !59
  %has_sdev = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 10
  store i8 0, i8* %has_sdev, align 8, !tbaa !123
  %blocked = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 11
  store i8 0, i8* %blocked, align 1, !tbaa !63
  %dont_block = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 10
  %3 = load i32, i32* %dont_block, align 8, !tbaa !62
  %inc = add nsw i32 %3, 1
  store i32 %inc, i32* %dont_block, align 8, !tbaa !62
  %orb_list = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 3
  call void @INIT_LIST_HEAD(%struct.list_head* %orb_list)
  %work = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 9
  %work10 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work10, i32 0)
  %work11 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 9
  %work12 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work11, i32 0, i32 0
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work12, i32 0, i32 0
  %counter = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !124
  %4 = bitcast %struct.pgprot* %data to i8*
  %5 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 8, i32 8, i1 false), !tbaa.struct !125
  %work13 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 9
  %work14 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work13, i32 0, i32 0
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work14, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.11, i32 0, i32 0), %struct.lock_class_key* @sbp2_add_logical_unit.__key, i32 0)
  %work15 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 9
  %work16 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work15, i32 0, i32 0
  %entry17 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work16, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry17)
  %work19 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 9
  %work20 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work19, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work20, i32 0, i32 2
  store void (%struct.work_struct*)* @sbp2_login, void (%struct.work_struct*)** %func, align 8, !tbaa !127
  %work27 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 9
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work27, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13, i32 0, i32 0), %struct.lock_class_key* @sbp2_add_logical_unit.__key.12)
  %work30 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 9
  %timer31 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work30, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer31, i32 0, i32 3
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !128
  %work32 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 9
  %6 = ptrtoint %struct.delayed_work* %work32 to i64
  %work33 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 9
  %timer34 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work33, i32 0, i32 1
  %data35 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer34, i32 0, i32 4
  store i64 %6, i64* %data35, align 8, !tbaa !129
  %link = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 1
  %lu_list = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 1
  call void @list_add_tail(%struct.list_head* %link, %struct.list_head* %lu_list)
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.then5, %entry
  %retval.0 = phi i32 [ -12, %if.then5 ], [ 0, %if.end6 ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_get_unit_unique_id(%struct.sbp2_target* %tgt, i32* %leaf) #2 {
entry:
  %arrayidx = getelementptr inbounds i32, i32* %leaf, i64 0
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !37
  %and = and i32 %0, -65536
  %cmp = icmp eq i32 %and, 131072
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %arrayidx1 = getelementptr inbounds i32, i32* %leaf, i64 1
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !37
  %conv = zext i32 %1 to i64
  %shl = shl i64 %conv, 32
  %arrayidx2 = getelementptr inbounds i32, i32* %leaf, i64 2
  %2 = load i32, i32* %arrayidx2, align 4, !tbaa !37
  %conv3 = zext i32 %2 to i64
  %or = or i64 %shl, %conv3
  %guid = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %tgt, i32 0, i32 3
  store i64 %or, i64* %guid, align 8, !tbaa !38
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_scan_logical_unit_dir(%struct.sbp2_target* %tgt, i32* %directory) #2 {
entry:
  %ci = alloca %struct.fw_csr_iterator, align 8
  %key = alloca i32, align 4
  %value = alloca i32, align 4
  %0 = bitcast %struct.fw_csr_iterator* %ci to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #8
  %1 = bitcast i32* %key to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  %2 = bitcast i32* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #8
  call void @fw_csr_iterator_init(%struct.fw_csr_iterator* %ci, i32* %directory)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call = call i32 @fw_csr_iterator_next(%struct.fw_csr_iterator* %ci, i32* %key, i32* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %3 = load i32, i32* %key, align 4, !tbaa !37
  %cmp = icmp eq i32 %3, 20
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %4 = load i32, i32* %value, align 4, !tbaa !37
  %call1 = call i32 @sbp2_add_logical_unit(%struct.sbp2_target* %tgt, i32 %4)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %while.body
  br label %while.cond

cleanup:                                          ; preds = %land.lhs.true, %while.cond
  %retval.0 = phi i32 [ -12, %land.lhs.true ], [ 0, %while.cond ]
  %5 = bitcast i32* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %5) #8
  %6 = bitcast i32* %key to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #8
  %7 = bitcast %struct.fw_csr_iterator* %ci to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %7) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_status_write(%struct.fw_card* %card, %struct.fw_request* %request, i32 %tcode, i32 %destination, i32 %source, i32 %generation, i64 %offset, i8* %payload, i64 %length, i8* %callback_data) #2 {
entry:
  %status = alloca %struct.sbp2_status, align 4
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i8* %callback_data to %struct.sbp2_logical_unit*
  %1 = bitcast %struct.sbp2_status* %status to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %1) #8
  %cmp = icmp ne i32 %tcode, 1
  %cmp1 = icmp ult i64 %length, 8
  %or.cond = or i1 %cmp, %cmp1
  %cmp3 = icmp ugt i64 %length, 32
  %or.cond1 = or i1 %or.cond, %cmp3
  br i1 %or.cond1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @fw_send_response(%struct.fw_card* %card, %struct.fw_request* %request, i32 6)
  br label %cleanup

if.end:                                           ; preds = %entry
  %2 = bitcast i8* %payload to i32*
  %call = call i32 @__be32_to_cpup(i32* %2)
  %status4 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  store i32 %call, i32* %status4, align 4, !tbaa !130
  %add.ptr = getelementptr i8, i8* %payload, i64 4
  %3 = bitcast i8* %add.ptr to i32*
  %call5 = call i32 @__be32_to_cpup(i32* %3)
  %orb_low = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 1
  store i32 %call5, i32* %orb_low, align 4, !tbaa !131
  %data = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 2
  %arraydecay = getelementptr inbounds [24 x i8], [24 x i8]* %data, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* %arraydecay, i8 0, i64 24, i32 4, i1 false)
  %cmp6 = icmp ugt i64 %length, 8
  br i1 %cmp6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end
  %sub = sub i64 %length, 8
  %data8 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 2
  %arraydecay9 = getelementptr inbounds [24 x i8], [24 x i8]* %data8, i32 0, i32 0
  %add.ptr10 = getelementptr i8, i8* %payload, i64 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay9, i8* %add.ptr10, i64 %sub, i32 1, i1 false)
  br label %if.end11

if.end11:                                         ; preds = %if.then7, %if.end
  %status12 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  %4 = load i32, i32* %status12, align 4, !tbaa !130
  %shr = lshr i32 %4, 30
  %and = and i32 %shr, 3
  %cmp13 = icmp eq i32 %and, 2
  br i1 %cmp13, label %if.then19, label %lor.lhs.false14

lor.lhs.false14:                                  ; preds = %if.end11
  %status15 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  %5 = load i32, i32* %status15, align 4, !tbaa !130
  %shr16 = lshr i32 %5, 30
  %and17 = and i32 %shr16, 3
  %cmp18 = icmp eq i32 %and17, 3
  br i1 %cmp18, label %if.then19, label %do.body23

if.then19:                                        ; preds = %lor.lhs.false14, %if.end11
  %call20 = call %struct.device* @lu_dev(%struct.sbp2_logical_unit* %0)
  %call21 = call i32 (%struct.device*, i8*, ...) @dev_notice(%struct.device* %call20, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.14, i32 0, i32 0))
  call void @fw_send_response(%struct.fw_card* %card, %struct.fw_request* %request, i32 0)
  br label %cleanup

do.body23:                                        ; preds = %lor.lhs.false14
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #8
  %7 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #8
  %cmp24 = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp24 to i32
  %8 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #8
  %9 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #8
  %lock = getelementptr inbounds %struct.fw_card, %struct.fw_card* %card, i32 0, i32 18
  %call26 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call27 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call26)
  %orb_list = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 3
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body23
  %link47.sink = phi %struct.list_head* [ %link47, %for.inc ], [ %orb_list, %do.body23 ]
  %next48 = getelementptr inbounds %struct.list_head, %struct.list_head* %link47.sink, i32 0, i32 0
  %10 = load %struct.list_head*, %struct.list_head** %next48, align 8, !tbaa !48
  %11 = bitcast %struct.list_head* %10 to i8*
  %add.ptr50 = getelementptr inbounds i8, i8* %11, i64 -320
  %12 = bitcast i8* %add.ptr50 to %struct.sbp2_orb*
  %link = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %12, i32 0, i32 5
  %orb_list32 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 3
  %cmp33 = icmp ne %struct.list_head* %link, %orb_list32
  br i1 %cmp33, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %status35 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  %13 = load i32, i32* %status35, align 4, !tbaa !130
  %and36 = and i32 %13, 65535
  %cmp37 = icmp eq i32 %and36, 0
  br i1 %cmp37, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %orb_low39 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 1
  %14 = load i32, i32* %orb_low39, align 4, !tbaa !131
  %conv40 = zext i32 %14 to i64
  %request_bus = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %12, i32 0, i32 2
  %15 = load i64, i64* %request_bus, align 8, !tbaa !97
  %cmp41 = icmp eq i64 %conv40, %15
  br i1 %cmp41, label %if.then43, label %for.inc

if.then43:                                        ; preds = %land.lhs.true
  %rcode = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %12, i32 0, i32 3
  store i32 0, i32* %rcode, align 8, !tbaa !100
  %link44 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %12, i32 0, i32 5
  call void @list_del(%struct.list_head* %link44)
  br label %for.end

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %link47 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %12, i32 0, i32 5
  br label %for.cond

for.end:                                          ; preds = %if.then43, %for.cond
  %lock51 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %card, i32 0, i32 18
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock51, i64 %call27)
  %link52 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %12, i32 0, i32 5
  %orb_list53 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %0, i32 0, i32 3
  %cmp54 = icmp ne %struct.list_head* %link52, %orb_list53
  br i1 %cmp54, label %if.then56, label %if.else

if.then56:                                        ; preds = %for.end
  %callback = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %12, i32 0, i32 4
  %16 = load void (%struct.sbp2_orb*, %struct.sbp2_status*)*, void (%struct.sbp2_orb*, %struct.sbp2_status*)** %callback, align 8, !tbaa !101
  call void %16(%struct.sbp2_orb* %12, %struct.sbp2_status* %status)
  %kref = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %12, i32 0, i32 1
  call void @kref_put(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* @free_orb)
  br label %if.end60

if.else:                                          ; preds = %for.end
  %call58 = call %struct.device* @lu_dev(%struct.sbp2_logical_unit* %0)
  %call59 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %call58, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.15, i32 0, i32 0))
  br label %if.end60

if.end60:                                         ; preds = %if.else, %if.then56
  call void @fw_send_response(%struct.fw_card* %card, %struct.fw_request* %request, i32 0)
  br label %cleanup

cleanup:                                          ; preds = %if.end60, %if.then19, %if.then
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then ], [ 1, %if.then19 ], [ 0, %if.end60 ]
  %17 = bitcast %struct.sbp2_status* %status to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %17) #8
  ret void
}

declare i32 @fw_core_add_address_handler(%struct.fw_address_handler*, %struct.load_weight*) #1

declare void @__init_work(%struct.work_struct*, i32) #1

declare void @lockdep_init_map(%struct.lockdep_map*, i8*, %struct.lock_class_key*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @sbp2_login(%struct.work_struct* %work) #2 {
entry:
  %response = alloca %struct.sbp2_login_response, align 4
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -112
  %1 = bitcast i8* %add.ptr to %struct.sbp2_logical_unit*
  %tgt1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %2 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt1, align 8, !tbaa !61
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %2)
  %3 = bitcast %struct.sbp2_login_response* %response to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %3) #8
  %call2 = call i32 @fw_device_is_shutdown(%struct.fw_device* %call)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %generation3 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 3
  %4 = load i32, i32* %generation3, align 4, !tbaa !55
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !132
  %node_id4 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 2
  %5 = load i32, i32* %node_id4, align 8, !tbaa !57
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %6 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %node_id5 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %6, i32 0, i32 4
  %7 = load i32, i32* %node_id5, align 8, !tbaa !133
  %has_sdev = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 10
  %8 = load i8, i8* %has_sdev, align 8, !tbaa !123, !range !64
  %tobool6 = trunc i8 %8 to i1
  br i1 %tobool6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end
  %node_id8 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 2
  %9 = load i32, i32* %node_id8, align 8, !tbaa !57
  %login_id = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 6
  %10 = load i32, i32* %login_id, align 4, !tbaa !54
  %call9 = call i32 @sbp2_send_management_orb(%struct.sbp2_logical_unit* %1, i32 %9, i32 %4, i32 7, i32 %10, i8* null)
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end
  %lun = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 5
  %11 = load i16, i16* %lun, align 8, !tbaa !53
  %conv = zext i16 %11 to i32
  %12 = bitcast %struct.sbp2_login_response* %response to i8*
  %call11 = call i32 @sbp2_send_management_orb(%struct.sbp2_logical_unit* %1, i32 %5, i32 %4, i32 0, i32 %conv, i8* %12)
  %cmp = icmp slt i32 %call11, 0
  br i1 %cmp, label %if.then13, label %if.end23

if.then13:                                        ; preds = %if.end10
  %retries = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 8
  %13 = load i32, i32* %retries, align 4, !tbaa !59
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %retries, align 4, !tbaa !59
  %cmp14 = icmp slt i32 %13, 5
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.then13
  call void @sbp2_queue_work(%struct.sbp2_logical_unit* %1, i64 50)
  br label %cleanup

if.else:                                          ; preds = %if.then13
  %call17 = call %struct.device* @tgt_dev(%struct.sbp2_target* %2)
  %lun18 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 5
  %14 = load i16, i16* %lun18, align 8, !tbaa !53
  %conv19 = zext i16 %14 to i32
  %call20 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %call17, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.16, i32 0, i32 0), i32 %conv19)
  %tgt21 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %15 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt21, align 8, !tbaa !61
  call void @sbp2_unblock(%struct.sbp2_target* %15)
  br label %cleanup

if.end23:                                         ; preds = %if.end10
  %node_id24 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %2, i32 0, i32 5
  store i32 %5, i32* %node_id24, align 4, !tbaa !134
  %shl = shl i32 %7, 16
  %address_high = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %2, i32 0, i32 6
  store i32 %shl, i32* %address_high, align 8, !tbaa !135
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !136
  %generation25 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 7
  store i32 %4, i32* %generation25, align 8, !tbaa !65
  %command_block_agent = getelementptr inbounds %struct.sbp2_login_response, %struct.sbp2_login_response* %response, i32 0, i32 1
  %high = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %command_block_agent, i32 0, i32 0
  %16 = load i32, i32* %high, align 4, !tbaa !137
  %call26 = call i32 @__fswab32(i32 %16) #6
  %and = and i32 %call26, 65535
  %conv27 = zext i32 %and to i64
  %shl28 = shl i64 %conv27, 32
  %command_block_agent29 = getelementptr inbounds %struct.sbp2_login_response, %struct.sbp2_login_response* %response, i32 0, i32 1
  %low = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %command_block_agent29, i32 0, i32 1
  %17 = load i32, i32* %low, align 4, !tbaa !139
  %call30 = call i32 @__fswab32(i32 %17) #6
  %conv31 = zext i32 %call30 to i64
  %or = or i64 %shl28, %conv31
  %command_block_agent_address = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 4
  store i64 %or, i64* %command_block_agent_address, align 8, !tbaa !140
  %misc = getelementptr inbounds %struct.sbp2_login_response, %struct.sbp2_login_response* %response, i32 0, i32 0
  %18 = load i32, i32* %misc, align 4, !tbaa !141
  %call32 = call i32 @__fswab32(i32 %18) #6
  %and33 = and i32 %call32, 65535
  %login_id34 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 6
  store i32 %and33, i32* %login_id34, align 4, !tbaa !54
  %call35 = call %struct.device* @tgt_dev(%struct.sbp2_target* %2)
  %lun36 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 5
  %19 = load i16, i16* %lun36, align 8, !tbaa !53
  %conv37 = zext i16 %19 to i32
  %retries38 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 8
  %20 = load i32, i32* %retries38, align 4, !tbaa !59
  %call39 = call i32 (%struct.device*, i8*, ...) @dev_notice(%struct.device* %call35, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.17, i32 0, i32 0), i32 %conv37, i32 %20)
  call void @sbp2_set_busy_timeout(%struct.sbp2_logical_unit* %1)
  %work40 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 9
  %work41 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work40, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work41, i32 0, i32 2
  store void (%struct.work_struct*)* @sbp2_reconnect, void (%struct.work_struct*)** %func, align 8, !tbaa !127
  call void @sbp2_agent_reset(%struct.sbp2_logical_unit* %1)
  %has_sdev42 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 10
  %21 = load i8, i8* %has_sdev42, align 8, !tbaa !123, !range !64
  %tobool43 = trunc i8 %21 to i1
  br i1 %tobool43, label %if.then44, label %if.end46

if.then44:                                        ; preds = %if.end23
  %call45 = call i32 @sbp2_cancel_orbs(%struct.sbp2_logical_unit* %1)
  call void @sbp2_conditionally_unblock(%struct.sbp2_logical_unit* %1)
  br label %cleanup

if.end46:                                         ; preds = %if.end23
  %tgt47 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %22 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt47, align 8, !tbaa !61
  %workarounds = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %22, i32 0, i32 7
  %23 = load i32, i32* %workarounds, align 4, !tbaa !119
  %and48 = and i32 %23, 16
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %if.end46
  call void @ssleep(i32 12)
  br label %if.end51

if.end51:                                         ; preds = %if.then50, %if.end46
  %24 = bitcast %struct.sbp2_target* %2 to i8*
  %25 = bitcast i8* %24 to i64*
  %26 = bitcast i64* %25 to i8*
  %add.ptr54 = getelementptr inbounds i8, i8* %26, i64 -3016
  %27 = bitcast i8* %add.ptr54 to %struct.Scsi_Host*
  %lun55 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 5
  %28 = load i16, i16* %lun55, align 8, !tbaa !53
  %call56 = call i32 @sbp2_lun2int(i16 zeroext %28)
  %29 = bitcast %struct.sbp2_logical_unit* %1 to i8*
  %call57 = call %struct.scsi_device* @__scsi_add_device(%struct.Scsi_Host* %27, i32 0, i32 0, i32 %call56, i8* %29)
  %30 = bitcast %struct.scsi_device* %call57 to i8*
  %call58 = call i64 @IS_ERR(i8* %30)
  %tobool59 = icmp ne i64 %call58, 0
  br i1 %tobool59, label %out_logout_login, label %if.end61

if.end61:                                         ; preds = %if.end51
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !142
  %card62 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %31 = load %struct.fw_card*, %struct.fw_card** %card62, align 8, !tbaa !2
  %generation63 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %31, i32 0, i32 5
  %32 = load i32, i32* %generation63, align 4, !tbaa !66
  %cmp64 = icmp ne i32 %4, %32
  br i1 %cmp64, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.end61
  call void @scsi_remove_device(%struct.scsi_device* %call57)
  call void @scsi_device_put(%struct.scsi_device* %call57)
  br label %out_logout_login

if.end67:                                         ; preds = %if.end61
  %has_sdev68 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 10
  store i8 1, i8* %has_sdev68, align 8, !tbaa !123
  call void @scsi_device_put(%struct.scsi_device* %call57)
  call void @sbp2_allow_block(%struct.sbp2_logical_unit* %1)
  br label %cleanup

out_logout_login:                                 ; preds = %if.then66, %if.end51
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !143
  %generation69 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 3
  %33 = load i32, i32* %generation69, align 4, !tbaa !55
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !144
  %node_id70 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 2
  %34 = load i32, i32* %node_id70, align 8, !tbaa !57
  %login_id71 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 6
  %35 = load i32, i32* %login_id71, align 4, !tbaa !54
  %call72 = call i32 @sbp2_send_management_orb(%struct.sbp2_logical_unit* %1, i32 %34, i32 %33, i32 7, i32 %35, i8* null)
  %work74 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 9
  %work75 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work74, i32 0, i32 0
  %func76 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work75, i32 0, i32 2
  store void (%struct.work_struct*)* @sbp2_login, void (%struct.work_struct*)** %func76, align 8, !tbaa !127
  br label %cleanup

cleanup:                                          ; preds = %out_logout_login, %if.end67, %if.then44, %if.else, %if.then16, %entry
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then44 ], [ 0, %out_logout_login ], [ 1, %if.end67 ], [ 1, %entry ], [ 1, %if.else ], [ 1, %if.then16 ]
  %36 = bitcast %struct.sbp2_login_response* %response to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %36) #8
  ret void
}

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #1

declare void @delayed_work_timer_fn(i64) #1

; Function Attrs: nounwind uwtable
define internal void @sbp2_set_busy_timeout(%struct.sbp2_logical_unit* %lu) #2 {
entry:
  %d = alloca i32, align 4
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !61
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %1 = bitcast i32* %d to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  store i32 260049920, i32* %d, align 4, !tbaa !37
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %2 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %tgt1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %3 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt1, align 8, !tbaa !61
  %node_id = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %3, i32 0, i32 5
  %4 = load i32, i32* %node_id, align 4, !tbaa !134
  %generation = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 7
  %5 = load i32, i32* %generation, align 8, !tbaa !65
  %max_speed = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 4
  %6 = load i32, i32* %max_speed, align 8, !tbaa !45
  %7 = bitcast i32* %d to i8*
  %call2 = call i32 @fw_run_transaction(%struct.fw_card* %2, i32 0, i32 %4, i32 %5, i32 %6, i64 281474708275728, i8* %7, i64 4)
  %8 = bitcast i32* %d to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %8) #8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_reconnect(%struct.work_struct* %work) #2 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -112
  %1 = bitcast i8* %add.ptr to %struct.sbp2_logical_unit*
  %tgt1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %2 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt1, align 8, !tbaa !61
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %2)
  %call2 = call i32 @fw_device_is_shutdown(%struct.fw_device* %call)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %generation3 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 3
  %3 = load i32, i32* %generation3, align 4, !tbaa !55
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !145
  %node_id4 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 2
  %4 = load i32, i32* %node_id4, align 8, !tbaa !57
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %5 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %node_id5 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %5, i32 0, i32 4
  %6 = load i32, i32* %node_id5, align 8, !tbaa !133
  %login_id = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 6
  %7 = load i32, i32* %login_id, align 4, !tbaa !54
  %call6 = call i32 @sbp2_send_management_orb(%struct.sbp2_logical_unit* %1, i32 %4, i32 %3, i32 3, i32 %7, i8* null)
  %cmp = icmp slt i32 %call6, 0
  br i1 %cmp, label %if.then7, label %if.end19

if.then7:                                         ; preds = %if.end
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !146
  %card8 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %8 = load %struct.fw_card*, %struct.fw_card** %card8, align 8, !tbaa !2
  %generation9 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %8, i32 0, i32 5
  %9 = load i32, i32* %generation9, align 4, !tbaa !66
  %cmp10 = icmp eq i32 %3, %9
  br i1 %cmp10, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then7
  %retries = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 8
  %10 = load i32, i32* %retries, align 4, !tbaa !59
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %retries, align 4, !tbaa !59
  %cmp11 = icmp sge i32 %10, 5
  br i1 %cmp11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %lor.lhs.false, %if.then7
  %call13 = call %struct.device* @tgt_dev(%struct.sbp2_target* %2)
  %call14 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %call13, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.22, i32 0, i32 0))
  %retries15 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 8
  store i32 0, i32* %retries15, align 4, !tbaa !59
  %work16 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 9
  %work17 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %work16, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work17, i32 0, i32 2
  store void (%struct.work_struct*)* @sbp2_login, void (%struct.work_struct*)** %func, align 8, !tbaa !127
  br label %if.end18

if.end18:                                         ; preds = %if.then12, %lor.lhs.false
  call void @sbp2_queue_work(%struct.sbp2_logical_unit* %1, i64 50)
  br label %cleanup.cont

if.end19:                                         ; preds = %if.end
  %node_id20 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %2, i32 0, i32 5
  store i32 %4, i32* %node_id20, align 4, !tbaa !134
  %shl = shl i32 %6, 16
  %address_high = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %2, i32 0, i32 6
  store i32 %shl, i32* %address_high, align 8, !tbaa !135
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !147
  %generation21 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 7
  store i32 %3, i32* %generation21, align 8, !tbaa !65
  %call22 = call %struct.device* @tgt_dev(%struct.sbp2_target* %2)
  %lun = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 5
  %11 = load i16, i16* %lun, align 8, !tbaa !53
  %conv = zext i16 %11 to i32
  %retries23 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 8
  %12 = load i32, i32* %retries23, align 4, !tbaa !59
  %call24 = call i32 (%struct.device*, i8*, ...) @dev_notice(%struct.device* %call22, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.23, i32 0, i32 0), i32 %conv, i32 %12)
  call void @sbp2_agent_reset(%struct.sbp2_logical_unit* %1)
  %call25 = call i32 @sbp2_cancel_orbs(%struct.sbp2_logical_unit* %1)
  call void @sbp2_conditionally_unblock(%struct.sbp2_logical_unit* %1)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end19, %if.end18, %entry
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.end18 ], [ 0, %if.end19 ], [ 1, %entry ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_agent_reset(%struct.sbp2_logical_unit* %lu) #2 {
entry:
  %d = alloca i32, align 4
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !61
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %1 = bitcast i32* %d to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  store i32 0, i32* %d, align 4, !tbaa !37
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %2 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %tgt1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %3 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt1, align 8, !tbaa !61
  %node_id = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %3, i32 0, i32 5
  %4 = load i32, i32* %node_id, align 4, !tbaa !134
  %generation = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 7
  %5 = load i32, i32* %generation, align 8, !tbaa !65
  %max_speed = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 4
  %6 = load i32, i32* %max_speed, align 8, !tbaa !45
  %command_block_agent_address = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 4
  %7 = load i64, i64* %command_block_agent_address, align 8, !tbaa !140
  %add = add i64 %7, 4
  %8 = bitcast i32* %d to i8*
  %call2 = call i32 @fw_run_transaction(%struct.fw_card* %2, i32 0, i32 %4, i32 %5, i32 %6, i64 %add, i8* %8, i64 4)
  %9 = bitcast i32* %d to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %9) #8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_conditionally_unblock(%struct.sbp2_logical_unit* %lu) #2 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tgt1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt1, align 8, !tbaa !61
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %card2 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %1 = load %struct.fw_card*, %struct.fw_card** %card2, align 8, !tbaa !2
  %2 = bitcast %struct.sbp2_target* %0 to i8*
  %3 = bitcast i8* %2 to i64*
  %4 = bitcast i64* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 -3016
  %5 = bitcast i8* %add.ptr to %struct.Scsi_Host*
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #8
  %7 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %8 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #8
  %9 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #8
  %lock = getelementptr inbounds %struct.fw_card, %struct.fw_card* %1, i32 0, i32 18
  %call5 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call6 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call5)
  %blocked = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 11
  %10 = load i8, i8* %blocked, align 1, !tbaa !63, !range !64
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %generation = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 7
  %11 = load i32, i32* %generation, align 8, !tbaa !65
  %generation10 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %1, i32 0, i32 5
  %12 = load i32, i32* %generation10, align 4, !tbaa !66
  %cmp11 = icmp eq i32 %11, %12
  br i1 %cmp11, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %blocked13 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 11
  store i8 0, i8* %blocked13, align 1, !tbaa !63
  %blocked14 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 11
  %13 = load i32, i32* %blocked14, align 4, !tbaa !67
  %dec = add nsw i32 %13, -1
  store i32 %dec, i32* %blocked14, align 4, !tbaa !67
  %cmp15 = icmp eq i32 %dec, 0
  %frombool = zext i1 %cmp15 to i8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %unblock.0 = phi i8 [ %frombool, %if.then ], [ 0, %land.lhs.true ], [ 0, %entry ]
  %lock17 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %1, i32 0, i32 18
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock17, i64 %call6)
  %tobool18 = trunc i8 %unblock.0 to i1
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end
  call void @scsi_unblock_requests(%struct.Scsi_Host* %5)
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @ssleep(i32 %seconds) #3 {
entry:
  %mul = mul i32 %seconds, 1000
  call void @msleep(i32 %mul)
  ret void
}

declare %struct.scsi_device* @__scsi_add_device(%struct.Scsi_Host*, i32, i32, i32, i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sbp2_allow_block(%struct.sbp2_logical_unit* %lu) #3 {
entry:
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !61
  %dont_block = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %0, i32 0, i32 10
  %1 = load i32, i32* %dont_block, align 8, !tbaa !62
  %dec = add nsw i32 %1, -1
  store i32 %dec, i32* %dont_block, align 8, !tbaa !62
  ret void
}

declare void @msleep(i32) #1

declare i32 @fw_run_transaction(%struct.fw_card*, i32, i32, i32, i32, i64, i8*, i64) #1

declare void @fw_send_response(%struct.fw_card*, %struct.fw_request*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__be32_to_cpup(i32* %p) #3 {
entry:
  %call = call i32 @__swab32p(i32* %p)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__swab32p(i32* %p) #3 {
entry:
  %0 = load i32, i32* %p, align 4, !tbaa !37
  %call = call i32 @__fswab32(i32 %0) #6
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_scsi_queuecommand(%struct.Scsi_Host* %shost, %struct.scsi_cmnd* %cmd) #2 {
entry:
  %device = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 0
  %0 = load %struct.scsi_device*, %struct.scsi_device** %device, align 8, !tbaa !148
  %hostdata = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %0, i32 0, i32 23
  %1 = load i8*, i8** %hostdata, align 8, !tbaa !153
  %2 = bitcast i8* %1 to %struct.sbp2_logical_unit*
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %2, i32 0, i32 0
  %3 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !61
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %3)
  %sc_data_direction = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 11
  %4 = load i32, i32* %sc_data_direction, align 4, !tbaa !156
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call %struct.device* @lu_dev(%struct.sbp2_logical_unit* %2)
  %call4 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %call3, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.5, i32 0, i32 0))
  %result = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 22
  store i32 458752, i32* %result, align 8, !tbaa !157
  %scsi_done = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 19
  %5 = load void (%struct.scsi_cmnd*)*, void (%struct.scsi_cmnd*)** %scsi_done, align 8, !tbaa !158
  call void %5(%struct.scsi_cmnd* %cmd)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call5 = call i8* @kzalloc(i64 1424, i32 32)
  %6 = bitcast i8* %call5 to %struct.sbp2_command_orb*
  %cmp6 = icmp eq %struct.sbp2_command_orb* %6, null
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end
  %base = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %6, i32 0, i32 0
  %rcode = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base, i32 0, i32 3
  store i32 -1, i32* %rcode, align 8, !tbaa !159
  %base9 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %6, i32 0, i32 0
  %kref = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base9, i32 0, i32 1
  call void @kref_init(%struct.arch_spinlock* %kref)
  %lu10 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %6, i32 0, i32 3
  store %struct.sbp2_logical_unit* %2, %struct.sbp2_logical_unit** %lu10, align 8, !tbaa !162
  %cmd11 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %6, i32 0, i32 2
  store %struct.scsi_cmnd* %cmd, %struct.scsi_cmnd** %cmd11, align 8, !tbaa !163
  %request = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %6, i32 0, i32 1
  %next = getelementptr inbounds %struct.anon.53, %struct.anon.53* %request, i32 0, i32 0
  %high = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %next, i32 0, i32 0
  store i32 128, i32* %high, align 8, !tbaa !164
  %tgt12 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %2, i32 0, i32 0
  %7 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt12, align 8, !tbaa !61
  %max_payload = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %7, i32 0, i32 9
  %8 = load i32, i32* %max_payload, align 4, !tbaa !47
  %shl = shl i32 %8, 20
  %max_speed = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 4
  %9 = load i32, i32* %max_speed, align 8, !tbaa !45
  %shl13 = shl i32 %9, 24
  %or = or i32 %shl, %shl13
  %or14 = or i32 %or, -2147483648
  %call15 = call i32 @__fswab32(i32 %or14) #6
  %request16 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %6, i32 0, i32 1
  %misc = getelementptr inbounds %struct.anon.53, %struct.anon.53* %request16, i32 0, i32 2
  store i32 %call15, i32* %misc, align 8, !tbaa !165
  %sc_data_direction17 = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 11
  %10 = load i32, i32* %sc_data_direction17, align 4, !tbaa !156
  %cmp18 = icmp eq i32 %10, 2
  br i1 %cmp18, label %if.then19, label %if.end23

if.then19:                                        ; preds = %if.end8
  %request20 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %6, i32 0, i32 1
  %misc21 = getelementptr inbounds %struct.anon.53, %struct.anon.53* %request20, i32 0, i32 2
  %11 = load i32, i32* %misc21, align 8, !tbaa !165
  %or22 = or i32 %11, 8
  store i32 %or22, i32* %misc21, align 8, !tbaa !165
  br label %if.end23

if.end23:                                         ; preds = %if.then19, %if.end8
  %generation24 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 3
  %12 = load i32, i32* %generation24, align 4, !tbaa !55
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !166
  %call25 = call i32 @scsi_sg_count(%struct.scsi_cmnd* %cmd)
  %tobool = icmp ne i32 %call25, 0
  br i1 %tobool, label %land.lhs.true, label %if.end29

land.lhs.true:                                    ; preds = %if.end23
  %call26 = call i32 @sbp2_map_scatterlist(%struct.sbp2_command_orb* %6, %struct.fw_device* %call, %struct.sbp2_logical_unit* %2)
  %cmp27 = icmp slt i32 %call26, 0
  br i1 %cmp27, label %out, label %if.end29

if.end29:                                         ; preds = %land.lhs.true, %if.end23
  %cmd_len = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 10
  %13 = load i16, i16* %cmd_len, align 2, !tbaa !167
  %conv = zext i16 %13 to i64
  %request30 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %6, i32 0, i32 1
  %command_block = getelementptr inbounds %struct.anon.53, %struct.anon.53* %request30, i32 0, i32 3
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %command_block, i32 0, i32 0
  %cmnd = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 12
  %14 = load i8*, i8** %cmnd, align 8, !tbaa !168
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay, i8* %14, i64 %conv, i32 1, i1 false)
  %base31 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %6, i32 0, i32 0
  %callback = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base31, i32 0, i32 4
  store void (%struct.sbp2_orb*, %struct.sbp2_status*)* @complete_command_orb, void (%struct.sbp2_orb*, %struct.sbp2_status*)** %callback, align 8, !tbaa !169
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %15 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %device32 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %15, i32 0, i32 1
  %16 = load %struct.device*, %struct.device** %device32, align 8, !tbaa !32
  %request33 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %6, i32 0, i32 1
  %17 = bitcast %struct.anon.53* %request33 to i8*
  %call34 = call i64 @dma_map_single_attrs(%struct.device* %16, i8* %17, i64 36, i32 1, %struct.sigset_t* null)
  %base35 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %6, i32 0, i32 0
  %request_bus = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base35, i32 0, i32 2
  store i64 %call34, i64* %request_bus, align 8, !tbaa !170
  %card36 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %18 = load %struct.fw_card*, %struct.fw_card** %card36, align 8, !tbaa !2
  %device37 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %18, i32 0, i32 1
  %19 = load %struct.device*, %struct.device** %device37, align 8, !tbaa !32
  %base38 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %6, i32 0, i32 0
  %request_bus39 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base38, i32 0, i32 2
  %20 = load i64, i64* %request_bus39, align 8, !tbaa !170
  %call40 = call i32 @dma_mapping_error(%struct.device* %19, i64 %20)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.then42, label %if.end45

if.then42:                                        ; preds = %if.end29
  %card43 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %21 = load %struct.fw_card*, %struct.fw_card** %card43, align 8, !tbaa !2
  %device44 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %21, i32 0, i32 1
  %22 = load %struct.device*, %struct.device** %device44, align 8, !tbaa !32
  call void @sbp2_unmap_scatterlist(%struct.device* %22, %struct.sbp2_command_orb* %6)
  br label %out

if.end45:                                         ; preds = %if.end29
  %base46 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %6, i32 0, i32 0
  %tgt47 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %2, i32 0, i32 0
  %23 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt47, align 8, !tbaa !61
  %node_id = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %23, i32 0, i32 5
  %24 = load i32, i32* %node_id, align 4, !tbaa !134
  %command_block_agent_address = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %2, i32 0, i32 4
  %25 = load i64, i64* %command_block_agent_address, align 8, !tbaa !140
  %add = add i64 %25, 8
  call void @sbp2_send_orb(%struct.sbp2_orb* %base46, %struct.sbp2_logical_unit* %2, i32 %24, i32 %12, i64 %add)
  br label %out

out:                                              ; preds = %if.end45, %if.then42, %land.lhs.true
  %retval2.0 = phi i32 [ 4181, %if.then42 ], [ 0, %if.end45 ], [ 4181, %land.lhs.true ]
  %base48 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %6, i32 0, i32 0
  %kref49 = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base48, i32 0, i32 1
  call void @kref_put(%struct.arch_spinlock* %kref49, void (%struct.arch_spinlock*)* @free_orb)
  br label %cleanup

cleanup:                                          ; preds = %out, %if.end, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ %retval2.0, %out ], [ 4181, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_scsi_abort(%struct.scsi_cmnd* %cmd) #2 {
entry:
  %device = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 0
  %0 = load %struct.scsi_device*, %struct.scsi_device** %device, align 8, !tbaa !148
  %hostdata = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %0, i32 0, i32 23
  %1 = load i8*, i8** %hostdata, align 8, !tbaa !153
  %2 = bitcast i8* %1 to %struct.sbp2_logical_unit*
  %call = call %struct.device* @lu_dev(%struct.sbp2_logical_unit* %2)
  %call1 = call i32 (%struct.device*, i8*, ...) @dev_notice(%struct.device* %call, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.8, i32 0, i32 0))
  call void @sbp2_agent_reset(%struct.sbp2_logical_unit* %2)
  %call2 = call i32 @sbp2_cancel_orbs(%struct.sbp2_logical_unit* %2)
  ret i32 8194
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_scsi_slave_alloc(%struct.scsi_device* %sdev) #2 {
entry:
  %hostdata = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 23
  %0 = load i8*, i8** %hostdata, align 8, !tbaa !153
  %1 = bitcast i8* %0 to %struct.sbp2_logical_unit*
  %tobool = icmp ne %struct.sbp2_logical_unit* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %allow_restart = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 37
  %2 = bitcast i48* %allow_restart to i64*
  %bf.load = load i64, i64* %2, align 4
  %bf.clear = and i64 %bf.load, -134217729
  %bf.set = or i64 %bf.clear, 134217728
  store i64 %bf.set, i64* %2, align 4
  %request_queue = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 1
  %3 = load %struct.request_queue*, %struct.request_queue** %request_queue, align 8, !tbaa !171
  call void @blk_queue_update_dma_alignment(%struct.request_queue* %3, i32 3)
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %4 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !61
  %workarounds = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %4, i32 0, i32 7
  %5 = load i32, i32* %workarounds, align 4, !tbaa !119
  %and = and i32 %5, 2
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then2, label %cleanup

if.then2:                                         ; preds = %if.end
  %inquiry_len = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 27
  store i8 36, i8* %inquiry_len, align 1, !tbaa !172
  br label %cleanup

cleanup:                                          ; preds = %if.then2, %if.end, %entry
  %retval.0 = phi i32 [ -38, %entry ], [ 0, %if.then2 ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_scsi_slave_configure(%struct.scsi_device* %sdev) #2 {
entry:
  %hostdata = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 23
  %0 = load i8*, i8** %hostdata, align 8, !tbaa !153
  %1 = bitcast i8* %0 to %struct.sbp2_logical_unit*
  %use_10_for_rw = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 37
  %2 = bitcast i48* %use_10_for_rw to i64*
  %bf.load = load i64, i64* %2, align 4
  %bf.clear = and i64 %bf.load, -131073
  %bf.set = or i64 %bf.clear, 131072
  store i64 %bf.set, i64* %2, align 4
  %3 = load i8, i8* @sbp2_param_exclusive_login, align 1, !tbaa !84, !range !64
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %manage_start_stop = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 37
  %4 = bitcast i48* %manage_start_stop to i64*
  %bf.load1 = load i64, i64* %4, align 4
  %bf.clear2 = and i64 %bf.load1, -268435457
  %bf.set3 = or i64 %bf.clear2, 268435456
  store i64 %bf.set3, i64* %4, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %type = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 24
  %5 = load i8, i8* %type, align 8, !tbaa !173
  %conv = sext i8 %5 to i32
  %cmp = icmp eq i32 %conv, 5
  br i1 %cmp, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.end
  %use_10_for_ms = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 37
  %6 = bitcast i48* %use_10_for_ms to i64*
  %bf.load6 = load i64, i64* %6, align 4
  %bf.clear7 = and i64 %bf.load6, -262145
  %bf.set8 = or i64 %bf.clear7, 262144
  store i64 %bf.set8, i64* %6, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then5, %if.end
  %type10 = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 24
  %7 = load i8, i8* %type10, align 8, !tbaa !173
  %conv11 = sext i8 %7 to i32
  %cmp12 = icmp eq i32 %conv11, 0
  br i1 %cmp12, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %if.end9
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %8 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !61
  %workarounds = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %8, i32 0, i32 7
  %9 = load i32, i32* %workarounds, align 4, !tbaa !119
  %and = and i32 %9, 4
  %tobool14 = icmp ne i32 %and, 0
  br i1 %tobool14, label %if.then15, label %if.end19

if.then15:                                        ; preds = %land.lhs.true
  %skip_ms_page_8 = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 37
  %10 = bitcast i48* %skip_ms_page_8 to i64*
  %bf.load16 = load i64, i64* %10, align 4
  %bf.clear17 = and i64 %bf.load16, -4194305
  %bf.set18 = or i64 %bf.clear17, 4194304
  store i64 %bf.set18, i64* %10, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then15, %land.lhs.true, %if.end9
  %tgt20 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %11 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt20, align 8, !tbaa !61
  %workarounds21 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %11, i32 0, i32 7
  %12 = load i32, i32* %workarounds21, align 4, !tbaa !119
  %and22 = and i32 %12, 8
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end28

if.then24:                                        ; preds = %if.end19
  %fix_capacity = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 37
  %13 = bitcast i48* %fix_capacity to i64*
  %bf.load25 = load i64, i64* %13, align 4
  %bf.clear26 = and i64 %bf.load25, -4294967297
  %bf.set27 = or i64 %bf.clear26, 4294967296
  store i64 %bf.set27, i64* %13, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.then24, %if.end19
  %tgt29 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %14 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt29, align 8, !tbaa !61
  %workarounds30 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %14, i32 0, i32 7
  %15 = load i32, i32* %workarounds30, align 4, !tbaa !119
  %and31 = and i32 %15, 32
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.then33, label %if.end37

if.then33:                                        ; preds = %if.end28
  %start_stop_pwr_cond = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 37
  %16 = bitcast i48* %start_stop_pwr_cond to i64*
  %bf.load34 = load i64, i64* %16, align 4
  %bf.clear35 = and i64 %bf.load34, -536870913
  %bf.set36 = or i64 %bf.clear35, 536870912
  store i64 %bf.set36, i64* %16, align 4
  br label %if.end37

if.end37:                                         ; preds = %if.then33, %if.end28
  %tgt38 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %1, i32 0, i32 0
  %17 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt38, align 8, !tbaa !61
  %workarounds39 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %17, i32 0, i32 7
  %18 = load i32, i32* %workarounds39, align 4, !tbaa !119
  %and40 = and i32 %18, 1
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.end37
  %request_queue = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %sdev, i32 0, i32 1
  %19 = load %struct.request_queue*, %struct.request_queue** %request_queue, align 8, !tbaa !171
  call void @blk_queue_max_hw_sectors(%struct.request_queue* %19, i32 256)
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %if.end37
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i64 @sbp2_sysfs_ieee1394_id_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #2 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -432
  %1 = bitcast i8* %add.ptr to %struct.scsi_device*
  %tobool = icmp ne %struct.scsi_device* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %hostdata = getelementptr inbounds %struct.scsi_device, %struct.scsi_device* %1, i32 0, i32 23
  %2 = load i8*, i8** %hostdata, align 8, !tbaa !153
  %3 = bitcast i8* %2 to %struct.sbp2_logical_unit*
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %3, i32 0, i32 0
  %4 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !61
  %guid = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %4, i32 0, i32 3
  %5 = load i64, i64* %guid, align 8, !tbaa !38
  %tgt1 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %3, i32 0, i32 0
  %6 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt1, align 8, !tbaa !61
  %directory_id = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %6, i32 0, i32 4
  %7 = load i32, i32* %directory_id, align 8, !tbaa !44
  %lun = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %3, i32 0, i32 5
  %8 = load i16, i16* %lun, align 8, !tbaa !53
  %conv = zext i16 %8 to i32
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.10, i32 0, i32 0), i64 %5, i32 %7, i32 %conv)
  %conv2 = sext i32 %call to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv2, %if.end ], [ 0, %entry ]
  ret i64 %retval.0
}

declare i32 @sprintf(i8*, i8*, ...) #1

declare void @blk_queue_max_hw_sectors(%struct.request_queue*, i32) #1

declare void @blk_queue_update_dma_alignment(%struct.request_queue*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @scsi_sg_count(%struct.scsi_cmnd* %cmd) #3 {
entry:
  %sdb = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 13
  %table = getelementptr inbounds %struct.scsi_data_buffer, %struct.scsi_data_buffer* %sdb, i32 0, i32 0
  %nents = getelementptr inbounds %struct.sg_table, %struct.sg_table* %table, i32 0, i32 1
  %0 = load i32, i32* %nents, align 8, !tbaa !174
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_map_scatterlist(%struct.sbp2_command_orb* %orb, %struct.fw_device* %device, %struct.sbp2_logical_unit* %lu) #2 {
entry:
  %cmd = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 2
  %0 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd, align 8, !tbaa !163
  %call = call %struct.scatterlist* @scsi_sglist(%struct.scsi_cmnd* %0)
  %cmd1 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 2
  %1 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd1, align 8, !tbaa !163
  %call2 = call i32 @scsi_dma_map(%struct.scsi_cmnd* %1)
  %cmp = icmp sle i32 %call2, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp3 = icmp eq i32 %call2, 1
  br i1 %cmp3, label %if.then4, label %if.end11

if.then4:                                         ; preds = %if.end
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %2 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !61
  %address_high = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %2, i32 0, i32 6
  %3 = load i32, i32* %address_high, align 8, !tbaa !135
  %call5 = call i32 @__fswab32(i32 %3) #6
  %request = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 1
  %data_descriptor = getelementptr inbounds %struct.anon.53, %struct.anon.53* %request, i32 0, i32 1
  %high = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %data_descriptor, i32 0, i32 0
  store i32 %call5, i32* %high, align 8, !tbaa !175
  %dma_address = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %call, i32 0, i32 4
  %4 = load i64, i64* %dma_address, align 8, !tbaa !176
  %conv = trunc i64 %4 to i32
  %call6 = call i32 @__fswab32(i32 %conv) #6
  %request7 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 1
  %data_descriptor8 = getelementptr inbounds %struct.anon.53, %struct.anon.53* %request7, i32 0, i32 1
  %low = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %data_descriptor8, i32 0, i32 1
  store i32 %call6, i32* %low, align 4, !tbaa !178
  %dma_length = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %call, i32 0, i32 5
  %5 = load i32, i32* %dma_length, align 8, !tbaa !179
  %call9 = call i32 @__fswab32(i32 %5) #6
  %request10 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 1
  %misc = getelementptr inbounds %struct.anon.53, %struct.anon.53* %request10, i32 0, i32 2
  %6 = load i32, i32* %misc, align 8, !tbaa !165
  %or = or i32 %6, %call9
  store i32 %or, i32* %misc, align 8, !tbaa !165
  br label %cleanup

if.end11:                                         ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end11
  %sg.0 = phi %struct.scatterlist* [ %call, %if.end11 ], [ %call24, %for.body ]
  %i.0 = phi i32 [ 0, %if.end11 ], [ %inc, %for.body ]
  %cmp12 = icmp slt i32 %i.0, %call2
  br i1 %cmp12, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %dma_length14 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg.0, i32 0, i32 5
  %7 = load i32, i32* %dma_length14, align 8, !tbaa !179
  %shl = shl i32 %7, 16
  %call15 = call i32 @__fswab32(i32 %shl) #6
  %page_table = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 4
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [128 x %struct.exception_table_entry], [128 x %struct.exception_table_entry]* %page_table, i64 0, i64 %idxprom
  %high16 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %arrayidx, i32 0, i32 0
  store i32 %call15, i32* %high16, align 8, !tbaa !96
  %dma_address17 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg.0, i32 0, i32 4
  %8 = load i64, i64* %dma_address17, align 8, !tbaa !176
  %conv18 = trunc i64 %8 to i32
  %call19 = call i32 @__fswab32(i32 %conv18) #6
  %page_table20 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 4
  %idxprom21 = sext i32 %i.0 to i64
  %arrayidx22 = getelementptr inbounds [128 x %struct.exception_table_entry], [128 x %struct.exception_table_entry]* %page_table20, i64 0, i64 %idxprom21
  %low23 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %arrayidx22, i32 0, i32 1
  store i32 %call19, i32* %low23, align 4, !tbaa !98
  %inc = add nsw i32 %i.0, 1
  %call24 = call %struct.scatterlist* @sg_next(%struct.scatterlist* %sg.0)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %device, i32 0, i32 5
  %9 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %device25 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %9, i32 0, i32 1
  %10 = load %struct.device*, %struct.device** %device25, align 8, !tbaa !32
  %page_table26 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 4
  %arraydecay = getelementptr inbounds [128 x %struct.exception_table_entry], [128 x %struct.exception_table_entry]* %page_table26, i32 0, i32 0
  %11 = bitcast %struct.exception_table_entry* %arraydecay to i8*
  %call27 = call i64 @dma_map_single_attrs(%struct.device* %10, i8* %11, i64 1024, i32 1, %struct.sigset_t* null)
  %page_table_bus = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 5
  store i64 %call27, i64* %page_table_bus, align 8, !tbaa !180
  %card28 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %device, i32 0, i32 5
  %12 = load %struct.fw_card*, %struct.fw_card** %card28, align 8, !tbaa !2
  %device29 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %12, i32 0, i32 1
  %13 = load %struct.device*, %struct.device** %device29, align 8, !tbaa !32
  %page_table_bus30 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 5
  %14 = load i64, i64* %page_table_bus30, align 8, !tbaa !180
  %call31 = call i32 @dma_mapping_error(%struct.device* %13, i64 %14)
  %tobool = icmp ne i32 %call31, 0
  br i1 %tobool, label %fail_page_table, label %if.end33

if.end33:                                         ; preds = %for.end
  %tgt34 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %15 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt34, align 8, !tbaa !61
  %address_high35 = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %15, i32 0, i32 6
  %16 = load i32, i32* %address_high35, align 8, !tbaa !135
  %call36 = call i32 @__fswab32(i32 %16) #6
  %request37 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 1
  %data_descriptor38 = getelementptr inbounds %struct.anon.53, %struct.anon.53* %request37, i32 0, i32 1
  %high39 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %data_descriptor38, i32 0, i32 0
  store i32 %call36, i32* %high39, align 8, !tbaa !175
  %page_table_bus40 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 5
  %17 = load i64, i64* %page_table_bus40, align 8, !tbaa !180
  %conv41 = trunc i64 %17 to i32
  %call42 = call i32 @__fswab32(i32 %conv41) #6
  %request43 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 1
  %data_descriptor44 = getelementptr inbounds %struct.anon.53, %struct.anon.53* %request43, i32 0, i32 1
  %low45 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %data_descriptor44, i32 0, i32 1
  store i32 %call42, i32* %low45, align 4, !tbaa !178
  %or46 = or i32 524288, %call2
  %call47 = call i32 @__fswab32(i32 %or46) #6
  %request48 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 1
  %misc49 = getelementptr inbounds %struct.anon.53, %struct.anon.53* %request48, i32 0, i32 2
  %18 = load i32, i32* %misc49, align 8, !tbaa !165
  %or50 = or i32 %18, %call47
  store i32 %or50, i32* %misc49, align 8, !tbaa !165
  br label %cleanup

fail_page_table:                                  ; preds = %for.end
  %cmd51 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 2
  %19 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd51, align 8, !tbaa !163
  call void @scsi_dma_unmap(%struct.scsi_cmnd* %19)
  br label %cleanup

cleanup:                                          ; preds = %fail_page_table, %if.end33, %if.then4, %entry
  %retval.0 = phi i32 [ 0, %if.then4 ], [ 0, %if.end33 ], [ -12, %entry ], [ -12, %fail_page_table ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @complete_command_orb(%struct.sbp2_orb* %base_orb, %struct.sbp2_status* %status) #2 {
entry:
  %0 = bitcast %struct.sbp2_orb* %base_orb to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sbp2_command_orb*
  %lu = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %1, i32 0, i32 3
  %2 = load %struct.sbp2_logical_unit*, %struct.sbp2_logical_unit** %lu, align 8, !tbaa !162
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %2, i32 0, i32 0
  %3 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !61
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %3)
  %cmp = icmp ne %struct.sbp2_status* %status, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %status1 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  %4 = load i32, i32* %status1, align 4, !tbaa !130
  %shr = lshr i32 %4, 27
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %lu3 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %1, i32 0, i32 3
  %5 = load %struct.sbp2_logical_unit*, %struct.sbp2_logical_unit** %lu3, align 8, !tbaa !162
  call void @sbp2_agent_reset_no_wait(%struct.sbp2_logical_unit* %5)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %status4 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  %6 = load i32, i32* %status4, align 4, !tbaa !130
  %shr5 = lshr i32 %6, 28
  %and6 = and i32 %shr5, 3
  %Pivot4 = icmp slt i32 %and6, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %and6, 2
  br i1 %Pivot, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %and6, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %NodeBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %NodeBlock
  %result.0 = phi i32 [ 458752, %sw.default ], [ 0, %LeafBlock ], [ 131072, %NodeBlock ]
  %cmp9 = icmp eq i32 %result.0, 0
  br i1 %cmp9, label %land.lhs.true, label %if.end18

land.lhs.true:                                    ; preds = %sw.epilog
  %status10 = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 0
  %7 = load i32, i32* %status10, align 4, !tbaa !130
  %shr11 = lshr i32 %7, 24
  %and12 = and i32 %shr11, 7
  %cmp13 = icmp ugt i32 %and12, 1
  br i1 %cmp13, label %if.then14, label %if.end18

if.then14:                                        ; preds = %land.lhs.true
  %data = getelementptr inbounds %struct.sbp2_status, %struct.sbp2_status* %status, i32 0, i32 2
  %arraydecay = getelementptr inbounds [24 x i8], [24 x i8]* %data, i32 0, i32 0
  %cmd = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %1, i32 0, i32 2
  %8 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd, align 8, !tbaa !163
  %sense_buffer = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %8, i32 0, i32 18
  %9 = load i8*, i8** %sense_buffer, align 8, !tbaa !181
  %call15 = call i32 @sbp2_status_to_sense_data(i8* %arraydecay, i8* %9)
  br label %if.end18

if.else:                                          ; preds = %entry
  %lu17 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %1, i32 0, i32 3
  %10 = load %struct.sbp2_logical_unit*, %struct.sbp2_logical_unit** %lu17, align 8, !tbaa !162
  call void @sbp2_conditionally_block(%struct.sbp2_logical_unit* %10)
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then14, %land.lhs.true, %sw.epilog
  %result.2 = phi i32 [ 131072, %if.else ], [ %call15, %if.then14 ], [ %result.0, %land.lhs.true ], [ %result.0, %sw.epilog ]
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %11 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %device19 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %11, i32 0, i32 1
  %12 = load %struct.device*, %struct.device** %device19, align 8, !tbaa !32
  %base = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %1, i32 0, i32 0
  %request_bus = getelementptr inbounds %struct.sbp2_orb, %struct.sbp2_orb* %base, i32 0, i32 2
  %13 = load i64, i64* %request_bus, align 8, !tbaa !170
  call void @dma_unmap_single_attrs(%struct.device* %12, i64 %13, i64 36, i32 1, %struct.sigset_t* null)
  %card20 = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %14 = load %struct.fw_card*, %struct.fw_card** %card20, align 8, !tbaa !2
  %device21 = getelementptr inbounds %struct.fw_card, %struct.fw_card* %14, i32 0, i32 1
  %15 = load %struct.device*, %struct.device** %device21, align 8, !tbaa !32
  call void @sbp2_unmap_scatterlist(%struct.device* %15, %struct.sbp2_command_orb* %1)
  %cmd22 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %1, i32 0, i32 2
  %16 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd22, align 8, !tbaa !163
  %result23 = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %16, i32 0, i32 22
  store i32 %result.2, i32* %result23, align 8, !tbaa !157
  %cmd24 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %1, i32 0, i32 2
  %17 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd24, align 8, !tbaa !163
  %scsi_done = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %17, i32 0, i32 19
  %18 = load void (%struct.scsi_cmnd*)*, void (%struct.scsi_cmnd*)** %scsi_done, align 8, !tbaa !158
  %cmd25 = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %1, i32 0, i32 2
  %19 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd25, align 8, !tbaa !163
  call void %18(%struct.scsi_cmnd* %19)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbp2_unmap_scatterlist(%struct.device* %card_device, %struct.sbp2_command_orb* %orb) #2 {
entry:
  %cmd = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 2
  %0 = load %struct.scsi_cmnd*, %struct.scsi_cmnd** %cmd, align 8, !tbaa !163
  call void @scsi_dma_unmap(%struct.scsi_cmnd* %0)
  %request = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 1
  %misc = getelementptr inbounds %struct.anon.53, %struct.anon.53* %request, i32 0, i32 2
  %1 = load i32, i32* %misc, align 8, !tbaa !165
  %and = and i32 %1, 2048
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %page_table_bus = getelementptr inbounds %struct.sbp2_command_orb, %struct.sbp2_command_orb* %orb, i32 0, i32 5
  %2 = load i64, i64* %page_table_bus, align 8, !tbaa !180
  call void @dma_unmap_single_attrs(%struct.device* %card_device, i64 %2, i64 1024, i32 1, %struct.sigset_t* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @scsi_dma_unmap(%struct.scsi_cmnd*) #1

; Function Attrs: nounwind uwtable
define internal void @sbp2_agent_reset_no_wait(%struct.sbp2_logical_unit* %lu) #2 {
entry:
  %tgt = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %0 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt, align 8, !tbaa !61
  %call = call %struct.fw_device* @target_parent_device(%struct.sbp2_target* %0)
  %call1 = call i8* @kmalloc(i64 288, i32 32)
  %1 = bitcast i8* %call1 to %struct.fw_transaction*
  %cmp = icmp eq %struct.fw_transaction* %1, null
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %card = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 5
  %2 = load %struct.fw_card*, %struct.fw_card** %card, align 8, !tbaa !2
  %tgt2 = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 0
  %3 = load %struct.sbp2_target*, %struct.sbp2_target** %tgt2, align 8, !tbaa !61
  %node_id = getelementptr inbounds %struct.sbp2_target, %struct.sbp2_target* %3, i32 0, i32 5
  %4 = load i32, i32* %node_id, align 4, !tbaa !134
  %generation = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 7
  %5 = load i32, i32* %generation, align 8, !tbaa !65
  %max_speed = getelementptr inbounds %struct.fw_device, %struct.fw_device* %call, i32 0, i32 4
  %6 = load i32, i32* %max_speed, align 8, !tbaa !45
  %command_block_agent_address = getelementptr inbounds %struct.sbp2_logical_unit, %struct.sbp2_logical_unit* %lu, i32 0, i32 4
  %7 = load i64, i64* %command_block_agent_address, align 8, !tbaa !140
  %add = add i64 %7, 4
  %8 = bitcast %struct.fw_transaction* %1 to i8*
  call void @fw_send_request(%struct.fw_card* %2, %struct.fw_transaction* %1, i32 0, i32 %4, i32 %5, i32 %6, i64 %add, i8* bitcast (i32* @sbp2_agent_reset_no_wait.d to i8*), i64 4, void (%struct.fw_card*, i32, i8*, i64, i8*)* @complete_agent_reset_write_no_wait, i8* %8)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end ], [ 1, %entry ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sbp2_status_to_sense_data(i8* %sbp2_status, i8* %sense_data) #2 {
entry:
  %arrayidx = getelementptr inbounds i8, i8* %sbp2_status, i64 0
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !68
  %conv = zext i8 %0 to i32
  %shr = ashr i32 %conv, 6
  %and = and i32 %shr, 3
  %and.off = add i32 %and, -2
  %switch = icmp ult i32 %and.off, 2
  br i1 %switch, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %or = or i32 112, %and
  %arrayidx4 = getelementptr inbounds i8, i8* %sbp2_status, i64 1
  %1 = load i8, i8* %arrayidx4, align 1, !tbaa !68
  %conv5 = zext i8 %1 to i32
  %and6 = and i32 %conv5, 128
  %or7 = or i32 %or, %and6
  %conv8 = trunc i32 %or7 to i8
  %arrayidx9 = getelementptr inbounds i8, i8* %sense_data, i64 0
  store i8 %conv8, i8* %arrayidx9, align 1, !tbaa !68
  %arrayidx10 = getelementptr inbounds i8, i8* %sense_data, i64 1
  store i8 0, i8* %arrayidx10, align 1, !tbaa !68
  %arrayidx11 = getelementptr inbounds i8, i8* %sbp2_status, i64 1
  %2 = load i8, i8* %arrayidx11, align 1, !tbaa !68
  %conv12 = zext i8 %2 to i32
  %shl = shl i32 %conv12, 1
  %and13 = and i32 %shl, 224
  %arrayidx14 = getelementptr inbounds i8, i8* %sbp2_status, i64 1
  %3 = load i8, i8* %arrayidx14, align 1, !tbaa !68
  %conv15 = zext i8 %3 to i32
  %and16 = and i32 %conv15, 15
  %or17 = or i32 %and13, %and16
  %conv18 = trunc i32 %or17 to i8
  %arrayidx19 = getelementptr inbounds i8, i8* %sense_data, i64 2
  store i8 %conv18, i8* %arrayidx19, align 1, !tbaa !68
  %arrayidx20 = getelementptr inbounds i8, i8* %sbp2_status, i64 4
  %4 = load i8, i8* %arrayidx20, align 1, !tbaa !68
  %arrayidx21 = getelementptr inbounds i8, i8* %sense_data, i64 3
  store i8 %4, i8* %arrayidx21, align 1, !tbaa !68
  %arrayidx22 = getelementptr inbounds i8, i8* %sbp2_status, i64 5
  %5 = load i8, i8* %arrayidx22, align 1, !tbaa !68
  %arrayidx23 = getelementptr inbounds i8, i8* %sense_data, i64 4
  store i8 %5, i8* %arrayidx23, align 1, !tbaa !68
  %arrayidx24 = getelementptr inbounds i8, i8* %sbp2_status, i64 6
  %6 = load i8, i8* %arrayidx24, align 1, !tbaa !68
  %arrayidx25 = getelementptr inbounds i8, i8* %sense_data, i64 5
  store i8 %6, i8* %arrayidx25, align 1, !tbaa !68
  %arrayidx26 = getelementptr inbounds i8, i8* %sbp2_status, i64 7
  %7 = load i8, i8* %arrayidx26, align 1, !tbaa !68
  %arrayidx27 = getelementptr inbounds i8, i8* %sense_data, i64 6
  store i8 %7, i8* %arrayidx27, align 1, !tbaa !68
  %arrayidx28 = getelementptr inbounds i8, i8* %sense_data, i64 7
  store i8 10, i8* %arrayidx28, align 1, !tbaa !68
  %arrayidx29 = getelementptr inbounds i8, i8* %sbp2_status, i64 8
  %8 = load i8, i8* %arrayidx29, align 1, !tbaa !68
  %arrayidx30 = getelementptr inbounds i8, i8* %sense_data, i64 8
  store i8 %8, i8* %arrayidx30, align 1, !tbaa !68
  %arrayidx31 = getelementptr inbounds i8, i8* %sbp2_status, i64 9
  %9 = load i8, i8* %arrayidx31, align 1, !tbaa !68
  %arrayidx32 = getelementptr inbounds i8, i8* %sense_data, i64 9
  store i8 %9, i8* %arrayidx32, align 1, !tbaa !68
  %arrayidx33 = getelementptr inbounds i8, i8* %sbp2_status, i64 10
  %10 = load i8, i8* %arrayidx33, align 1, !tbaa !68
  %arrayidx34 = getelementptr inbounds i8, i8* %sense_data, i64 10
  store i8 %10, i8* %arrayidx34, align 1, !tbaa !68
  %arrayidx35 = getelementptr inbounds i8, i8* %sbp2_status, i64 11
  %11 = load i8, i8* %arrayidx35, align 1, !tbaa !68
  %arrayidx36 = getelementptr inbounds i8, i8* %sense_data, i64 11
  store i8 %11, i8* %arrayidx36, align 1, !tbaa !68
  %arrayidx37 = getelementptr inbounds i8, i8* %sbp2_status, i64 2
  %12 = load i8, i8* %arrayidx37, align 1, !tbaa !68
  %arrayidx38 = getelementptr inbounds i8, i8* %sense_data, i64 12
  store i8 %12, i8* %arrayidx38, align 1, !tbaa !68
  %arrayidx39 = getelementptr inbounds i8, i8* %sbp2_status, i64 3
  %13 = load i8, i8* %arrayidx39, align 1, !tbaa !68
  %arrayidx40 = getelementptr inbounds i8, i8* %sense_data, i64 13
  store i8 %13, i8* %arrayidx40, align 1, !tbaa !68
  %arrayidx41 = getelementptr inbounds i8, i8* %sbp2_status, i64 12
  %14 = load i8, i8* %arrayidx41, align 1, !tbaa !68
  %arrayidx42 = getelementptr inbounds i8, i8* %sense_data, i64 14
  store i8 %14, i8* %arrayidx42, align 1, !tbaa !68
  %arrayidx43 = getelementptr inbounds i8, i8* %sbp2_status, i64 13
  %15 = load i8, i8* %arrayidx43, align 1, !tbaa !68
  %arrayidx44 = getelementptr inbounds i8, i8* %sense_data, i64 15
  store i8 %15, i8* %arrayidx44, align 1, !tbaa !68
  %arrayidx45 = getelementptr inbounds i8, i8* %sbp2_status, i64 0
  %16 = load i8, i8* %arrayidx45, align 1, !tbaa !68
  %conv46 = zext i8 %16 to i32
  %and47 = and i32 %conv46, 63
  %Pivot18 = icmp slt i32 %and47, 8
  br i1 %Pivot18, label %NodeBlock5, label %NodeBlock15

NodeBlock15:                                      ; preds = %if.end
  %Pivot16 = icmp slt i32 %and47, 24
  br i1 %Pivot16, label %LeafBlock7, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %and47, 34
  br i1 %Pivot14, label %LeafBlock9, label %LeafBlock11

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %and47, 34
  br i1 %SwitchLeaf12, label %sw.bb, label %cleanup

LeafBlock9:                                       ; preds = %NodeBlock13
  %SwitchLeaf10 = icmp eq i32 %and47, 24
  br i1 %SwitchLeaf10, label %sw.bb, label %cleanup

LeafBlock7:                                       ; preds = %NodeBlock15
  %SwitchLeaf8 = icmp eq i32 %and47, 8
  br i1 %SwitchLeaf8, label %sw.bb, label %cleanup

NodeBlock5:                                       ; preds = %if.end
  %Pivot6 = icmp slt i32 %and47, 2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %and47, 4
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %and47, 4
  br i1 %SwitchLeaf4, label %sw.bb, label %cleanup

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and47, 2
  br i1 %SwitchLeaf2, label %sw.bb, label %cleanup

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %and47, 0
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock11
  %or48 = or i32 0, %and47
  br label %cleanup

cleanup:                                          ; preds = %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock11, %entry
  %retval.0 = phi i32 [ %or48, %sw.bb ], [ 458752, %entry ], [ 458752, %LeafBlock ], [ 458752, %LeafBlock1 ], [ 458752, %LeafBlock3 ], [ 458752, %LeafBlock7 ], [ 458752, %LeafBlock9 ], [ 458752, %LeafBlock11 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @complete_agent_reset_write_no_wait(%struct.fw_card* %card, i32 %rcode, i8* %payload, i64 %length, i8* %data) #2 {
entry:
  call void @kfree(i8* %data)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.scatterlist* @scsi_sglist(%struct.scsi_cmnd* %cmd) #3 {
entry:
  %sdb = getelementptr inbounds %struct.scsi_cmnd, %struct.scsi_cmnd* %cmd, i32 0, i32 13
  %table = getelementptr inbounds %struct.scsi_data_buffer, %struct.scsi_data_buffer* %sdb, i32 0, i32 0
  %sgl = getelementptr inbounds %struct.sg_table, %struct.sg_table* %table, i32 0, i32 0
  %0 = load %struct.scatterlist*, %struct.scatterlist** %sgl, align 8, !tbaa !182
  ret %struct.scatterlist* %0
}

declare i32 @scsi_dma_map(%struct.scsi_cmnd*) #1

declare %struct.scatterlist* @sg_next(%struct.scatterlist*) #1

; Function Attrs: nounwind uwtable
define internal void @sbp2_cleanup() #0 section ".exit.text" {
entry:
  call void @driver_unregister(%struct.device_driver* getelementptr inbounds (%struct.fw_driver, %struct.fw_driver* @sbp2_driver, i32 0, i32 0))
  ret void
}

declare void @driver_unregister(%struct.device_driver*) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind }
attributes #5 = { inlinehint nounwind readnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readnone }
attributes #7 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nounwind }

!llvm.ident = !{!0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{!3, !8, i64 32}
!3 = !{!"fw_device", !4, i64 0, !8, i64 8, !5, i64 16, !5, i64 20, !5, i64 24, !8, i64 32, !9, i64 40, !13, i64 1176, !11, i64 1344, !8, i64 1360, !16, i64 1368, !5, i64 1376, !5, i64 1380, !5, i64 1380, !5, i64 1380, !5, i64 1380, !5, i64 1380, !29, i64 1384, !30, i64 1608}
!4 = !{!"", !5, i64 0}
!5 = !{!"int", !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C/C++ TBAA"}
!8 = !{!"any pointer", !6, i64 0}
!9 = !{!"device", !8, i64 0, !8, i64 8, !10, i64 16, !8, i64 80, !8, i64 88, !13, i64 96, !8, i64 264, !8, i64 272, !8, i64 280, !17, i64 288, !8, i64 880, !5, i64 888, !8, i64 896, !25, i64 904, !8, i64 912, !11, i64 920, !8, i64 936, !26, i64 944, !8, i64 960, !27, i64 968, !5, i64 976, !5, i64 980, !14, i64 984, !11, i64 1056, !28, i64 1072, !8, i64 1104, !8, i64 1112, !8, i64 1120, !8, i64 1128}
!10 = !{!"kobject", !8, i64 0, !11, i64 8, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !12, i64 56, !5, i64 60, !5, i64 60, !5, i64 60, !5, i64 60, !5, i64 60}
!11 = !{!"list_head", !8, i64 0, !8, i64 8}
!12 = !{!"kref", !4, i64 0}
!13 = !{!"mutex", !4, i64 0, !14, i64 8, !11, i64 80, !8, i64 96, !8, i64 104, !8, i64 112, !15, i64 120}
!14 = !{!"spinlock", !6, i64 0}
!15 = !{!"lockdep_map", !8, i64 0, !6, i64 8, !8, i64 24, !5, i64 32, !16, i64 40}
!16 = !{!"long", !6, i64 0}
!17 = !{!"dev_pm_info", !18, i64 0, !5, i64 4, !5, i64 4, !19, i64 4, !19, i64 4, !19, i64 4, !19, i64 4, !14, i64 8, !11, i64 80, !20, i64 96, !8, i64 192, !19, i64 200, !19, i64 200, !22, i64 208, !16, i64 336, !23, i64 344, !21, i64 424, !4, i64 512, !4, i64 516, !5, i64 520, !5, i64 520, !5, i64 520, !5, i64 520, !5, i64 520, !5, i64 520, !5, i64 521, !5, i64 521, !5, i64 521, !5, i64 521, !5, i64 521, !6, i64 524, !6, i64 528, !5, i64 532, !5, i64 536, !16, i64 544, !16, i64 552, !16, i64 560, !16, i64 568, !8, i64 576, !8, i64 584}
!18 = !{!"pm_message", !5, i64 0}
!19 = !{!"_Bool", !6, i64 0}
!20 = !{!"completion", !5, i64 0, !21, i64 8}
!21 = !{!"__wait_queue_head", !14, i64 0, !11, i64 72}
!22 = !{!"timer_list", !11, i64 0, !16, i64 16, !8, i64 24, !8, i64 32, !16, i64 40, !5, i64 48, !5, i64 52, !8, i64 56, !6, i64 64, !15, i64 80}
!23 = !{!"work_struct", !24, i64 0, !11, i64 8, !8, i64 24, !15, i64 32}
!24 = !{!"", !16, i64 0}
!25 = !{!"long long", !6, i64 0}
!26 = !{!"dev_archdata", !8, i64 0, !8, i64 8}
!27 = !{!"acpi_dev_node", !8, i64 0}
!28 = !{!"klist_node", !8, i64 0, !11, i64 8, !12, i64 24}
!29 = !{!"delayed_work", !23, i64 0, !22, i64 80, !8, i64 208, !5, i64 216}
!30 = !{!"fw_attribute_group", !6, i64 0, !31, i64 16, !6, i64 40}
!31 = !{!"attribute_group", !8, i64 0, !8, i64 8, !8, i64 16}
!32 = !{!33, !8, i64 8}
!33 = !{!"fw_card", !8, i64 0, !8, i64 8, !12, i64 16, !20, i64 24, !5, i64 120, !5, i64 124, !5, i64 128, !25, i64 136, !11, i64 144, !25, i64 160, !5, i64 168, !5, i64 172, !5, i64 176, !5, i64 180, !25, i64 184, !5, i64 192, !5, i64 196, !5, i64 200, !14, i64 208, !8, i64 280, !8, i64 288, !8, i64 296, !6, i64 304, !5, i64 308, !19, i64 312, !5, i64 316, !11, i64 320, !11, i64 336, !29, i64 352, !19, i64 576, !29, i64 584, !5, i64 808, !5, i64 812, !5, i64 816, !19, i64 820, !19, i64 821, !19, i64 822, !19, i64 823, !5, i64 824, !6, i64 828, !5, i64 1852}
!34 = !{!35, !8, i64 0}
!35 = !{!"sbp2_target", !8, i64 0, !11, i64 8, !25, i64 24, !25, i64 32, !5, i64 40, !5, i64 44, !5, i64 48, !5, i64 52, !5, i64 56, !5, i64 60, !5, i64 64, !5, i64 68}
!36 = !{!3, !8, i64 1360}
!37 = !{!5, !5, i64 0}
!38 = !{!35, !25, i64 32}
!39 = !{!40, !41, i64 584}
!40 = !{!"Scsi_Host", !11, i64 0, !11, i64 16, !8, i64 32, !14, i64 40, !11, i64 112, !11, i64 128, !14, i64 144, !8, i64 216, !13, i64 224, !11, i64 392, !8, i64 408, !8, i64 416, !21, i64 424, !8, i64 512, !8, i64 520, !8, i64 528, !5, i64 536, !5, i64 540, !5, i64 544, !5, i64 548, !5, i64 552, !16, i64 560, !5, i64 568, !5, i64 572, !5, i64 576, !5, i64 580, !41, i64 584, !5, i64 588, !5, i64 592, !41, i64 596, !41, i64 598, !41, i64 600, !41, i64 602, !16, i64 608, !16, i64 616, !5, i64 624, !5, i64 624, !5, i64 624, !5, i64 624, !5, i64 624, !5, i64 624, !5, i64 624, !5, i64 625, !5, i64 625, !5, i64 625, !6, i64 626, !8, i64 648, !5, i64 656, !5, i64 660, !5, i64 664, !6, i64 668, !8, i64 672, !16, i64 680, !16, i64 688, !6, i64 696, !6, i64 697, !5, i64 700, !6, i64 704, !9, i64 712, !9, i64 1848, !11, i64 2984, !8, i64 3000, !8, i64 3008, !6, i64 3016}
!41 = !{!"short", !6, i64 0}
!42 = !{!43, !8, i64 1136}
!43 = !{!"fw_unit", !9, i64 0, !8, i64 1136, !30, i64 1144}
!44 = !{!35, !5, i64 40}
!45 = !{!3, !5, i64 24}
!46 = !{!33, !5, i64 192}
!47 = !{!35, !5, i64 60}
!48 = !{!8, !8, i64 0}
!49 = !{!11, !8, i64 0}
!50 = !{!51, !8, i64 8}
!51 = !{!"sbp2_logical_unit", !8, i64 0, !11, i64 8, !52, i64 24, !11, i64 72, !25, i64 88, !41, i64 96, !5, i64 100, !5, i64 104, !5, i64 108, !29, i64 112, !19, i64 336, !19, i64 337}
!52 = !{!"fw_address_handler", !25, i64 0, !25, i64 8, !8, i64 16, !8, i64 24, !11, i64 32}
!53 = !{!51, !41, i64 96}
!54 = !{!51, !5, i64 100}
!55 = !{!3, !5, i64 20}
!56 = !{i32 -2143434818}
!57 = !{!3, !5, i64 16}
!58 = !{!40, !5, i64 548}
!59 = !{!51, !5, i64 108}
!60 = !{!43, !8, i64 0}
!61 = !{!51, !8, i64 0}
!62 = !{!35, !5, i64 64}
!63 = !{!51, !19, i64 337}
!64 = !{i8 0, i8 2}
!65 = !{!51, !5, i64 104}
!66 = !{!33, !5, i64 124}
!67 = !{!35, !5, i64 68}
!68 = !{!6, !6, i64 0}
!69 = !{!70, !25, i64 384}
!70 = !{!"sbp2_management_orb", !71, i64 0, !74, i64 336, !6, i64 368, !25, i64 384, !20, i64 392, !76, i64 488}
!71 = !{!"sbp2_orb", !72, i64 0, !12, i64 288, !25, i64 296, !5, i64 304, !8, i64 312, !11, i64 320}
!72 = !{!"fw_transaction", !5, i64 0, !5, i64 4, !11, i64 8, !8, i64 24, !19, i64 32, !22, i64 40, !73, i64 168, !8, i64 272, !8, i64 280}
!73 = !{!"fw_packet", !5, i64 0, !5, i64 4, !6, i64 8, !16, i64 24, !8, i64 32, !16, i64 40, !25, i64 48, !19, i64 56, !5, i64 60, !8, i64 64, !5, i64 72, !11, i64 80, !8, i64 96}
!74 = !{!"", !75, i64 0, !75, i64 8, !5, i64 16, !5, i64 20, !75, i64 24}
!75 = !{!"sbp2_pointer", !5, i64 0, !5, i64 4}
!76 = !{!"sbp2_status", !5, i64 0, !5, i64 4, !6, i64 8}
!77 = !{!70, !5, i64 344}
!78 = !{!70, !5, i64 348}
!79 = !{!70, !5, i64 352}
!80 = !{!70, !5, i64 356}
!81 = !{!51, !25, i64 24}
!82 = !{!70, !5, i64 360}
!83 = !{!70, !5, i64 364}
!84 = !{!19, !19, i64 0}
!85 = !{!35, !5, i64 56}
!86 = !{!70, !8, i64 312}
!87 = !{!70, !25, i64 296}
!88 = !{!35, !25, i64 24}
!89 = !{!70, !5, i64 304}
!90 = !{!70, !5, i64 488}
!91 = !{i32 -2143698515, i32 -2143698490, i32 -2143698220, i32 -2143698423, i32 -2143698392, i32 -2143698362}
!92 = !{!93, !8, i64 32}
!93 = !{!"dma_map_ops", !8, i64 0, !8, i64 8, !8, i64 16, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !8, i64 56, !8, i64 64, !8, i64 72, !8, i64 80, !8, i64 88, !8, i64 96, !8, i64 104, !8, i64 112, !5, i64 120}
!94 = !{!93, !8, i64 96}
!95 = !{!20, !5, i64 0}
!96 = !{!75, !5, i64 0}
!97 = !{!71, !25, i64 296}
!98 = !{!75, !5, i64 4}
!99 = !{!71, !8, i64 320}
!100 = !{!71, !5, i64 304}
!101 = !{!71, !8, i64 312}
!102 = !{i32 -2143697165, i32 -2143697140, i32 -2143696870, i32 -2143697073, i32 -2143697042, i32 -2143697012}
!103 = !{!93, !8, i64 40}
!104 = !{i32 -2146063442, i32 -2146063403, i32 -2146063382, i32 -2146063345, i32 -2146063322, i32 -2146063452}
!105 = !{!9, !8, i64 944}
!106 = !{!11, !8, i64 8}
!107 = !{i32 -2146060595, i32 -2146060556, i32 -2146060535, i32 -2146060498, i32 -2146060475, i32 -2146060466}
!108 = !{i32 588040}
!109 = !{!4, !5, i64 0}
!110 = !{!9, !8, i64 912}
!111 = !{!112, !5, i64 0}
!112 = !{!"device_dma_parameters", !5, i64 0, !16, i64 8}
!113 = !{!114, !8, i64 0}
!114 = !{!"fw_csr_iterator", !8, i64 0, !8, i64 8}
!115 = !{!116, !5, i64 0}
!116 = !{!"", !5, i64 0, !5, i64 4, !5, i64 8}
!117 = !{!116, !5, i64 4}
!118 = !{!116, !5, i64 8}
!119 = !{!35, !5, i64 52}
!120 = !{!51, !25, i64 32}
!121 = !{!51, !8, i64 40}
!122 = !{!51, !8, i64 48}
!123 = !{!51, !19, i64 336}
!124 = !{!24, !16, i64 0}
!125 = !{i64 0, i64 8, !126}
!126 = !{!16, !16, i64 0}
!127 = !{!23, !8, i64 24}
!128 = !{!22, !8, i64 32}
!129 = !{!22, !16, i64 40}
!130 = !{!76, !5, i64 0}
!131 = !{!76, !5, i64 4}
!132 = !{i32 -2143445645}
!133 = !{!33, !5, i64 120}
!134 = !{!35, !5, i64 44}
!135 = !{!35, !5, i64 48}
!136 = !{i32 -2143445531}
!137 = !{!138, !5, i64 4}
!138 = !{!"sbp2_login_response", !5, i64 0, !75, i64 4, !5, i64 12}
!139 = !{!138, !5, i64 8}
!140 = !{!51, !25, i64 88}
!141 = !{!138, !5, i64 0}
!142 = !{i32 -2143442755}
!143 = !{i32 -2143442707}
!144 = !{i32 -2143442659}
!145 = !{i32 -2143442096}
!146 = !{i32 -2143442032}
!147 = !{i32 -2143441784}
!148 = !{!149, !8, i64 0}
!149 = !{!"scsi_cmnd", !8, i64 0, !11, i64 8, !11, i64 24, !5, i64 40, !16, i64 48, !16, i64 56, !5, i64 64, !5, i64 68, !6, i64 72, !6, i64 73, !41, i64 74, !6, i64 76, !8, i64 80, !150, i64 88, !8, i64 112, !5, i64 120, !5, i64 124, !8, i64 128, !8, i64 136, !8, i64 144, !152, i64 152, !8, i64 216, !5, i64 224, !6, i64 228}
!150 = !{!"scsi_data_buffer", !151, i64 0, !5, i64 16, !5, i64 20}
!151 = !{!"sg_table", !8, i64 0, !5, i64 8, !5, i64 12}
!152 = !{!"scsi_pointer", !8, i64 0, !5, i64 8, !8, i64 16, !5, i64 24, !25, i64 32, !5, i64 40, !5, i64 44, !5, i64 48, !5, i64 52, !5, i64 56}
!153 = !{!154, !8, i64 224}
!154 = !{!"scsi_device", !8, i64 0, !8, i64 8, !11, i64 16, !11, i64 32, !5, i64 48, !14, i64 56, !11, i64 128, !11, i64 144, !8, i64 160, !41, i64 168, !41, i64 170, !41, i64 172, !41, i64 174, !16, i64 176, !16, i64 184, !16, i64 192, !5, i64 200, !5, i64 204, !5, i64 208, !5, i64 212, !5, i64 216, !8, i64 224, !6, i64 232, !6, i64 233, !6, i64 234, !6, i64 235, !8, i64 240, !8, i64 248, !8, i64 256, !8, i64 264, !6, i64 272, !8, i64 280, !5, i64 288, !5, i64 292, !5, i64 292, !5, i64 292, !5, i64 292, !5, i64 292, !5, i64 292, !5, i64 292, !5, i64 292, !5, i64 293, !5, i64 293, !5, i64 293, !5, i64 293, !5, i64 293, !5, i64 293, !5, i64 293, !5, i64 293, !5, i64 294, !5, i64 294, !5, i64 294, !5, i64 294, !5, i64 294, !5, i64 294, !5, i64 294, !5, i64 294, !5, i64 295, !5, i64 295, !5, i64 295, !5, i64 295, !5, i64 295, !5, i64 295, !5, i64 295, !5, i64 295, !5, i64 296, !5, i64 296, !5, i64 296, !5, i64 296, !5, i64 296, !5, i64 296, !5, i64 296, !5, i64 296, !5, i64 297, !5, i64 297, !4, i64 300, !6, i64 304, !11, i64 312, !23, i64 328, !5, i64 408, !5, i64 412, !4, i64 416, !4, i64 420, !4, i64 424, !9, i64 432, !9, i64 1568, !155, i64 2704, !23, i64 2784, !8, i64 2864, !6, i64 2872, !6, i64 2880}
!155 = !{!"execute_work", !23, i64 0}
!156 = !{!149, !6, i64 76}
!157 = !{!149, !5, i64 224}
!158 = !{!149, !8, i64 144}
!159 = !{!160, !5, i64 304}
!160 = !{!"sbp2_command_orb", !71, i64 0, !161, i64 336, !8, i64 376, !8, i64 384, !6, i64 392, !25, i64 1416}
!161 = !{!"", !75, i64 0, !75, i64 8, !5, i64 16, !6, i64 20}
!162 = !{!160, !8, i64 384}
!163 = !{!160, !8, i64 376}
!164 = !{!160, !5, i64 336}
!165 = !{!160, !5, i64 352}
!166 = !{i32 -2143426560}
!167 = !{!149, !41, i64 74}
!168 = !{!149, !8, i64 80}
!169 = !{!160, !8, i64 312}
!170 = !{!160, !25, i64 296}
!171 = !{!154, !8, i64 8}
!172 = !{!154, !6, i64 235}
!173 = !{!154, !6, i64 232}
!174 = !{!149, !5, i64 96}
!175 = !{!160, !5, i64 344}
!176 = !{!177, !25, i64 24}
!177 = !{!"scatterlist", !16, i64 0, !16, i64 8, !5, i64 16, !5, i64 20, !25, i64 24, !5, i64 32}
!178 = !{!160, !5, i64 348}
!179 = !{!177, !5, i64 32}
!180 = !{!160, !25, i64 1416}
!181 = !{!149, !8, i64 136}
!182 = !{!149, !8, i64 88}

//===---------- SimplifyKernelGlobalsPassTest.cpp - Unit tests -------------==//
//
//       SimpLL - Program simplifier for analysis of semantic difference      //
//
// This file is published under Apache 2.0 license. See LICENSE for details.
// Author: Tomas Glozar, tglozar@gmail.com
//===----------------------------------------------------------------------===//
///
/// \file
/// This file contains unit tests for the SimplifyKernelGlobalsPass pass.
///
//===----------------------------------------------------------------------===//

#include <gtest/gtest.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/PassManager.h>
#include <llvm/Passes/PassBuilder.h>
#include <passes/SimplifyKernelGlobalsPass.h>

/// Utility function to create a void-returning empty function without
/// arguments and with external linkage.
static Function *createFunction(std::string Name, Module *Mod) {
    return Function::Create(
            FunctionType::get(Type::getVoidTy(Mod->getContext()), {}, false),
            GlobalValue::ExternalLinkage,
            Name,
            Mod);
}

/// Utility function to create a Int8 global variable.
static GlobalVariable *
        createGlobalVariable(std::string Name, int Initializer, Module *Mod) {
    return new GlobalVariable(
            *Mod,
            Type::getInt8Ty(Mod->getContext()),
            true,
            GlobalValue::ExternalLinkage,
            ConstantInt::get(Type::getInt8Ty(Mod->getContext()), Initializer),
            Name);
}

/// Utility function to add a direct call between functions generated by
/// createFunction.
static void addCall(Function *Src, Function *Dest) {
    BasicBlock *BB;
    if (Src->isDeclaration()) {
        BB = BasicBlock::Create(Src->getParent()->getContext(), "", Src);
    } else {
        BB = &*Src->getBasicBlockList().begin();
    }

    CallInst::Create(Dest, {}, "", BB);
}

static void simplifyKernelGlobals(Module *Mod) {
    ModulePassManager mpm(false);
    ModuleAnalysisManager mam(false);
    PassBuilder pb;
    pb.registerModuleAnalyses(mam);
    mpm.addPass(SimplifyKernelGlobalsPass{});
    mpm.run(*Mod, mam);
}

/// Tests the removing of global variables with names starting with __ksym.
/// Also creates an llvm.used table and checks their removal from it.
TEST(SimplifyKernelGlobalsPass, KSymRemoval) {
    LLVMContext Ctx;
    Module *Mod = new Module("test", Ctx);

    // Create two global variables with names starting with __ksym and one
    // without it.
    auto GV1 = createGlobalVariable("__ksym_test_1", 0, Mod);
    auto GV2 = createGlobalVariable("__ksym_test_2", 1, Mod);
    auto GV3 = createGlobalVariable("ksym_test_3", 2, Mod);

    // Create a global variable with a struct initializer.
    auto StrTy = StructType::create(Ctx, {GV3->getType()});
    StrTy->setName("struct.test");
    auto ConstStr = ConstantStruct::get(StrTy, {GV3});
    auto GV4 = new GlobalVariable(*Mod,
                                  StrTy,
                                  true,
                                  GlobalValue::ExternalLinkage,
                                  ConstStr,
                                  "__ksym_test_3");

    // Create the llvm.used global variable.
    std::vector<Constant *> UsedElems;
    for (GlobalVariable *GV : {GV1, GV2, GV3, GV4}) {
        UsedElems.push_back(ConstantExpr::getBitCast(
                GV, PointerType::get(Type::getVoidTy(Ctx), 0)));
    }
    auto UsedArray = ConstantArray::get(
            ArrayType::get(PointerType::get(Type::getVoidTy(Ctx), 0), 3),
            UsedElems);
    new GlobalVariable(*Mod,
                       UsedArray->getType(),
                       true,
                       GlobalValue::ExternalLinkage,
                       UsedArray,
                       "llvm.used");

    // Run the pass and check the results.
    simplifyKernelGlobals(Mod);

    // Check whether the right global variable were removed.
    ASSERT_FALSE(Mod->getGlobalVariable("__ksym_test_1"));
    ASSERT_FALSE(Mod->getGlobalVariable("__ksym_test_2"));
    ASSERT_FALSE(Mod->getGlobalVariable("__ksym_test_3"));
    ASSERT_EQ(Mod->getGlobalVariable("ksym_test_3"), GV3);

    // Check the uses of GV3 (if there are two or more, it means the initializer
    // of GV4 wasn't removed properly).
    ASSERT_EQ(++GV3->uses().begin(), GV3->uses().end());

    // Check llvm.used (only GV3 should be in the initializer).
    auto TestUsedGV = Mod->getGlobalVariable("llvm.used");
    ASSERT_TRUE(TestUsedGV);
    ASSERT_TRUE(TestUsedGV->hasInitializer());
    auto TestUsedArray = dyn_cast<ConstantArray>(TestUsedGV->getInitializer());
    ASSERT_TRUE(TestUsedArray);
    ASSERT_EQ(TestUsedArray->getNumOperands(), 1);
    auto TestCast = dyn_cast<ConstantExpr>(TestUsedArray->getOperand(0));
    ASSERT_TRUE(TestCast);
    ASSERT_EQ(TestCast->getOpcode(), Instruction::BitCast);
    ASSERT_EQ(TestCast->getOperand(0), GV3);
}

/// Tests merging of compile time assert functions.
TEST(SimplifyKernelGlobalsPass, CompileTimeAssertMerging) {
    LLVMContext Ctx;
    Module *Mod = new Module("test", Ctx);

    // Create three functions - one with the name __compiletime_assert and two
    // with a name containing __compiletime_assert.
    // Also create one function with a different name.
    std::vector<Function *> Funs{
            createFunction("__compiletime_assert", Mod),
            createFunction("test1__compiletime_assert", Mod),
            createFunction("test2__compiletime_assert__", Mod),
            createFunction("test", Mod)};

    // Create a main function calling all three of the them.
    Function *Main = createFunction("main", Mod);
    BasicBlock *BB = BasicBlock::Create(Ctx, "", Main);
    for (Function *Fun : Funs) {
        CallInst::Create(Fun, {}, "", BB);
    }
    ReturnInst::Create(Ctx, BB);

    // Run the pass and check whether the calls were replaced correctly.
    simplifyKernelGlobals(Mod);
    auto Iter = BB->begin();
    for (int i = 0; i < 4; i++) {
        ASSERT_NE(Iter, BB->end());
        auto Call = dyn_cast<CallInst>(&*Iter);
        ASSERT_TRUE(Call);
        auto CalledFun = Call->getCalledFunction();
        ASSERT_TRUE(CalledFun);
        ASSERT_TRUE(CalledFun->hasName());
        ASSERT_EQ(CalledFun->getName(),
                  (i < 3) ? "__compiletime_assert" : "test");
        ++Iter;
    }
    ASSERT_NE(Iter, BB->end());
    ASSERT_TRUE(isa<ReturnInst>(&*Iter));
    ++Iter;
    ASSERT_EQ(Iter, BB->end());
}
